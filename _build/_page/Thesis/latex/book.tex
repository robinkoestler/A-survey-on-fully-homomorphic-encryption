%% Generated by Sphinx.
\def\sphinxdocclass{jupyterBook}
\documentclass[letterpaper,10pt,english]{jupyterBook}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}
%% turn off hyperref patch of \index as sphinx.xdy xindy module takes care of
%% suitable \hyperpage mark-up, working around hyperref-xindy incompatibility
\PassOptionsToPackage{hyperindex=false}{hyperref}
%% memoir class requires extra handling
\makeatletter\@ifclassloaded{memoir}
{\ifdefined\memhyperindexfalse\memhyperindexfalse\fi}{}\makeatother

\PassOptionsToPackage{warn}{textcomp}

\catcode`^^^^00a0\active\protected\def^^^^00a0{\leavevmode\nobreak\ }
\usepackage{cmap}
\usepackage{fontspec}
\defaultfontfeatures[\rmfamily,\sffamily,\ttfamily]{}
\usepackage{amsmath,amssymb,amstext}
\usepackage{polyglossia}
\setmainlanguage{english}



\setmainfont{FreeSerif}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Italic,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldItalic
]
\setsansfont{FreeSans}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]
\setmonofont{FreeMono}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]



\usepackage[Bjarne]{fncychap}
\usepackage[,numfigreset=1,mathnumfig]{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}



        % Start of preamble defined in sphinx-jupyterbook-latex %
         \usepackage[Latin,Greek]{ucharclasses}
        \usepackage{unicode-math}
        % fixing title of the toc
        \addto\captionsenglish{\renewcommand{\contentsname}{Contents}}
        \hypersetup{
            pdfencoding=auto,
            psdextra
        }
        % End of preamble defined in sphinx-jupyterbook-latex %
        

\title{A survey on modern fully homomorphic encryption}
\date{Nov 15, 2022}
\release{}
\author{Robin Köstler}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{Thesis::doc}}

\begin{equation*}
\begin{split}\newcommand{\norm}[1]{\left\lvert\left\lvert #1 \right\rvert\right\rvert_\infty}
\newcommand{\abs}[1]{\left\lvert #1 \right\rvert}
\newcommand{\round}[1]{\left\lfloor #1 \right\rceil}
\newcommand{\Z}{\mathbb Z}
\renewcommand{\P}{\mathbb P}
\newcommand{\R}{\mathbb R}
\newcommand{\Q}{\mathbb Q}
\newcommand{\RLWE}{\mathrm{RLWE}}
\newcommand{\RLWEx}{\mathrm{RLWE'}}
\newcommand{\RGSW}{\mathrm{RGSW}}\end{split}
\end{equation*}\phantomsection\label{\detokenize{Thesis:introduction}}
\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\Large Introduction}
\end{DUlineblock}

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Fully homomorphic encryption}
\end{DUlineblock}

\sphinxAtStartPar
Fully homomorphic encryption (FHE) has been a major field of research in the area of cryptography in recent years.
Simply put, its objective can be described as performing operations on data that is securely hidden in an encryption (ciphertext).
For this reason, FHE features a broad range of applications, e.g. secure cloud computing.

\sphinxAtStartPar
The two homomorphic operations considered are additions and multiplications.
This is sufficient since technically every deterministic algorithm can be expressed by NAND gates.
A NAND gate for two bits \(b_1,b_2 \in \{0,1\}\) is defined as \(\mathrm{NAND}(b_1,b_2) = 1 - b_1b_2 \in \{0,1\}\) and thus only requires one addition and one multiplication modulo 2.

\sphinxAtStartPar
In general, the modern FHE approach relies on encryptions, which are based on errors.
These errors gradually increase during homomorphic operations and there is a bound in error size to which extent a correct decryption is still possible.
Therefore we require a procedure of reducing an accumulated error to its initial size (comparable to a “fresh” encryption error), and in doing so, arbitrarily many homomorphic operations (FHE) become achievable.
Gentry, who published the first FHE scheme in {[}\hyperlink{cite.Thesis:id77}{Gentry, 2009}{]}, named this procedure bootstrapping.

\sphinxAtStartPar
For more (historical) information about FHE see e.g. Section 6.1. in {[}\hyperlink{cite.Thesis:id65}{Peikert, 2015}{]}.

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Summary of the thesis}
\end{DUlineblock}

\sphinxAtStartPar
The thesis is organized as follows:
\begin{itemize}
\item {} 
\sphinxAtStartPar
In the rest of chapter 1, the {\hyperref[\detokenize{Thesis:introduction}]{\sphinxcrossref{\DUrole{std,std-ref}{Introduction}}}}, we provide notation and implementation details.

\item {} 
\sphinxAtStartPar
In Chapter 2, {\hyperref[\detokenize{Thesis:ring-learning-with-errors}]{\sphinxcrossref{\DUrole{std,std-ref}{Ring learning with errors (RLWE)}}}}, we explore the framework of the state\sphinxhyphen{}of\sphinxhyphen{}the\sphinxhyphen{}art notion of (RLWE) ciphertexts.
In doing so, we first investigate the properties of the ring \(R\) and its modular arithmetic variants, which serve as plaintext/ciphertext spaces.
We proceed to define a measure, i.e. \(\norm \cdot\), to keep track of the “size” of ring elements, e.g. the errors required for encryptions.
We also thoroughly analyse the probabilistic nature of \(\norm \cdot\)\sphinxhyphen{}bounds during adding/multiplying ring elements, as this later helps us to properly understand error growth in various contexts.
Lastly, we give a decent overview of security terms and definitions connected to modern ring learning with errors cryptosystems.

\item {} 
\sphinxAtStartPar
In Chapter 3, {\hyperref[\detokenize{Thesis:the-bfv-scheme}]{\sphinxcrossref{\DUrole{std,std-ref}{The BFV scheme}}}}, we examine the underlying encoding scheme (published in {[}\hyperlink{cite.Thesis:id70}{Fan and Vercauteren, 2012}{]}), which provides algorithms for (secret/public) key\sphinxhyphen{}generation, encryption, decryption, addition and multiplication of ciphertexts.
Special focus is laid on the error growth during the homomorphic operations, since these results heavily influence the overall running time, if one thinks of bootstrapping as an expensive intermission between performing additions/multiplications.
For that matter, we derive a bound for correct decryption and analyse the performance (depending on the choice of parameters) computationally.

\item {} 
\sphinxAtStartPar
In Chapter 4, {\hyperref[\detokenize{Thesis:preparations-for-bootstrapping}]{\sphinxcrossref{\DUrole{std,std-ref}{Preparations for bootstrapping}}}}, we establish methods to limit the error growth during multiplication, which is mandatory for our bootstrapping algorithm to be functional.
To achieve this, we introduce alterations/extensions of the fundamental RLWE ciphertexts and analyse the corresponding algorithms.
Furthermore, we investigate the two common auxiliary operations automorphism evaluation and rescaling.

\item {} 
\sphinxAtStartPar
In Chapter 5, {\hyperref[\detokenize{Thesis:bootstrapping}]{\sphinxcrossref{\DUrole{std,std-ref}{Bootstrapping}}}}, we finally present the core algorithm (published in {[}\hyperlink{cite.Thesis:id72}{Kim \sphinxstyleemphasis{et al.}, 2021}{]}), which itself primarily contains the auxiliary part \(\texttt{scaled-mod}\), whose target is the realization of a non\sphinxhyphen{}trivial multiplication with a large constant.
Splitting up the latter algorithm into three parts and also splitting up the problem into a large magnitude of subproblems will reveal, why bootstrapping is a computationally costly procedure after all.
We conclude the description of the bootstrapping procedure by adapting it to the employed scheme of encoding, i.e. BFV.
During the entire chapter, we will particularly emphasize a detailed error discussion, the (optimal) parameter selection, and the runtime analysis.
As a proof of concept, we computationally review the bootstrapping scheme by verifying the correctness, inspecting the runtime, and rechecking the parameter selection.
At last, we look into a simple application of fully homomorphic encryption, i.e. how to realize a more complex homomorphic operation, namely integer comparison e.g. used for the evaluation of if\sphinxhyphen{}statements.

\end{itemize}

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Notation}
\end{DUlineblock}
\begin{itemize}
\item {} 
\sphinxAtStartPar
With \(\round \cdot\) (respectively \(\lceil \cdot \rceil\) and \(\lfloor \cdot \rfloor\)) we denote the rounding function to the nearest integer (respectively up/down), which will be extended to polynomials coefficient\sphinxhyphen{}wise and to vectors entry\sphinxhyphen{}wise.

\item {} 
\sphinxAtStartPar
Since most of our variables will be of polynomial nature, to avoid confusion we will denote vectors as \(\vec v\).
For vectors, we will write the scalar product as \(\langle \cdot, \cdot \rangle\).

\item {} 
\sphinxAtStartPar
Algorithms will be indicated in \(\texttt{algorithm}\) textstyle.
The symbol ‘ will correspond to a \(\texttt{x}\) inside algorithms, e.g. \(\mathrm{RLWE'}\) becomes \(\texttt{rlwe-x}\).

\item {} 
\sphinxAtStartPar
The abbreviation i.i.d. in the context of random variables stands for “identically and independently distributed”.

\end{itemize}

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Implementation details}
\end{DUlineblock}

\sphinxAtStartPar
The implementation of the bootstrapping scheme relies on the separate Python file “polynomial\_arithmetic.py”, which performs polynomial arithmetic and other useful operations on polynomials in {\hyperref[\detokenize{Thesis:the-ring-r}]{\sphinxcrossref{\DUrole{std,std-ref}{The ring R}}}}.
The framework of the Python file originates in {[}\hyperlink{cite.Thesis:id75}{Erabelli, 2020}{]}, which has been partly modified and extended.
The main motivation using this framework, has been the lack of a (simple) Python package, which handles the arithmetic of arbitrarily long integers as coefficients of polynomials in the above ring.
The Python file includes extensive descriptions of its algorithms.

\sphinxAtStartPar
The main contribution was the implementation of a faster multiplication algorithm, namely the Karatsuba algorithm, which, contrary to the state\sphinxhyphen{}of\sphinxhyphen{}the\sphinxhyphen{}art multiplication techniques, is simpler to implement from scratch and most importantly directly applicable to any ciphertext modulus \(Q\) and ring degree \(N\) (these parameters will be examined in {\hyperref[\detokenize{Thesis:the-modular-variant-of-the-ring-r}]{\sphinxcrossref{\DUrole{std,std-ref}{The modular variant of the ring R}}}}).
In the original file, i.e. in {[}\hyperlink{cite.Thesis:id75}{Erabelli, 2020}{]}, the modern Fast Fourier Transform (FFT) multiplication algorithm is included, which is considerably faster compared to Karatsuba, but not applicable to powers of two as bootstrapping parameters (e.g. \(Q\)).
Since powers of two greatly simplify the mathematical analysis of the scheme and furthermore implementing techniques and algorithm speed are not the main concerns of this thesis, we have chosen to omit FFT implementation.

\sphinxAtStartPar
In general, multiplying efficiently is extremely important, since the bootstrapping procedure bases on multiplications of polynomials.
Apart from handling polynomials in the ring as a class object, we also import auxiliary functions generating polynomials, whose coefficients have certain properties, e.g. being drawn from a specific distribution (see {\hyperref[\detokenize{Thesis:background-on-probability-theory}]{\sphinxcrossref{\DUrole{std,std-ref}{Background on probability theory}}}}).

\sphinxAtStartPar
Further inspiration for implementing the somewhat homomorphic BFV scheme in Python (see {\hyperref[\detokenize{Thesis:the-bfv-scheme}]{\sphinxcrossref{\DUrole{std,std-ref}{The BFV scheme}}}}) has been drawn from {[}\hyperlink{cite.Thesis:id76}{Bolboceanu \sphinxstyleemphasis{et al.}, 2020}{]}.
The full implementation, including an online jupyter book version of the thesis featuring executable code cells, can be found at \sphinxurl{https://github.com/robinkoestler/A-survey-on-modern-fully-homomorphic-encryption}.

\sphinxAtStartPar
The bootstrapping implementation, which is split up among many auxiliary procedures throughout the document, will be analyzed in a step\sphinxhyphen{}by\sphinxhyphen{}step fashion.

\sphinxAtStartPar
Below we import all necessary external Python packages and the class to handle polynomial arithmetic as \(\texttt{Poly}\).
The variable \(\texttt{speed}\) linearly controls the running time and it may be augmented to obtain more precise computational results in the case of probabilistic bounds for example.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{polynomial\PYGZus{}arithmetic}\PYG{o}{,} \PYG{n+nn}{random}
\PYG{k+kn}{from} \PYG{n+nn}{polynomial\PYGZus{}arithmetic} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{k+kn}{from} \PYG{n+nn}{timeit} \PYG{k+kn}{import} \PYG{n}{default\PYGZus{}timer} \PYG{k}{as} \PYG{n}{timer}
\PYG{k+kn}{from} \PYG{n+nn}{datetime} \PYG{k+kn}{import} \PYG{n}{timedelta}
\PYG{k+kn}{from} \PYG{n+nn}{math} \PYG{k+kn}{import} \PYG{n}{log}\PYG{p}{,} \PYG{n}{floor}\PYG{p}{,} \PYG{n}{ceil}\PYG{p}{,} \PYG{n}{sqrt}\PYG{p}{,} \PYG{n}{gcd}\PYG{p}{,} \PYG{n}{exp}\PYG{p}{,} \PYG{n}{pi}\PYG{p}{,} \PYG{n}{erf}
\PYG{n}{Poly} \PYG{o}{=} \PYG{n}{polynomial\PYGZus{}arithmetic}\PYG{o}{.}\PYG{n}{Polynomial} \PYG{c+c1}{\PYGZsh{} the class of handling polynomial arithmetic in R.}
\PYG{n}{speed} \PYG{o}{=} \PYG{l+m+mi}{100} \PYG{c+c1}{\PYGZsh{} precision factor for computations: Scales the running time.}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}\phantomsection\label{\detokenize{Thesis:ring-learning-with-errors}}
\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Ring learning with errors (RLWE)}
\end{DUlineblock}
\phantomsection\label{\detokenize{Thesis:the-ring-r}}
\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{The ring \(R\)}
\end{DUlineblock}

\sphinxAtStartPar
Our cryptographic scheme will work with polynomials, which are elements of the ring \(R := \Z[x]/\langle x^N +1 \rangle\) with a power of two \(N > 1\).
We will often refer to the coefficients \(c_0,\dots,c_{N-1} \in \Z\) of an element \(r(x) \in R\) by using the standard \(r(x) = \sum_{i=0}^{N-1} c_i x^i\) representation.

\sphinxAtStartPar
There are many reasons for the choice of \(R\):
\begin{itemize}
\item {} 
\sphinxAtStartPar
First and foremost, in the described scheme we are working within discrete structures (messages, ciphertexts, etc. built on elements of \(\Z\)).
Thus we have the advantage of the simplicity of representing everything via integers, whereas in approximate cryptographic schemes (like CKKS, where \(\R\) or \(\mathbb C\) are used, see {[}\hyperlink{cite.Thesis:id69}{Cheon \sphinxstyleemphasis{et al.}, 2017}{]}) one has to worry about rounding errors during computations, which e.g. affect the message precision.

\item {} 
\sphinxAtStartPar
We are generally using polynomial rings to ensure that the basic ring operations (addition and multiplication) can be efficiently calculated by computers without too much effort concerning implementing techniques of the latter.

\item {} 
\sphinxAtStartPar
After multiplying two ring elements, we are left to reduce the result modulo \(x^N + 1\), which is as simple as a sign change and adding two polynomials in \(R\), because \(x^N = -1\) in \(R\).
Compared to the regular polynomial division for arbitrary polynomial quotient rings, this is computationally close to optimal.

\item {} 
\sphinxAtStartPar
At last, we have the property of having no nonzero zero divisors in \(R\), which avoids possible degeneration by performing ring operations:

\end{itemize}
\label{Thesis:R_integral}
\begin{sphinxadmonition}{note}{Theorem 1}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}
\sphinxAtStartPar
Proof. \(x^N+1\) is the \(2N\)\sphinxhyphen{}th cyclotomic polynomial.
All cyclotomic polynomials are irreducible over \(\Q[x]\) and monic, thus they are irreducible over \(\Z[x]\), too.
Because \(\Z\) and \(\Z[x]\) are both unique factorization domains, \(x^N+1 \in \Z[x]\) is a prime element equivalently to being irreducible over \(\Z[x]\).
It follows that the ideal \(I = \langle x^N +1 \rangle\) is a prime ideal and therefore \(R = \Z[x]/I\) is an integral domain.
\end{sphinxadmonition}
\phantomsection\label{\detokenize{Thesis:the-modular-variant-of-the-ring-r}}
\sphinxAtStartPar
\(R\) is an integral domain.

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{The modular variant of the ring \(R\)}
\end{DUlineblock}

\sphinxAtStartPar
The above ring \(R\) cannot possibly degenerate nonzero elements to zero during ring operations, but nevertheless, it contains infinitely many elements \sphinxhyphen{} a property we want to avoid while using a similar structure for message/ciphertext spaces.
The introduction of a power of two modulus \(M > 1\) to define the finite quotient ring \(R_M := R/MR\) resolves this issue and has the following impacts:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Because of the finiteness, we are now able to choose elements of \(R_M\) uniformly at random.
This will later be necessary to define the Decision\sphinxhyphen{}RLWE (see {\hyperref[\detokenize{Thesis:decision-RLWE}]{\sphinxcrossref{Definition 3}}}) problem, upon which the security of our scheme is based.

\item {} 
\sphinxAtStartPar
To uniquely represent the coefficients of a polynomial in \(R_M\), we will use the set of integers inside \((-M/2,M/2]\).
Naturally, this is advantageous for two reasons.
\begin{itemize}
\item {} 
\sphinxAtStartPar
Firstly, it allows a coefficient to be sampled from zero\sphinxhyphen{}centered distributions.

\item {} 
\sphinxAtStartPar
Secondly, compared to e.g. \([0,M-1]\) it halves the maximum absolute value a polynomial coefficient can reach and therefore is an optimal choice regarding the complexity of algorithms operating on integers.

\end{itemize}

\item {} 
\sphinxAtStartPar
By using different power of two moduli as \(M\), we can adjust our plaintext/ciphertext/bootstrapping space size to our necessities.
Switching between these will be easily done by just embedding (from small to large modulus) respectively by a modular reduction of the coefficients (and vice versa).

\end{itemize}

\sphinxAtStartPar
To illustrate the benefit of modular variants of \(R\), let us consider a small message space, e.g. \(R_8\), and a larger (ciphertext) space, e.g. \(R_{32}\), without a further specified \(N\).
Technically, we could just trivially embed an example message \(2x+1 \in R_8\) into the larger ring as \(2x+1 \in R_{32}\).
But since we furthermore need to introduce additive errors, which make our scheme secure and also alter ring elements slightly, we can use a different, more sophisticated embedding into \(R_{32}\) than just enlarging the space in general.
For this example consider the ring\sphinxhyphen{}dependent expansion factor \(\kappa := 32/8 = 4\) and the switching of rings procedure:
\begin{equation*}
\begin{split}\underbrace{2x+1}_{\in R_8} \overset{\cdot \kappa}{\dashrightarrow} \underbrace{8x+4}_{\in R_{32}} \overset{+ e }{\dashrightarrow} \underbrace{9x+3}_{\in R_{32}} \overset{: \kappa}{\dashrightarrow} \underbrace{2.25 x + 0.75}_{\in\Q[x]/\langle x^N+1 \rangle} \overset{\round \cdot}{\dashrightarrow} \underbrace{2x+1}_{\in R_8}\end{split}
\end{equation*}
\sphinxAtStartPar
with an error \(e := x-1\).
We observe that instead of irrevokably changing the message by adding \(e\) to \(2x+1\) in \(R_8\), we made use of the larger ring \(R_{32}\) in such a way, that it preserves the message when adding \(e\) in \(R_{32}\) and switching back to \(R_8\) afterwards.
This later becomes a crucial idea in the bootstrapping procedure, where errors are “large”.
The above procedure also highlights that power of two moduli \(M\) generally result in integer \(\kappa\)’s, which keeps the upscaling by \(\kappa\) clean from rounding errors.

\sphinxAtStartPar
To sum it up, we gain security and sizing control by adding modular arithmetic to \(R\).
However, it is worth mentioning that \(R_M\) for powers of two \(M>2\) and \(N\) is no longer an integer domain.
Hence, it is important to keep track of where and when we can reduce a \(R\)\sphinxhyphen{}element modulo \(M\), after performing operations favorably in \(R\) itself.

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Size and norm of ring elements}
\end{DUlineblock}

\sphinxAtStartPar
The above example of switching (modular) rings points out that it is indeed important to distinguish between “small” and “large” ring elements, referring to the “size” of the coefficients.
This size can be measured by the infinity norm adapted to the rings as follows \(\norm{y} := \max \{|y_i| : i \in \{0,\dots,N-1\}\}\), where \(y_i\) are the coefficients of \(y \in R\).
Note that, if especially \(y \in R_M\), this definition already expects the centered reductions \(y_i\) modulo \(M\).

\sphinxAtStartPar
Additionally, let us remark that in contrary to \(R\), \(\norm \cdot\) for \(R_M\) is not a norm in the classical sense, because it is not compatible with modular arithmetic, e.g.:
\begin{equation*}
\begin{split}M = \abs{M/2} \cdot \norm{x+2} \neq \norm{(M/2)(x+2)} = \norm{(M/2)x} = M/2.\end{split}
\end{equation*}
\sphinxAtStartPar
Nevertheless, in \(R\) the norm properties are satisfied, and thus we will mainly work with \(R\) instead of the modular variant, for which we will only reduce at certain times during our computations.
Moreover, later our error within ciphertexts must not surpass a certain bound \(< M/2\) for correct decryptions, so \(\norm \cdot\) will be used to measure the error size.

\phantomsection\label{\detokenize{Thesis:background-on-probability-theory}}
\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Background on probability theory}
\end{DUlineblock}

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Occurring distributions}
\end{DUlineblock}

\sphinxAtStartPar
Let us denote the sampling of \(y\) from a probability distribution \(\mathcal D\) by \(y \sim \mathcal D\).
In the same fashion, we say we sample a ring element \(y \in R\) from a distribution \(\mathcal D\), if we independently and identically sample the related coefficients \(y_0, \dots, y_{N-1}\) of \(x\) each from \(\mathcal D\).

\sphinxAtStartPar
We will use the following distributions for \(y \in \Z\):
\begin{itemize}
\item {} 
\sphinxAtStartPar
Discrete uniform distribution \(\mathcal U(a,b)\): For integers \(a \le b\) and \(i \in \Z \cap [a,b]\) fixed, we have \(\mathbb P(y=i) := 1/(b-a+1)\).
Most of the time, we will use \(\mathcal U(R_M) := \mathcal U(-M/2,M/2)\).
Notice that technically \(-M/2\) is not in the (representative) set \(\Z_{M}\), but for sampling we will use it anyway, since otherwise \(\mathcal U(R_M)\) would have mean one instead of zero.
The overall effect of this on the uniformity of the distribution is quite negligible while using a (typically) large \(M\).

\item {} 
\sphinxAtStartPar
Discrete centered normal distribution \(\mathcal {N}_d(0,\sigma^2)\):
For a (real) standard deviation parameter \(\sigma \ge 0\) and \(i \in \Z\) fixed, we assign \(\mathbb P(y = i) := \int_{i-1/2}^{i+1/2} f_{\mathcal N(0,\sigma^2)}(z) dz\), where \(f_{\mathcal N(0,\sigma^2)}\) is the probability density function of the (continuous) normal distribution \(\mathcal N(0,\sigma^2)\).
In other words, while sampling discretely we simply round the values obtained from the continuous distribution to the nearest integer.
Notice furthermore that \(\mathcal N_d(0,\sigma^2)\), although we denote it in the same way, only has mean zero, but it does not have variance \(\sigma^2\) (see {\hyperref[\detokenize{Thesis:discrete-variance}]{\sphinxcrossref{Lemma 1}}}).

\item {} 
\sphinxAtStartPar
Ternary distribution \(\mathrm{Ter}_\rho\): For a parameter \(\rho \in (0,1)\) define the ternary distribution by \(\mathbb P(y = -1) = \mathbb P(y = 1) = (1-\rho)/2\) and \(\mathbb P(y = 0) = \rho\).
In our implementation, we set \(\rho\) to \(1/3\), thus \(\mathrm{Ter}_{1/3} = \mathcal U(-1,1)\).
Another notable choice: A large \(\rho\) leads to samples of sparse ring elements, which have computational advantages.

\end{itemize}

\sphinxAtStartPar
Efficient bootstrapping relies on a detailed error analysis, whose errors are typically generated from the discrete normal distribution.
Hence, we will need to apply theorems from probability theory to estimate the size of an error (with high probability).
Since errors will also be added and multiplied throughout the bootstrapping scheme, we will proceed to analyse the error growth depending on different operations and distributions.

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{The error function \(\mathrm{erf}\)}
\end{DUlineblock}
\label{Thesis:error-function}
\begin{sphinxadmonition}{note}{Definition 1 (The error function)}
\end{sphinxadmonition}

\sphinxAtStartPar
The error function will be useful to calculate the probability that \(\norm y\) for \(y\in R\) has a certain bound.
\label{Thesis:property-error-function}
\begin{sphinxadmonition}{note}{Property 1 (Properties of \protect\(\mathrm{erf}\protect\))}
\end{sphinxadmonition}

\sphinxAtStartPar
For \(x \in \R\), the error function \(\mathrm{erf}(x)\) is given by:
\begin{equation*}
\begin{split}\mathrm{erf}(x) := \frac{2}{\sqrt{\pi}} \int_0^x e^{-t^2}dt.\end{split}
\end{equation*}
\sphinxAtStartPar
Let \(F(x)\) be the cumulative distribution function of the normal distribution \(\mathcal N(0, \sigma^2)\). Then for a corresponding random variable \(X\) we have:
\begin{equation*}
\begin{split}\P(\abs X \le x) \overset{\text{if } x > 0}{=} \mathrm{erf}(x/\sqrt{2\sigma^2}) = 2F(x) -1 = F(x) - F(-x).\end{split}
\end{equation*}
\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Bounds for the normal distribution}
\end{DUlineblock}

\sphinxAtStartPar
Suppose we sample \(y \in R\) from \(\mathcal N_d(0,\sigma^2)\) and want to derive a bound on \(\norm y\) for further computations.
Naturally, only a probabilistic bound can be achieved here.
Thus we consider the scenario: Determine the small probability \(p_{\text{norm}}(k)\) for which \(\norm y \le k\cdot \sigma\) holds for various \(k \in \mathbb N\).

\sphinxAtStartPar
For a single coefficient \(y_i \in \Z\) of \(y\), we have by definition:
\begin{equation*}
\begin{split}p := \P(\abs{y_i} \le k \cdot \sigma) = \mathrm{erf}\left( \frac{\lfloor k\sigma \rfloor + 1/2}{\sqrt{2}\sigma}\right).\end{split}
\end{equation*}
\sphinxAtStartPar
Because the \(y_i\) are i.i.d. samples, we have that
\begin{equation}\label{equation:Thesis:bernoulli-estimation}
\begin{split}    p_{\text{norm}}(k) = \P(\norm y \le k \cdot \sigma) = p^N \ge 1 - N (1-p).\end{split}
\end{equation}
\sphinxAtStartPar
using the maximum inside \(\norm \cdot\) and Bernoulli’s inequality.
\label{Thesis:sampling-bound}
\begin{sphinxadmonition}{note}{Theorem 2 (Norm bounds for standard Gaussian sampling in \protect\(R\protect\))}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}
\sphinxAtStartPar
Proof. Following the above discussion, all left to show is the bound of \(\mathrm{erf}\). This follows because \(\mathrm{erf}\) is strictly increasing and thus estimating \((\lfloor k \sigma \rfloor + 1/2)/\sigma \ge (k-1)\) with \(\sigma \ge 1\) yields the result.
\end{sphinxadmonition}

\sphinxAtStartPar
We now want to determine pairs \((k,p_{\text{norm}}(k))\) computationally by using the Bernoulli estimation given in \eqref{equation:Thesis:bernoulli-estimation}, because of precision issues during exponentiation.
For simplicity, we also set \(\sigma = 1\), since it has a negligible effect on the result anyway.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{N} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{4}
\PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{9}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{p} \PYG{o}{=} \PYG{n}{erf}\PYG{p}{(}\PYG{p}{(}\PYG{n}{k}\PYG{o}{+}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{o}{/}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{k = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{k}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ leads to 1\PYGZhy{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{N}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{*(1\PYGZhy{}p) = }\PYG{l+s+si}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{N}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{p}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
k = 3 leads to 1\PYGZhy{}10000*(1\PYGZhy{}p) = \PYGZhy{}3.6525815807108017
k = 4 leads to 1\PYGZhy{}10000*(1\PYGZhy{}p) = 0.9320465375052258
k = 5 leads to 1\PYGZhy{}10000*(1\PYGZhy{}p) = 0.9996202087504393
k = 6 leads to 1\PYGZhy{}10000*(1\PYGZhy{}p) = 0.999999196800271
k = 7 leads to 1\PYGZhy{}10000*(1\PYGZhy{}p) = 0.9999999993616218
k = 8 leads to 1\PYGZhy{}10000*(1\PYGZhy{}p) = 1.0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Computational conclusion: In a secure implementation, the parameter \(N\) is set to around \(10^4\).
Hence, by using \(k=10\) for example, our computations let us surmise that \(\norm{y} > 10\sigma\) only happens with probability \(\approx 10^{-18}\).
Other authors regularly assume a lower \(k\), e.g. \(k=6\), implying a probability of bound\sphinxhyphen{}exceeding around \(10^{-6}\) per sample.
This is also reasonable, since the norm\sphinxhyphen{}wise equilibrating effects of adding/multiplying elements of \(R\) respectively \(R_M\), which we will soon discuss in detail, will take care of the outliers anyway.

\sphinxAtStartPar
For an \(R\)\sphinxhyphen{}element \(y \sim \mathcal N_d(0,\sigma^2)\) with \(\sigma \ge 1\), we can assume the bound \(\norm y \le k\sigma\) with probability \(\ge \mathrm{erf}\left( (k-1)/\sqrt{2} \right)^N\).

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{Bound for adding two \(R\)\sphinxhyphen{}elements}
\end{DUlineblock}

\sphinxAtStartPar
Let \(x_1,\dots,x_m \in \R\) be independently sampled from \(\mathcal N(0,\sigma^2)\).
It is widely known that \(\sum_{i=1}^m x_i\) has then the distribution \(\mathcal N(0,m\sigma^2)\).
We observe that in this case, the sum of variants equals the variance of the sum (Bienaymé’s identity for i.i.d. random variables).
To bound \(\norm{y+z}\) for independent \(y,z \in R\) and \(y,z \sim \mathcal N_d(0,\sigma^2)\), we therefore have to determine the variance of the distribution \(\mathcal N_d(0,\sigma^2)\).
\label{Thesis:discrete-variance}
\begin{sphinxadmonition}{note}{Lemma 1 (Variance of rounded centered normal distributions)}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}
\sphinxAtStartPar
Proof. We will use the result from Equation 3.2. in {[}\hyperlink{cite.Thesis:id62}{Tricker, 1984}{]}, which treats our case for \(a=0\).
For a more detailed derivation of a proof of this equation, we refer to {[}\hyperlink{cite.Thesis:id63}{An, 2021}{]}.
Following these papers, we have:
\begin{equation*}
\begin{split}\mathrm{Var}(X) = \sigma^2 + \frac{1}{12} + 4 \sum_{k=1}^\infty (-1)^k e^{-2k^2\pi^2\sigma^2} \cdot (\sigma^2 + (2\pi k)^{-2}).\end{split}
\end{equation*}
\sphinxAtStartPar
If we denote by \(a_k\) the sequence in the above series, notice that \(\abs{a_k}\) is strictly decreasing for \(\sigma \ge 1\).
Because \(a_k\) is alternating in sign, starting with \(-1\), we verify our bound \(\sigma^2 + 1/12\) by just ignoring the series in general, since the value of the series will be negative:
\begin{equation*}
\begin{split}\sum_{k=1}^\infty a_k = a_1 + \sum_{k=2}^\infty a_k \le a_1 + a_2 < 0.\end{split}
\end{equation*}\end{sphinxadmonition}

\sphinxAtStartPar
In practice, the above result could even hold for \(\sigma \ge 0.3\), which the computation below points out.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{cdf}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{sigma}\PYG{p}{)}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{} cumulative density function for N(0, sigma\PYGZca{}2)}
    \PYG{k}{return} \PYG{p}{(}\PYG{n}{erf}\PYG{p}{(}\PYG{n}{x}\PYG{o}{/}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{p}{(}\PYG{n}{sigma}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{2}
\PYG{n}{sigma} \PYG{o}{=} \PYG{l+m+mf}{0.3} \PYG{c+c1}{\PYGZsh{} test with 0.1, 0.3, 1}
\PYG{n}{var\PYGZus{}values} \PYG{o}{=} \PYG{p}{[}\PYG{p}{(}\PYG{n}{i}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{*} \PYG{p}{(}\PYG{n}{cdf}\PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{n}{sigma}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{cdf}\PYG{p}{(}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{n}{sigma}\PYG{p}{)}\PYG{p}{)} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1000}\PYG{p}{,}\PYG{l+m+mi}{1000}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{]}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{With sigma = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{sigma}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{, the bound of 1/12 is approximately 1/}\PYG{l+s+si}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{p}{(}\PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{var\PYGZus{}values}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{sigma}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ instead}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
With sigma = 0.3, the bound of 1/12 is approximately 1/179.13363773216952 instead
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Putting everything together, we end up with:
\label{Thesis:norm-bound-adding_R}
\begin{sphinxadmonition}{note}{Theorem 3 (Norm bound for adding \protect\(R\protect\)\sphinxhyphen{}elements)}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}
\sphinxAtStartPar
Proof. We prove the theorem in the same fashion as {\hyperref[\detokenize{Thesis:sampling-bound}]{\sphinxcrossref{Theorem 2}}}, by treating each coefficient \(c\) of \(y \in R\) individually and later using \eqref{equation:Thesis:bernoulli-estimation} to analogously generalize for the ring element \(y\).
So let \(c\) be the sum of \(z_1,\dots,z_m \in \Z\) independently sampled from \(\mathcal N_d(0,\sigma^2)\).
By Bienaymé’s identity and the independence of the \(z_i\), the variance of \(c\) can be bound by \(m\sigma^2 +m/12\) using {\hyperref[\detokenize{Thesis:discrete-variance}]{\sphinxcrossref{Lemma 1}}}.

\sphinxAtStartPar
It is now reasonable to assume that \(c \sim \mathcal N(0,m\sigma^2 +m/12)\) in an approximate way, since the \(z_i\) themselves come from a slightly altered normal distribution.
This argument is supported by the central limit theorem, which yields the exact same distribution \(\mathcal N(0,m\sigma^2 +m/12)\) as an approximation for large \(m\), if one takes the sequence \((z_i) \sim \mathcal N_d(0,\sigma^2)\) as an input.

\sphinxAtStartPar
We compute using {\hyperref[\detokenize{Thesis:property-error-function}]{\sphinxcrossref{Property 1}}}:
\begin{equation*}
\begin{split}\P(\abs c > k\sqrt{m}\sigma) \approx \mathrm{erf}\left( \frac{k\sigma\sqrt{m}}{\sqrt{2\cdot(m\sigma^2+m/12)}} \right).\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\sqrt{m}\) cancels out.
Furthermore, the term “\(+1/12\)” coming from {\hyperref[\detokenize{Thesis:discrete-variance}]{\sphinxcrossref{Lemma 1}}} has been considered more for a theoretical interest, since it only has a marginal influence on the probability bound.
If we choose to omit it, \(\sigma\) also cancels out, thus leaving us with the second approximation.
\end{sphinxadmonition}

\sphinxAtStartPar
Let us give a quick demonstration of the bound given in the theorem.
Taking \(N=1\) for simplicity, \(m=3\) for adding three \(R\)\sphinxhyphen{}elements, \(\sigma = 1\) to have a rounding effect and \(k=3\) for not having to do too many iterations:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{m}\PYG{p}{,} \PYG{n}{sigma}\PYG{p}{,} \PYG{n}{iterations}\PYG{p}{,} \PYG{n}{k}\PYG{p}{,} \PYG{n}{counter} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{50000}\PYG{o}{*}\PYG{n}{speed}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{0}
\PYG{c+c1}{\PYGZsh{} below: without \PYGZdq{}+1/12\PYGZdq{} the approximation sometimes exceeds the ratio}
\PYG{n}{p} \PYG{o}{=} \PYG{n}{erf}\PYG{p}{(}\PYG{p}{(}\PYG{n}{k}\PYG{o}{*}\PYG{n}{sigma}\PYG{p}{)} \PYG{o}{/} \PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{p}{(}\PYG{n}{sigma}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{12}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{iterations}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{y} \PYG{o}{=} \PYG{n+nb}{sum}\PYG{p}{(}\PYG{p}{[}\PYG{n}{generate\PYGZus{}gaussian\PYGZus{}distribution}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{sigma}\PYG{p}{)}\PYG{o}{.}\PYG{n}{evaluate}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{m}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}
    \PYG{k}{if} \PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{k} \PYG{o}{*} \PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{m}\PYG{p}{)} \PYG{o}{*} \PYG{n}{sigma}\PYG{p}{:}
        \PYG{n}{counter} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{counter}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ out of }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{iterations}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ y}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{s satisfying the bound (= ratio of }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{counter}\PYG{o}{/}\PYG{n}{iterations}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Probability approximation given in theorem = }\PYG{l+s+si}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{p}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
4990157 out of 5000000 y\PYGZsq{}s satisfying the bound (= ratio of 0.9980314)
Probability approximation given in theorem = 0.9960522481430966
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}\phantomsection\label{\detokenize{Thesis:bound-for-multiplying-two-ring-elements}}
\sphinxAtStartPar
For \(\sigma \ge 1\) and a random variable \(X\sim \mathcal N_d(0,\sigma^2)\), we have:
\begin{equation*}
\begin{split}\mathrm{Var}(X) \le \sigma^2 + \frac{1}{12}.\end{split}
\end{equation*}
\sphinxAtStartPar
Let \(x_1,\dots,x_m \in R\) be independently sampled from \(\mathcal N_d(0,\sigma^2)\) and \(y = x_1+\dots+x_m\). Then we can assume the bound \(\norm y \le k\sigma \sqrt{m}\) with an approximate probability of
\begin{equation*}
\begin{split}\mathrm{erf}\left( \frac{k\sigma}{\sqrt{2\cdot(\sigma^2+1/12)}} \right)^N \approx \mathrm{erf}(k/\sqrt{2})^N\end{split}
\end{equation*}
\sphinxAtStartPar
for \(k \in \mathbb N\) and large \(m\).

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{Bound for multiplying two \(R\)\sphinxhyphen{}elements}
\end{DUlineblock}

\sphinxAtStartPar
Similarly to adding \(R\)\sphinxhyphen{}elements \(y,z\), we now want to derive a bound on \(\norm{y \cdot z}\) depending on \(\norm y\) and \(\norm z\).
The worst\sphinxhyphen{}case can be estimated as \(\norm{y \cdot z} \le N \cdot \norm{y} \norm{z}\) and this bound is tight (e.g. for \(y = z := \sum_{i=0}^{N-1} x^i\)).
The latter expansion factor \(N\) can be shown to be only \(\approx \sqrt{N}\) with high probability if \(y\) and \(z\) satisfy certain properties.
Before deducing this as a general result, which is applicable to the usual cryptographic variables, we investigate two special cases.

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large The case “uniform” times “ternary”}
\end{DUlineblock}

\sphinxAtStartPar
The objective of this section now is to improve the worst\sphinxhyphen{}case bound \(N\) for the average case of multiplying an \(R\)\sphinxhyphen{}element \(y \sim \mathcal U(R_Q)\) times an \(R\)\sphinxhyphen{}element \(z \sim \mathrm{Ter}_\rho\).
Recall the formula for calculating the coefficients of the product \(yz\) in the ring \(R\):
\begin{equation*}
\begin{split}(yz)_i := \sum_{j=0}^i y_iz_{i-j} + \sum_{j=i+1}^{N-1} -y_i z_{i+N-j}.\end{split}
\end{equation*}\label{Thesis:uniform-times-ternary}
\begin{sphinxadmonition}{note}{Lemma 2}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}
\sphinxAtStartPar
Proof. Because of the independency, we have \(\mathbb E[YZ] = \mathbb E[Y]  \mathbb E[Z] = 0\).
The variance of \(Z\) is \(1-\rho\), and then again due to the independency \(\mathrm{Var}(YZ) = (1-\rho)\mathrm{Var}(Y)\).
Since also \(Z \sim -Z\) holds, the claim follows.
\end{sphinxadmonition}

\sphinxAtStartPar
We now can again use the Central Limit Theorem to approximate the distribution of our multiplied coefficient \((yz)_i\).
So we have:
\begin{equation}\label{equation:Thesis:central-limit-approx}
\begin{split}\P\left( \abs{(yz)_i} \le \sqrt{N \cdot \mathrm{Var}(y_iz_i)} \cdot v \right) \approx \Phi(v) - \Phi(-v) = \mathrm{erf}(v/\sqrt{2}),\end{split}
\end{equation}
\sphinxAtStartPar
where \(\Phi\) is the cumulative density function of \(\mathcal N(0,1)\).

\sphinxAtStartPar
In the literature, often the bound \(\norm{yz} \le C \sqrt{N} \norm y \le C \sqrt{N} (Q/2)\) is found for our case of \(y\) and \(z\).
Heuristic experiments for choices of \(C\) underline that usually \(C\) ranges in \([1,2]\).
Such experiments have been conducted in e.g. Section 6.1. in {[}\hyperlink{cite.Thesis:id64}{Halevi \sphinxstyleemphasis{et al.}, 2018}{]}.
We may now formulate a theorem, where we estimate the probability that the bound is satisfied for \(C\) using the above.
\label{Thesis:multiplication-bound-uniform-ternary}
\begin{sphinxadmonition}{note}{Theorem 4 (Norm bound for multiplying uniform times ternary in \protect\(R\protect\))}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}
\sphinxAtStartPar
Proof. Using the central limit theorem as in \eqref{equation:Thesis:central-limit-approx} and {\hyperref[\detokenize{Thesis:uniform-times-ternary}]{\sphinxcrossref{Lemma 2}}} we have:
\begin{equation*}
\begin{split}\P(\abs{(yz)_i} \le C\sqrt{N}\norm y) \approx \mathrm{erf} \left( \frac{C\norm y}{\sqrt{2\cdot \mathrm{Var}(y_iz_i)}}\right) = \mathrm{erf} \left( \frac{C\norm y}{\sqrt{2(1-\rho)\mathrm{Var}(y_i)}}\right).\end{split}
\end{equation*}
\sphinxAtStartPar
For the uniform distribution we have \(\mathrm{Var}(y_i) = ((Q+1)^2-1)/12\).
Now \(\sqrt{\mathrm{Var}(y_i)} \approx Q/\sqrt{12}\) is very accurate for a large \(Q\).

\sphinxAtStartPar
Finally, we estimate \(\P(\norm{yz} \le C\sqrt{N}\norm y) \approx \P(\abs{(yz)_i} \le C\sqrt N \norm y)^N\) and the claim follows.
Only an approximation is accurate in this case since \((yz)_i\) and \((yz)_j\) for \(i\neq j\) are not statistically independent anymore.
The reason is that:
\begin{equation*}
\begin{split}\P(y_iz_i =  y_i z_j) = \P(z_i = z_j) = \rho^2 + (1/2) \cdot (1-\rho)^2 \overset{\rho = 1/3}{=} 1/3.\end{split}
\end{equation*}
\sphinxAtStartPar
In total, one summand inside \((yz)_i\) and \((yz)_j\) is equal with probability \(1/3\), and \(k\) summands are equal with probability \((1/3)^k\) (for \(\rho = 1/3\)).
Nevertheless, we assume independency of the family \(((yz)_i)_{i \in \{0,\dots,N-1\}}\) anyway, since this effect becomes negligible for large \(N\) (even though we have \(N-1\) choices for \(j\) in \((yz)_j\) to compare with a fixed \((yz)_i\)).
\end{sphinxadmonition}

\sphinxAtStartPar
The above probability is largely dependent on the size of \(\norm y\) and \(C\).
Since \(y\) contains uniformly sampled coefficients, \(\norm y\) is regularly about the size of \(Q/2\).
For example:
\begin{equation*}
\begin{split}
\P\left(\norm y \ge \frac{Q}{2}-\frac{Q}{2}\frac{1}{N}\right) = 1 - \P\left(\abs {y_0} < \frac{Q}{2}-\frac{Q}{2}\frac{1}{N}\right)^N = 1 - \left(\frac{Q-Q/N}{Q}\right)^N \approx 1 - e^{-1} \ge 0.63
\end{split}
\end{equation*}
\sphinxAtStartPar
A demonstration of the value in {\hyperref[\detokenize{Thesis:multiplication-bound-uniform-ternary}]{\sphinxcrossref{Theorem 4}}} in practice (notice that for \(C=2\) the bound gets exceeded with probability around \(0.002\)):

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Q}\PYG{p}{,} \PYG{n}{N}\PYG{p}{,} \PYG{n}{C}\PYG{p}{,} \PYG{n}{counter}\PYG{p}{,} \PYG{n}{iterations} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{5000}\PYG{o}{*}\PYG{n}{speed}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{iterations}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{y} \PYG{o}{=} \PYG{n}{generate\PYGZus{}uniform\PYGZus{}distribution}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{Q}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{Q}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}
    \PYG{n}{z} \PYG{o}{=} \PYG{n}{generate\PYGZus{}ternary\PYGZus{}distribution}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} rho = 1/3}
    \PYG{k}{if} \PYG{n}{y}\PYG{o}{.}\PYG{n}{multiply}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)}\PYG{o}{.}\PYG{n}{norm}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{C}\PYG{o}{*}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{o}{*}\PYG{n}{y}\PYG{o}{.}\PYG{n}{norm}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{counter} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{counter}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ out of }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{iterations}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ satisfied bound (ratio }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{counter}\PYG{o}{/}\PYG{n}{iterations}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{norm\PYGZus{}average} \PYG{o}{=} \PYG{n+nb}{sum}\PYG{p}{(}\PYG{p}{[}\PYG{n}{generate\PYGZus{}uniform\PYGZus{}distribution}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{Q}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{Q}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{.}\PYG{n}{norm}\PYG{p}{(}\PYG{p}{)} \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{iterations}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)} \PYG{o}{/}\PYG{o}{/} \PYG{n}{iterations}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Probability in theorem }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{erf}\PYG{p}{(}\PYG{n}{norm\PYGZus{}average}\PYG{o}{*}\PYG{n}{C}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{o}{/}\PYG{n}{Q}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{n}{N}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
499181 out of 500000 satisfied bound (ratio 0.998362)
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Probability in theorem 0.9981059300560312
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Let \(Y \sim \mathcal U (-Q/2,Q/2)\) and \(Z \sim \mathrm{Ter}_\rho\) be independent integer random variables for \(\rho \in (0,1)\). Then \(YZ\) and \(-YZ\) have mean zero and variance \((1-\rho) \cdot \mathrm{Var}(Y)\).

\sphinxAtStartPar
For \(R\)\sphinxhyphen{}elements \(y \sim \mathcal U(R_Q)\) and \(z \sim \mathrm{Ter}_{\rho}\), we have \(\norm{yz} \le C\sqrt{N}\norm{y}\norm{z}\) with probability approximately:
\begin{equation*}
\begin{split}\mathrm{erf}\left(\frac{C\sqrt{6}\norm y}{\sqrt{1-\rho}\cdot Q}\right)^N \overset{\rho = 1/3}{\approx} \mathrm{erf}(3C)^N.\end{split}
\end{equation*}
\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large The case “Gaussian” times “ternary”}
\end{DUlineblock}

\sphinxAtStartPar
Essentially, we can transform our analysis from the previous section to this case.
So, let \(R\)\sphinxhyphen{}elements \(y,z\) be sampled as \(y \sim \mathcal N_d(0,\sigma^2)\), \(z \sim \mathrm{Ter}_\rho\) for \(\sigma \ge 1\).
Now, using the argument in {\hyperref[\detokenize{Thesis:uniform-times-ternary}]{\sphinxcrossref{Lemma 2}}} and the value of {\hyperref[\detokenize{Thesis:discrete-variance}]{\sphinxcrossref{Lemma 1}}}, we have for integer random variables \(Y \sim \mathcal N_d(0,\sigma^2)\) and \(Z \sim \mathrm{Ter}_\rho\):
\begin{equation*}
\begin{split}\mathrm{Var}(YZ) = (\sigma^2 + 1/12)(1-\rho).\end{split}
\end{equation*}\label{Thesis:multiplication-bound-gaussian-ternary}
\begin{sphinxadmonition}{note}{Theorem 5 (Norm bound for multiplying Gaussian times ternary in \protect\(R\protect\))}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}
\sphinxAtStartPar
Proof. The proof works as the proof of {\hyperref[\detokenize{Thesis:multiplication-bound-uniform-ternary}]{\sphinxcrossref{Theorem 4}}}.
Using the central limit theorem as in \eqref{equation:Thesis:central-limit-approx} and {\hyperref[\detokenize{Thesis:uniform-times-ternary}]{\sphinxcrossref{Lemma 2}}} once again, we have:
\begin{equation*}
\begin{split}\P(\abs{(yz)_i} \le C\sqrt{N}\norm y) \approx \mathrm{erf} \left( \frac{C\norm y }{\sqrt{2\cdot \mathrm{Var}(y_iz_i)}}\right) = \mathrm{erf} \left( \frac{C\norm y}{\sqrt{2(1-\rho)(\sigma^2+1/12)}}\right).\end{split}
\end{equation*}
\sphinxAtStartPar
Now the exact value inside \(\mathrm{erf}(\cdot)\) is largely dependent on \(\norm y\) and thus on \(N\) itself.
For a detailed analysis of \(\norm y\), it is important to consider {\hyperref[\detokenize{Thesis:sampling-bound}]{\sphinxcrossref{Theorem 2}}} for a fixed \(N\) to obtain a better probability estimation, but for simplicity, it is reasonable to assume that \(\norm y \ge 2\sigma\), which regularly already holds for quite small \(N\).
Furthermore, we have used {\hyperref[\detokenize{Thesis:discrete-variance}]{\sphinxcrossref{Lemma 1}}} for the variance estimation, whose square root is roughly \(\sigma\).
\end{sphinxadmonition}

\sphinxAtStartPar
Remark: If \(N \ge 2^{10}\), then \(\norm y \ge 3\sigma\) with high probability.
In this case, the factor inside \(\mathrm{erf}(\cdot)\) is already close to the one in {\hyperref[\detokenize{Thesis:multiplication-bound-uniform-ternary}]{\sphinxcrossref{Theorem 4}}}.

\sphinxAtStartPar
Once more we want to illustrate our result by checking computationally if the bound in the theorem is indeed satisfied.
To not get caught up in precision errors regarding \(\norm y\), we will only check on samples with a given norm, e.g. \(3\sigma\).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{N}\PYG{p}{,} \PYG{n}{sigma}\PYG{p}{,} \PYG{n}{C}\PYG{p}{,} \PYG{n}{counter}\PYG{p}{,} \PYG{n}{iterations} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{5000}\PYG{o}{*}\PYG{n}{speed}
\PYG{n}{y\PYGZus{}norm} \PYG{o}{=} \PYG{n+nb}{round}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{sigma}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{iterations}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{y} \PYG{o}{=} \PYG{n}{generate\PYGZus{}gaussian\PYGZus{}distribution}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{sigma}\PYG{p}{)}
    \PYG{k}{while} \PYG{n}{y}\PYG{o}{.}\PYG{n}{norm}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!=} \PYG{n}{y\PYGZus{}norm}\PYG{p}{:}
        \PYG{n}{y} \PYG{o}{=} \PYG{n}{generate\PYGZus{}gaussian\PYGZus{}distribution}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{sigma}\PYG{p}{)}
    \PYG{n}{z} \PYG{o}{=} \PYG{n}{generate\PYGZus{}ternary\PYGZus{}distribution}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}
    \PYG{k}{if} \PYG{n}{y}\PYG{o}{.}\PYG{n}{multiply}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)}\PYG{o}{.}\PYG{n}{norm}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{C}\PYG{o}{*}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{o}{*}\PYG{n}{y\PYGZus{}norm}\PYG{p}{:}
        \PYG{n}{counter} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{counter}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ out of }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{iterations}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ satisfied bound (ratio }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{counter}\PYG{o}{/}\PYG{n}{iterations}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{probability} \PYG{o}{=} \PYG{n}{erf}\PYG{p}{(} \PYG{p}{(}\PYG{n}{C}\PYG{o}{*}\PYG{n}{y\PYGZus{}norm}\PYG{p}{)} \PYG{o}{/} \PYG{n}{sqrt}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{o}{/}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(}\PYG{p}{(}\PYG{n}{sigma}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{12}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)} \PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{n}{N}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Probability in theorem }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{probability}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
486993 out of 500000 satisfied bound (ratio 0.973986)
Probability in theorem 0.9838201795058529
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}\phantomsection\label{\detokenize{Thesis:conclusion-on-delta-r}}
\sphinxAtStartPar
For \(R\)\sphinxhyphen{}elements \(y \sim \mathcal N_d(0,\sigma^2)\) and \(z \sim \mathrm{Ter}_{\rho}\), we have \(\norm{yz} \le C\sqrt{N}\norm{y}\) with probability approximately:
\begin{equation*}
\begin{split}\mathrm{erf} \left( \frac{C\norm y}{\sqrt{2(1-\rho)(\sigma^2+1/12)}}\right)^N \overset{\rho = 1/3}{\approx} \mathrm{erf}(\sqrt{3}C)^N.\end{split}
\end{equation*}
\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Conclusion on the expansion factor}
\end{DUlineblock}

\sphinxAtStartPar
Our results on the multiplicative norm\sphinxhyphen{}bound in the ring \(R\) with the general estimation
\begin{equation*}
\begin{split}\norm{ab} \le \delta_R \norm a \norm b\end{split}
\end{equation*}
\sphinxAtStartPar
let us conjecture that \(\delta_R\) is approximately \(\sqrt{N}\) (and not \(N\)) in special cases.
The two above theorems regarding \(\delta_R \approx \sqrt{N}\) mainly hold, because \(a\) and \(b\)’s coefficients were i.i.d. samples with mean zero (as e.g. in {\hyperref[\detokenize{Thesis:uniform-times-ternary}]{\sphinxcrossref{Lemma 2}}}), which is decisive for the application of the central limit theorem.
We will commonly use the distributions \(\mathrm{Ter}_{1/3}, \mathcal U(R_Q)\) and \(\mathcal N_d(0,\sigma^2)\) (all with mean zero) for generating elements within our cryptographic constructions.
Almost all variables used later, except for predetermined messages, will thus satisfy the \(\delta_R := \sqrt{N}\) constraint.
Therefore we treat the rare case as \(\delta_R' := N\) and use \(\delta_R\) respectively \(\delta_R'\) for our error analysis.

\phantomsection\label{\detokenize{Thesis:security}}
\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Security}
\end{DUlineblock}

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large The Decision\sphinxhyphen{}RLWE problem}
\end{DUlineblock}

\sphinxAtStartPar
In this section, we provide the details regarding the security of encryption schemes, whose ciphertexts are based on \(R\) and its “Learning with errors” problem (\(R\)\sphinxhyphen{}LWE).
An extensive overview of the whole topic is given in {[}\hyperlink{cite.Thesis:id65}{Peikert, 2015}{]}, especially Section 4.4, to which we refer as a source for the following definitions.

\sphinxAtStartPar
As a first step, we define the RLWE distribution according to Definition 4.4.1. in {[}\hyperlink{cite.Thesis:id65}{Peikert, 2015}{]}, which already contains the necessary structure for later defining RLWE ciphertexts.
\label{Thesis:RLWE-distribution}
\begin{sphinxadmonition}{note}{Definition 2 (RLWE distribution)}
\end{sphinxadmonition}

\sphinxAtStartPar
Following up, we assign a problem to the RLWE distribution, which a cryptographic adversary technically has to solve for “learning” information about the distribution (i.e. \(s\)) despite dealing “with errors” \(e\).
\label{Thesis:decision-RLWE}
\begin{sphinxadmonition}{note}{Definition 3 (Decision\sphinxhyphen{}RLWE problem)}
\end{sphinxadmonition}

\sphinxAtStartPar
Naturally, here we are only allowed to work with a quite small number (typically polynomial in the ring degree \(N\)) of samples, to prevent the problem from becoming too easy.

\sphinxAtStartPar
Generally speaking, the security reductions, which reduce the Decision\sphinxhyphen{}RLWE problem to a well\sphinxhyphen{}known problem over lattices, are cumbersome to formulate precisely and difficult to prove.
Thus, these kinds of security discussions are extensive topics on their own, and the variety among the security principles would be too ambitious to break down.
Therefore, later in {\hyperref[\detokenize{Thesis:remarks-on-security}]{\sphinxcrossref{\DUrole{std,std-ref}{Remarks on the security framework for FHE}}}}, we will only collect some selected remarks about RLWE\sphinxhyphen{}distributed ciphertext security, which are particularly important for constructing an efficient fully homomorphic encryption scheme.
But first, let us formulate the security reduction, which requires a quick {\hyperref[\detokenize{Thesis:background-on-lattices}]{\sphinxcrossref{\DUrole{std,std-ref}{Background on lattices}}}}.
\label{Thesis:RLWE-security}
\begin{sphinxadmonition}{note}{Property 2 (Security reduction from Decision\sphinxhyphen{}RLWE to \protect\(\mathrm{SVP}_\gamma\protect\))}
\end{sphinxadmonition}
\phantomsection\label{\detokenize{Thesis:background-on-lattices}}
\sphinxAtStartPar
For a fixed (secret key) \(s \in R_Q\) and a preselected error distribution \(\chi\), we say that \((a,b) \in R_Q^2\) is sampled from the RLWE distribution \(A_{s,\chi}\), if:
\begin{equation*}
\begin{split}(a,b) := (a, -a\cdot s + e), \qquad a \sim \mathcal U(R_Q), e \sim \chi.\end{split}
\end{equation*}
\sphinxAtStartPar
Determine (with an non\sphinxhyphen{}negligible advantage) for \(n\) given i.i.d. samples \((a_i,b_i) \in R_Q^2\), whether they are either sampled from \(A_{s,\chi}\) (with \(s \sim \mathcal U(R_Q)\)) or from \(U(R_Q)^2\).

\sphinxAtStartPar
As mentioned in Theorem 4.4.3. of {[}\hyperlink{cite.Thesis:id65}{Peikert, 2015}{]}, the Decision\sphinxhyphen{}RLWE problem with proper parameters is at least as hard as quantumly solving the \(\gamma\)\sphinxhyphen{}Approximate Shortest Vector Problem (\(\mathrm{SVP}_\gamma\)) over ideal lattices.

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Background on lattices}
\end{DUlineblock}

\sphinxAtStartPar
Given a “lattice basis” \(B = \{\vec{b_1},\dots,\vec{b_n}\}\) of linearly independent vectors \(\vec{b_i} \in \R^n\), define the corresponding (full\sphinxhyphen{}rank) lattice as:
\begin{equation*}
\begin{split}\mathcal L := \mathcal L(B) := \left\{\sum_{i=1}^n z_i\vec{b_i} \mid z_i \in \Z \right\}.\end{split}
\end{equation*}
\sphinxAtStartPar
Let moreover \(\lambda_1 := \min_{0 \neq \vec v \in \mathcal L} \lvert\lvert \vec v \rvert\rvert\) denote the length of the shortest non\sphinxhyphen{}zero vector in \(\mathcal L\) with respect to a norm (usually the euclidean norm in \(\R^n\)).

\sphinxAtStartPar
Ideal lattices now have the additional property of corresponding to ideals \(I\) of the ring \(R\).
In this connection, it is very important, which embedding from generators (polynomials) of \(I\) to generators (integer vectors) of \(\mathcal L \subset \Z^N\) is chosen.
For example, one can choose the straightforward coefficient embedding and set
\begin{equation*}
\begin{split}\mathcal L(I) = \left\langle(g_0,\dots,g_{N-1}) \mid g = \sum_{i=0}^{N-1} g_i x^i \in I \right\rangle \subset \Z^N.\end{split}
\end{equation*}
\sphinxAtStartPar
It is clear from the description that \(\mathcal L(I) \subset \Z^N\) is isomorphic to \(I \subset R\) as an additive group.
This fact illustrates the close relationship between the ring \(R\) and ideal lattices and puts the above security reduction from RLWE to lattice problems into context.
Nevertheless, there is a lot more to state about more sophisticated embeddings (see Section 4.3.3. of {[}\hyperlink{cite.Thesis:id65}{Peikert, 2015}{]}), which feature favorable qualities and play a crucial role in the proof of the security reduction of RLWE.

\sphinxAtStartPar
The following definition directly refers to Definition 2.2.2 in {[}\hyperlink{cite.Thesis:id65}{Peikert, 2015}{]}.
\label{Thesis:approximate-shortest-vector-problem}
\begin{sphinxadmonition}{note}{Definition 4 (Approximate Shortest Vector Problem \protect\(\mathrm{SVP}_\gamma\protect\))}
\end{sphinxadmonition}

\sphinxAtStartPar
Notice that, if \(\gamma = 1\), we obtain the special case of the (absolute) Shortest Vector Problem (SVP).

\begin{sphinxadmonition}{note}{Conjectured (quantum) NP\sphinxhyphen{}hardness of \protect\(\mathrm{SVP}_\gamma\protect\)}

\sphinxAtStartPar
In {\hyperref[\detokenize{Thesis:RLWE-security}]{\sphinxcrossref{Property 2}}}, \(\gamma(n)\) is a polynomial function in \(n\).
As pointed out in Section 4.3.4 of {[}\hyperlink{cite.Thesis:id65}{Peikert, 2015}{]}, such a \(\gamma\) still results in an exponential (in \(n\)) running time for the best known (quantum) algorithms to solve \(\mathrm{SVP}_\gamma\) on ideal lattices.
\end{sphinxadmonition}
\phantomsection\label{\detokenize{Thesis:remarks-on-security}}
\sphinxAtStartPar
Given a (full\sphinxhyphen{}rank) lattice basis \(B\) of an \(n\)\sphinxhyphen{}dimensional lattice \(\mathcal L(B)\), find a \(0 \neq \vec v \in \mathcal L\) with \(\norm {\vec v} \le \gamma(n) \cdot \lambda_1\).

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Remarks on the security framework for FHE}
\end{DUlineblock}

\sphinxAtStartPar
The following remarks tackle the requirements of {\hyperref[\detokenize{Thesis:decision-RLWE}]{\sphinxcrossref{Definition 3}}}, which need to be partly altered to serve as an efficient framework for FHE:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
The error distribution (in our case this will be \(\mathcal N_d(0,\sigma^2)\)) must be chosen carefully.
Informally speaking, a larger standard deviation \(\sigma\) corresponds to a smaller \(\gamma\), which then makes \(\mathrm{SVP}_\gamma\) harder.
In contrast to that, we are also interested in keeping the error size (thus \(\sigma\)) very small, to perform more homomorphic operations in a row without needing to perform a costly bootstrapping operation in between.

\item {} 
\sphinxAtStartPar
It is important to note, that in {[}\hyperlink{cite.Thesis:id66}{Langlois and Stehlé, 2012}{]} it has been proven that the security of Decision\sphinxhyphen{}RLWE does not rely on a specific number theoretical properties of the modulus \(Q\) and hence we can conveniently set \(Q\) to a large power of two.

\item {} 
\sphinxAtStartPar
Additionally, it is obstructive for our bootstrapping method to use a secret key \(s\) sampled from \(\mathcal U(R_Q)\).
It can be shown that we even may assume \(s \sim \chi\) without changing the above theorem (see Section 4.4.1 in {[}\hyperlink{cite.Thesis:id65}{Peikert, 2015}{]}).
Still, for practical purposes, where we need to realize a distinction of cases (the cases being the values a \(s\)\sphinxhyphen{}coefficient can take), the ternary distribution comes into play.
This choice is a compromise since there is a lack of security proofs for a ternary secret key \(s \sim \mathrm{Ter}_\rho\) and moreover sparse ternary keys (with \(\rho\) close to \(0\)) are subject of security concerns.
More information can be found in Chapter 1 of {[}\hyperlink{cite.Thesis:id67}{Lee \sphinxstyleemphasis{et al.}, 2022}{]}.
To mention one last argument in favor of using them, ternary secret keys are part of the Homomorphic Encryption Standardization document {[}\hyperlink{cite.Thesis:id68}{Albrecht \sphinxstyleemphasis{et al.}, 2018}{]}.

\end{enumerate}
\phantomsection\label{\detokenize{Thesis:the-bfv-scheme}}
\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large The BFV scheme}
\end{DUlineblock}

\sphinxAtStartPar
Before working on a bootstrapping algorithm for achieving fully homomorphic encryption, we need to set the framework of our scheme.
This will be done by considering a “somewhat homomorphic” encryption scheme, which enables us to encrypt, decrypt, and already perform a limited amount of additions and multiplications on a ciphertext.
Notice that for a ciphertext structure as in {\hyperref[\detokenize{Thesis:RLWE-distribution}]{\sphinxcrossref{Definition 2}}} we outlined a proof of security earlier.
Taking that as a foundation, all is left to specify where and how to hide a message within a ciphertext, which will be the salient feature of BFV ciphertexts.
The BFV (abbreviation of the names of the authors) scheme was initially published in {[}\hyperlink{cite.Thesis:id70}{Fan and Vercauteren, 2012}{]}, which will be our main reference throughout this chapter.

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Asymmetric key generation}
\end{DUlineblock}

\sphinxAtStartPar
To start defining our scheme, we could solely contemplate ciphertexts, which only make use of a secret key for encrypting messages.
However, extending the idea to an asymmetric encrypting scheme by introducing a public key can be achieved in a straightforward way.
That is due to the fact that a public key, which is in fact generated from the secret key, simply has a structure identical to any other ciphertext, i.e. a structure as in {\hyperref[\detokenize{Thesis:RLWE-distribution}]{\sphinxcrossref{Definition 2}}}.
It follows that the security reductions for any ciphertext ({\hyperref[\detokenize{Thesis:RLWE-security}]{\sphinxcrossref{Property 2}}}) also apply to the public key, whose exposure to any party is therefore unproblematic and of great avail.

\sphinxAtStartPar
BFV’s \(\texttt{keygen}\) algorithm takes as an input a ring degree \(N\), a ciphertext modulus \(Q\), and a standard deviation \(\sigma \ge 0\).
It outputs a public key \(\mathrm{pk} \in R_Q^2\) and a secret key \(\mathrm{sk} \in R_Q\). It sets:
\begin{equation*}
\begin{split}\mathrm{sk} := s \sim \mathrm{Ter}_{1/3}, \qquad
\mathrm{pk} := (\mathrm{pk}_0, \mathrm{pk}_1) := (\mathrm{pk}_0,-\mathrm{pk}_0\cdot s-e)\end{split}
\end{equation*}
\sphinxAtStartPar
with \(\mathrm{pk}_0 \sim \mathcal U(R_Q)\) and an error \(e \sim \mathcal N_d(0,\sigma^2)\).

\sphinxAtStartPar
Notice that we can control our error distribution with the parameter standard deviation \(\sigma \ge 0\).
As pointed out in {\hyperref[\detokenize{Thesis:remarks-on-security}]{\sphinxcrossref{\DUrole{std,std-ref}{Remarks on the security framework for FHE}}}}, it is very important to choose the parameters carefully for preserving security hardness results.
Nevertheless, as we will later see, \(\sigma\) does affect the number of possible homomorphic operations greatly (see {\hyperref[\detokenize{Thesis:parameter-impact}]{\sphinxcrossref{\DUrole{std,std-ref}{Parameter impact}}}}).
Hence, we conveniently set \(\sigma = 1\) while testing our implementations.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{keygen}\PYG{p}{(}\PYG{n}{key\PYGZus{}size}\PYG{p}{,} \PYG{n}{ciphertext\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{standard\PYGZus{}deviation}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{N}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{STD} \PYG{o}{=} \PYG{n}{key\PYGZus{}size}\PYG{p}{,} \PYG{n}{ciphertext\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{standard\PYGZus{}deviation}
    \PYG{n}{sk} \PYG{o}{=} \PYG{n}{generate\PYGZus{}ternary\PYGZus{}distribution}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}
    \PYG{n}{pk\PYGZus{}0} \PYG{o}{=} \PYG{n}{generate\PYGZus{}uniform\PYGZus{}distribution}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Q}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{n}{e} \PYG{o}{=} \PYG{n}{generate\PYGZus{}gaussian\PYGZus{}distribution}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{STD}\PYG{p}{)}
    \PYG{n}{pk\PYGZus{}1} \PYG{o}{=} \PYG{n}{pk\PYGZus{}0}\PYG{o}{.}\PYG{n}{multiply}\PYG{p}{(}\PYG{n}{sk}\PYG{p}{)}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{e}\PYG{p}{)}\PYG{o}{.}\PYG{n}{scalar\PYGZus{}multiply}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{)}
    \PYG{k}{return} \PYG{p}{[}\PYG{n}{sk}\PYG{p}{,} \PYG{p}{[}\PYG{n}{pk\PYGZus{}0}\PYG{p}{,} \PYG{n}{pk\PYGZus{}1}\PYG{p}{]}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Encryption}
\end{DUlineblock}

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Notion of BFV ciphertexts}
\end{DUlineblock}

\sphinxAtStartPar
For encryption, we take a message that has been previously encoded into the polynomial \(M \in R_T\), where \(T\) is the plaintext modulus.
Encryption now essentially uses the public key to transform \(M\) into a ciphertext \(\mathrm{ct} \in R_Q^2\) defined as:
\begin{equation*}
\begin{split}\begin{split}
\mathrm{ct} := (\mathrm{ct}_0, \mathrm{ct}_1) := (z\cdot \mathrm{pk}_0+e_0,z\cdot \mathrm{pk}_1 + e_1 + \lfloor Q/T \rceil M) \in R_Q^2
\end{split}\end{split}
\end{equation*}
\sphinxAtStartPar
where \(e_0, e_1, z \sim \mathcal N_d(0, \sigma^2)\).
To highlight the technique of encryption, we will commonly denote \(\mathrm{ct}\) as \(\mathrm{BFV}_{Q,s}(M)\).

\sphinxAtStartPar
Notice that the BFV ciphertext as well fits the structure of a RLWE ciphertext as in {\hyperref[\detokenize{Thesis:RLWE-distribution}]{\sphinxcrossref{Definition 2}}}.
That is because \(\mathrm{ct}_0\) still looks uniformly at random, since multiplying with \(z\) and adding \(e_0\) does not change this in a meaningful way.
Furthermore, the second component containing the hidden secret key as \(- \mathrm{pk}_0 \cdot \mathrm{sk}\) and the error term \(-z \cdot e + e_1 - e_0\cdot \mathrm{sk}\) (which is slightly altered compared to an error generated from \(\mathcal N_d(0,\sigma^2)\)) can be shown to greatly resemble the structure of a RLWE ciphertext.
More details on the security of \(\mathrm{ct}\) are given in Section 8.2 of {[}\hyperlink{cite.Thesis:id71}{Lyubashevsky \sphinxstyleemphasis{et al.}, 2013}{]}.

\sphinxAtStartPar
The scaling of the message \(M\) by the large factor \(\round{Q/T}\) is also crucial since we need to distinguish it from the error during decrypting.

\sphinxAtStartPar
Remarks:
\begin{itemize}
\item {} 
\sphinxAtStartPar
For constructing something cryptographically secure, we want to blow up a (rather small) plaintext space \(R_T\) to a large ciphertext space \(R_Q\), hence we ought to choose \(Q\) much larger than \(T\).
This is also indispensable for realizing even the simplest operations on ciphertexts, not to mention decrypting (see {\hyperref[\detokenize{Thesis:correct-BFV-decryption}]{\sphinxcrossref{Lemma 4}}}).

\item {} 
\sphinxAtStartPar
For our purposes, we will only use powers of two for \(T\) and \(Q\), such that the rounding of \(Q/T\) is technically obsolete, but nevertheless it should be mentioned as the scheme can be varied to arbitrary \(T, Q\) and the above is the usual BFV encryption formula.

\end{itemize}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{encrypt}\PYG{p}{(}\PYG{n}{message}\PYG{p}{,} \PYG{n}{plaintext\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{ciphertext\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{standard\PYGZus{}deviation}\PYG{p}{,} \PYG{n}{public\PYGZus{}key}\PYG{p}{)}\PYG{p}{:} 
    \PYG{n}{M}\PYG{p}{,} \PYG{n}{T}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{STD}\PYG{p}{,} \PYG{n}{pk} \PYG{o}{=} \PYG{n}{message}\PYG{p}{,} \PYG{n}{plaintext\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{ciphertext\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{standard\PYGZus{}deviation}\PYG{p}{,} \PYG{n}{public\PYGZus{}key}
    \PYG{n}{N} \PYG{o}{=} \PYG{n+nb}{getattr}\PYG{p}{(}\PYG{n}{message}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ring\PYGZus{}degree}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{z} \PYG{o}{=} \PYG{n}{generate\PYGZus{}gaussian\PYGZus{}distribution}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{STD}\PYG{p}{)} 
    \PYG{n}{e\PYGZus{}0} \PYG{o}{=} \PYG{n}{generate\PYGZus{}gaussian\PYGZus{}distribution}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{STD}\PYG{p}{)}
    \PYG{n}{e\PYGZus{}1} \PYG{o}{=} \PYG{n}{generate\PYGZus{}gaussian\PYGZus{}distribution}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{STD}\PYG{p}{)}  
    \PYG{n}{ct\PYGZus{}0} \PYG{o}{=} \PYG{n}{z}\PYG{o}{.}\PYG{n}{multiply}\PYG{p}{(}\PYG{n}{pk}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{e\PYGZus{}0}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{)}
    \PYG{n}{ct\PYGZus{}1} \PYG{o}{=} \PYG{n}{z}\PYG{o}{.}\PYG{n}{multiply}\PYG{p}{(}\PYG{n}{pk}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{M}\PYG{o}{.}\PYG{n}{scalar\PYGZus{}multiply}\PYG{p}{(}\PYG{n}{Q} \PYG{o}{/}\PYG{o}{/} \PYG{n}{T}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{e\PYGZus{}1}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{)}
    \PYG{k}{return} \PYG{p}{[}\PYG{n}{ct\PYGZus{}0}\PYG{p}{,} \PYG{n}{ct\PYGZus{}1}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
A short demonstration of encrypting:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{N} \PYG{o}{=} \PYG{n}{print\PYGZus{}and\PYGZus{}return}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Polynomial ring degree N}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{T} \PYG{o}{=} \PYG{n}{print\PYGZus{}and\PYGZus{}return}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Plaintext modulus T}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{Q} \PYG{o}{=} \PYG{n}{print\PYGZus{}and\PYGZus{}return}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Ciphertext modulus Q}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{20}\PYG{p}{)}
\PYG{n}{STD} \PYG{o}{=} \PYG{n}{print\PYGZus{}and\PYGZus{}return}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Standard deviation STD}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{M} \PYG{o}{=} \PYG{n}{print\PYGZus{}and\PYGZus{}return}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{Message: M}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{generate\PYGZus{}uniform\PYGZus{}distribution}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{T}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{SK}\PYG{p}{,} \PYG{n}{PK} \PYG{o}{=} \PYG{n}{keygen}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{STD}\PYG{p}{)}
\PYG{n}{encryption} \PYG{o}{=} \PYG{n}{encrypt}\PYG{p}{(}\PYG{n}{M}\PYG{p}{,} \PYG{n}{T}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{STD}\PYG{p}{,} \PYG{n}{PK}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Encryption components are}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{encryption}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{and}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{encryption}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Polynomial ring degree N = 4
Plaintext modulus T = 4
Ciphertext modulus Q = 1048576
Standard deviation STD = 1

Message: M = 3x\PYGZca{}3 + x
Encryption components are 239111x\PYGZca{}3 + 225686x\PYGZca{}2 + 678463x + 210869 
and 93151x\PYGZca{}3 + 968709x\PYGZca{}2 + 64703x + 834909
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Error after BFV encryption}
\end{DUlineblock}
\label{Thesis:error-after-BFV-encryption}
\begin{sphinxadmonition}{note}{Lemma 3 (Error after BFV\sphinxhyphen{}Encryption)}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}
\sphinxAtStartPar
Proof. The error after BFV encryption is precisely \(-z \cdot e + e_1 + e_0 \cdot s\) with \(z,e,e_0,e_1 \sim \mathcal N_d(0,1)\) and \(\mathrm{sk} \sim \mathrm{Ter}_{1/3}\).
Now, many details for determining the norm of multiplied ring elements generated from certain distributions can be examined.
But as the theoretical and computational conclusions in {\hyperref[\detokenize{Thesis:conclusion-on-delta-r}]{\sphinxcrossref{\DUrole{std,std-ref}{Conclusion on the expansion factor}}}} suggest, we may use the reasonable estimation:
\begin{equation*}
\begin{split}\norm{x_1x_2} \le \sqrt{N}\norm{x_1}\norm{x_2}\end{split}
\end{equation*}
\sphinxAtStartPar
for \(x_1,x_2 \sim \mathcal N_d(0,1)\).

\sphinxAtStartPar
Coming back to the analysis, for a \(\mathcal N_d(0,1)\) element \(x\), we have \(\norm x \le 7\) with overwhelming probability (see {\hyperref[\detokenize{Thesis:sampling-bound}]{\sphinxcrossref{Theorem 2}}}).
In total, we may estimate the error after BFV encryption as:
\begin{equation*}
\begin{split}\le 2 \cdot \sqrt{N} \cdot 7^2 + 7 \approx C \sqrt{N}.\end{split}
\end{equation*}\end{sphinxadmonition}

\sphinxAtStartPar
In practice, \(C\) is indeed much smaller as the following computation points out.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{N}\PYG{p}{,} \PYG{n}{iterations}\PYG{p}{,} \PYG{n}{max\PYGZus{}norm} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5000}\PYG{o}{*}\PYG{n}{speed}\PYG{p}{,} \PYG{l+m+mi}{0}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{iterations}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{a} \PYG{o}{=} \PYG{p}{[}\PYG{n}{generate\PYGZus{}gaussian\PYGZus{}distribution}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{]}
    \PYG{n}{s} \PYG{o}{=} \PYG{n}{generate\PYGZus{}ternary\PYGZus{}distribution}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}
    \PYG{n}{max\PYGZus{}norm} \PYG{o}{=} \PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{multiply}\PYG{p}{(}\PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{.}\PYG{n}{multiply}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{mod\PYGZus{}small}\PYG{p}{(}\PYG{n}{Q}\PYG{p}{)}\PYG{o}{.}\PYG{n}{norm}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{max\PYGZus{}norm}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Maximum C after }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{iterations}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ iterations was }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{max\PYGZus{}norm}\PYG{o}{/}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Maximum C after 500000 iterations was 8.5
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
The error size within a BFV\sphinxhyphen{}ciphertext after BFV\sphinxhyphen{}encryption using \(\sigma = 1\) can be estimated as \(C\sqrt{N}\). It holds that \(C \approx 100\) with high probability.

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Decryption}
\end{DUlineblock}

\sphinxAtStartPar
The decryption algorithm takes a BFV ciphertext \(\mathrm{BFV}_{Q,\mathrm{sk}}(M) = \mathrm{ct} \in R_Q\) and the secret key \(\mathrm{sk}\) as an input and it outputs the hidden message polynomial \(M \in R_T\).
To begin with, it eliminates the random component inside a ciphertext by computing:
\begin{equation*}
\begin{split}T\cdot (\mathrm{ct}_0 \cdot \mathrm{sk} + \mathrm{ct}_1).\end{split}
\end{equation*}
\sphinxAtStartPar
It is crucial to perform this computation entirely in \(R\), that means without modular reductions:
If we instead use the ring \(R_Q\), we would wind up with the term \(T \lfloor Q/T \rceil M \in R_Q\) within \(\mathrm{ct}_1\), which would then degenerate any message.

\sphinxAtStartPar
To proceed, we integer\sphinxhyphen{}divide the coefficients of \(T \cdot (\mathrm{ct}_0 \cdot \mathrm{sk} + \mathrm{ct}_1)\) by \(Q\) (done by rounding the coefficients of the result).
At last, we reduce the result by \(T\) to regain \(M \in R_T\).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{decrypt}\PYG{p}{(}\PYG{n}{ciphertext}\PYG{p}{,} \PYG{n}{plaintext\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{ciphertext\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{secret\PYGZus{}key}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{ct}\PYG{p}{,} \PYG{n}{q}\PYG{p}{,} \PYG{n}{t}\PYG{p}{,} \PYG{n}{sk} \PYG{o}{=} \PYG{n}{ciphertext}\PYG{p}{,} \PYG{n}{ciphertext\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{plaintext\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{secret\PYGZus{}key}
    \PYG{k}{return} \PYG{n}{ct}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{multiply}\PYG{p}{(}\PYG{n}{sk}\PYG{p}{,} \PYG{n}{q}\PYG{p}{)}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{ct}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q}\PYG{p}{)}\PYG{o}{.}\PYG{n}{scalar\PYGZus{}multiply}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{o}{.}\PYG{n}{rounded\PYGZus{}integer\PYGZus{}divide}\PYG{p}{(}\PYG{n}{q}\PYG{p}{)}\PYG{o}{.}\PYG{n}{mod}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
We will give a demonstration of the decryption algorithm, which is a continuation of the above encryption example.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{N} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}
\PYG{n}{decryption} \PYG{o}{=} \PYG{n}{print\PYGZus{}and\PYGZus{}return}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Decryption of Message}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{decrypt}\PYG{p}{(}\PYG{n}{encryption}\PYG{p}{,} \PYG{n}{T}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{SK}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Message }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{M}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ decrypted correctly? }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{M}\PYG{o}{.}\PYG{n}{is\PYGZus{}equal\PYGZus{}to}\PYG{p}{(}\PYG{n}{decryption}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{decryption\PYGZus{}error} \PYG{o}{=} \PYG{n}{encryption}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{multiply}\PYG{p}{(}\PYG{n}{SK}\PYG{p}{)}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{encryption}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{)}\PYG{o}{.}\PYG{n}{subtract}\PYG{p}{(}\PYG{n}{M}\PYG{o}{.}\PYG{n}{scalar\PYGZus{}multiply}\PYG{p}{(}\PYG{n}{Q}\PYG{o}{/}\PYG{o}{/}\PYG{n}{T}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Error size inside ciphertext: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{decryption\PYGZus{}error}\PYG{o}{.}\PYG{n}{mod\PYGZus{}small}\PYG{p}{(}\PYG{n}{Q}\PYG{p}{)}\PYG{o}{.}\PYG{n}{norm}\PYG{p}{(}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Decryption of Message = 3x\PYGZca{}3 + x
Message 3x\PYGZca{}3 + x decrypted correctly? True
Error size inside ciphertext: 3
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large A criterion for correct decryption}
\end{DUlineblock}

\sphinxAtStartPar
It is of uttermost importance for a FHE scheme to be serviceable to formulate a criterion, which answers the question, of under which circumstances we still can decrypt correctly.
Moreover, this criterion will be our main limitation in terms of how frequently we need to interpose a (costly) bootstrapping procedure later (to reduce the error size).

\sphinxAtStartPar
Recall that a BFV\sphinxhyphen{}encrypted ciphertext unfolded looks like the following:
\begin{equation*}
\begin{split}\mathrm{ct} = (z\cdot \mathrm{pk}_0 +e_0, -z \cdot \mathrm{pk}_0 \cdot \mathrm{sk} - z\cdot e +e_1 + \lfloor Q/T \rfloor M).\end{split}
\end{equation*}
\sphinxAtStartPar
If we compute \(T \cdot (\mathrm{ct}_0 \cdot \mathrm{sk} + \mathrm{ct}_1)\), we will be left with:
\begin{equation*}
\begin{split}T (e_0\cdot \mathrm{sk}+e_1-z\cdot e) + T\cdot \lfloor Q/T \rceil M\end{split}
\end{equation*}
\sphinxAtStartPar
This already properly illustrates, what we have to keep track of, if we still correctly want to decrypt any ciphertext that may have been manipulated.
The first term within brackets is called the decryption error.
Recall that at this point we still have to integer\sphinxhyphen{}divide by \(Q\).
In order to obtain a correct decryption, we want the first summand to vanish, such that we are left with \(M\) only.
To make sure that this is indeed the case, we, on the one hand, have to set \(Q\) suitably larger than \(T\), to gain a scaling factor \(T/Q\) as small as possible.
On the other hand, if the intrinsic error is of encryption kind, the polynomials \(e_0, e_1, e, z, \mathrm{sk}\) are required to have a small infinity norm, too, such that their composition does not exceed a certain size (see {\hyperref[\detokenize{Thesis:error-after-BFV-encryption}]{\sphinxcrossref{Lemma 3}}}).
Nevertheless, if the decryption error is composed differently because of previous ciphertext manipulations, we have no scope left to control the decryption query this way.

\sphinxAtStartPar
We summarize these observations by the following lemma, which even holds for an arbitrary error (accumulated during homomorphic operations), generalizing the above beyond encryption errors.
\label{Thesis:correct-BFV-decryption}
\begin{sphinxadmonition}{note}{Lemma 4 (Correct BFV decryption)}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}
\sphinxAtStartPar
Proof. We follow the proof of Lemma 1 in {[}\hyperlink{cite.Thesis:id70}{Fan and Vercauteren, 2012}{]}.
The decryption algorithm works correctly if and only if the rounding as its final step does.
We enter the rounding step with \(M + (T/Q)e\), which is treated as a polynomial with rational coefficients.
For \((T/Q)e\) to vanish during rounding, it is required that \(\norm{(T/Q)e} < 1/2\), which directly translates into the claim.
\end{sphinxadmonition}

\sphinxAtStartPar
In the rest of the notebook, we want to implement homomorphic operations (addition and multiplication) on the BFV scheme and furthermore derive a bootstrapping algorithm to replace a big error with a small and fresh one.
For this process it is not particularly necessary to deal with the lengthy public\sphinxhyphen{}key ciphertexts, thus we introduce a simpler notion of a BFV ciphertext by:
\begin{equation*}
\begin{split}\mathrm{BFV}_{Q,\mathrm{sk}}(M) := (a, -a\cdot\mathrm{sk}+e+\lfloor Q/T\rceil M),\end{split}
\end{equation*}
\sphinxAtStartPar
where neither \(a \in R_Q\) is further specified nor the (initial) error \(e \in R_Q\).

\sphinxAtStartPar
A \(\mathrm{BFV}_{Q,\mathrm{sk}}(M)\) ciphertext with an intrinsic error \(e\) decrypts correctly, if \(\norm e < Q/(2T)\).

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Adding ciphertexts}
\end{DUlineblock}

\sphinxAtStartPar
Adding, in contrast to multiplying ciphertexts, is easier, computationally cheaper, and induces a smaller error by far.
It plainly can be done by adding the ciphertext components together (subtraction is done analogously).
Starting with two BFV ciphertexts:
\begin{equation*}
\begin{split}\mathrm{ct}_0 := (a_0,b_0) := (a_0, -a_0\cdot \mathrm{sk} + e_0 + \lfloor Q/T\rceil M_0),\\
\mathrm{ct}_1 := (a_1,b_1) := (a_1, -a_1\cdot \mathrm{sk} + e_1 + \lfloor Q/T\rceil M_1),\end{split}
\end{equation*}
\sphinxAtStartPar
we define the sum of them as \(\mathrm{sum} := (a_0+a_1,b_0+b_1)\).
The linearity of adding and the structure of BFV ciphertexts make sure that \(\mathrm{sum}\) gets decrypted correctly to \(M_0+M_1\) as follows:
\begin{equation*}
\begin{split}\mathrm{sum}_0 \cdot \mathrm{sk} + \mathrm{sum}_1 = \frac{Q}{T}(M_0+M_1) + (e_0 + e_1) \in R_Q.\end{split}
\end{equation*}
\sphinxAtStartPar
Note that the above equation actually only holds for powers of two \(T < Q\), since we would otherwise have to deal with another summand building upon the (nonzero) remainder of \(Q\) divided by \(T\) (see chapter 4 in {[}\hyperlink{cite.Thesis:id70}{Fan and Vercauteren, 2012}{]}).

\sphinxAtStartPar
We may now still decrypt correctly, given the new error \(e_{\mathrm{sum}} = e_0+e_1\) still satisfies the bound given in {\hyperref[\detokenize{Thesis:correct-BFV-decryption}]{\sphinxcrossref{Lemma 4}}}.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{add}\PYG{p}{(}\PYG{n}{ciphertext1}\PYG{p}{,} \PYG{n}{ciphertext2}\PYG{p}{,} \PYG{n}{ciphertext\PYGZus{}modulus}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{ct1}\PYG{p}{,} \PYG{n}{ct2}\PYG{p}{,} \PYG{n}{Q} \PYG{o}{=} \PYG{n}{ciphertext1}\PYG{p}{,} \PYG{n}{ciphertext2}\PYG{p}{,} \PYG{n}{ciphertext\PYGZus{}modulus}
    \PYG{k}{return} \PYG{p}{[}\PYG{n}{ct1}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{ct2}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{)}\PYG{p}{,} \PYG{n}{ct1}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{ct2}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{)}\PYG{p}{]}

\PYG{k}{def} \PYG{n+nf}{subtract}\PYG{p}{(}\PYG{n}{ciphertext1}\PYG{p}{,} \PYG{n}{ciphertext2}\PYG{p}{,} \PYG{n}{ciphertext\PYGZus{}modulus}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{ct1}\PYG{p}{,} \PYG{n}{ct2}\PYG{p}{,} \PYG{n}{Q} \PYG{o}{=} \PYG{n}{ciphertext1}\PYG{p}{,} \PYG{n}{ciphertext2}\PYG{p}{,} \PYG{n}{ciphertext\PYGZus{}modulus}
    \PYG{k}{return} \PYG{p}{[}\PYG{n}{ct1}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{subtract}\PYG{p}{(}\PYG{n}{ct2}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{)}\PYG{p}{,} \PYG{n}{ct1}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{subtract}\PYG{p}{(}\PYG{n}{ct2}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{)}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
As a demonstration, we test adding by computing \(1+1=2 \in R_T\) in ciphertext space:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{One\PYGZus{}Encryption} \PYG{o}{=} \PYG{n}{encrypt}\PYG{p}{(}\PYG{n}{generate\PYGZus{}constant\PYGZus{}poly}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{T}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{STD}\PYG{p}{,} \PYG{n}{PK}\PYG{p}{)}
\PYG{n}{Two\PYGZus{}Encryption} \PYG{o}{=} \PYG{n}{add}\PYG{p}{(}\PYG{n}{One\PYGZus{}Encryption}\PYG{p}{,} \PYG{n}{One\PYGZus{}Encryption}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{)}
\PYG{n}{Two\PYGZus{}Decryption} \PYG{o}{=} \PYG{n}{print\PYGZus{}and\PYGZus{}return}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Decryption of 2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{decrypt}\PYG{p}{(}\PYG{n}{Two\PYGZus{}Encryption}\PYG{p}{,} \PYG{n}{T}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{SK}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Added 1+1 correctly? }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{Two\PYGZus{}Decryption}\PYG{o}{.}\PYG{n}{is\PYGZus{}equal\PYGZus{}to}\PYG{p}{(}\PYG{n}{generate\PYGZus{}constant\PYGZus{}poly}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Decryption of 2 = 2
Added 1+1 correctly? True
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Number of possible additions}
\end{DUlineblock}

\sphinxAtStartPar
As an example, we will now answer the question of how many additions of freshly encrypted ciphertexts are possible, depending on the chosen parameters.
To successfully perform \(k\) additions, the total error size afterwards must not exceed \(Q/(2T)\).
Using the triangle inequality and the error bound in {\hyperref[\detokenize{Thesis:error-after-BFV-encryption}]{\sphinxcrossref{Lemma 3}}} for a certain \(C\), we have to ensure that:
\begin{equation}\label{equation:Thesis:number-of-additions}
\begin{split}k < \frac{Q}{2T\cdot C \sqrt{N}}.\end{split}
\end{equation}
\sphinxAtStartPar
The procedure \(\texttt{how-many-additions}\) below enables us to run various experiments on adding ciphertexts.
It simulates the process of adding (freshly encrypted) ciphertexts and it outputs the maximum of possible (correct) additions, minimized over a number of iterations.
In doing so and compared to averaging the number of possible additions, it reflects the worst\sphinxhyphen{}case scenario, which is pivotal to consider while constructing a FHE scheme.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{how\PYGZus{}many\PYGZus{}additions}\PYG{p}{(}\PYG{n}{key\PYGZus{}size}\PYG{p}{,} \PYG{n}{plaintext\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{ciphertext\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{standard\PYGZus{}deviation}\PYG{p}{,} \PYG{n}{runs}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{N}\PYG{p}{,} \PYG{n}{T}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{STD} \PYG{o}{=} \PYG{n}{key\PYGZus{}size}\PYG{p}{,} \PYG{n}{plaintext\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{ciphertext\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{standard\PYGZus{}deviation}
    \PYG{n}{min\PYGZus{}correct\PYGZus{}additions} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{1000}
    \PYG{n}{SK}\PYG{p}{,} \PYG{n}{PK} \PYG{o}{=} \PYG{n}{keygen}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{STD}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{runs}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{counter} \PYG{o}{=} \PYG{l+m+mi}{0}
        \PYG{n}{random\PYGZus{}message} \PYG{o}{=} \PYG{n}{generate\PYGZus{}uniform\PYGZus{}distribution}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{T}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
        \PYG{n}{encrypted\PYGZus{}message} \PYG{o}{=} \PYG{n}{encrypt}\PYG{p}{(}\PYG{n}{random\PYGZus{}message}\PYG{p}{,} \PYG{n}{T}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{STD}\PYG{p}{,} \PYG{n}{PK}\PYG{p}{)}
        \PYG{k}{while} \PYG{n}{min\PYGZus{}correct\PYGZus{}additions} \PYG{o}{\PYGZgt{}} \PYG{n}{counter}\PYG{p}{:}
            \PYG{n}{new\PYGZus{}random\PYGZus{}message} \PYG{o}{=} \PYG{n}{generate\PYGZus{}uniform\PYGZus{}distribution}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{T}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
            \PYG{n}{encrypted\PYGZus{}new\PYGZus{}message} \PYG{o}{=} \PYG{n}{encrypt}\PYG{p}{(}\PYG{n}{new\PYGZus{}random\PYGZus{}message}\PYG{p}{,} \PYG{n}{T}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{STD}\PYG{p}{,} \PYG{n}{PK}\PYG{p}{)}
            \PYG{n}{random\PYGZus{}message} \PYG{o}{=} \PYG{n}{decrypt}\PYG{p}{(}\PYG{n}{encrypted\PYGZus{}message}\PYG{p}{,} \PYG{n}{T}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{SK}\PYG{p}{)}
            \PYG{n}{sum\PYGZus{}of\PYGZus{}messages} \PYG{o}{=} \PYG{n}{random\PYGZus{}message}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{new\PYGZus{}random\PYGZus{}message}\PYG{p}{,} \PYG{n}{T}\PYG{p}{)}
            \PYG{n}{encrypted\PYGZus{}message} \PYG{o}{=} \PYG{n}{add}\PYG{p}{(}\PYG{n}{encrypted\PYGZus{}message}\PYG{p}{,} \PYG{n}{encrypted\PYGZus{}new\PYGZus{}message}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{)}
            \PYG{k}{if} \PYG{n}{decrypt}\PYG{p}{(}\PYG{n}{encrypted\PYGZus{}message}\PYG{p}{,} \PYG{n}{T}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{SK}\PYG{p}{)}\PYG{o}{.}\PYG{n}{is\PYGZus{}equal\PYGZus{}to}\PYG{p}{(}\PYG{n}{sum\PYGZus{}of\PYGZus{}messages}\PYG{p}{)} \PYG{o}{!=} \PYG{k+kc}{True}\PYG{p}{:}
                \PYG{n}{min\PYGZus{}correct\PYGZus{}additions} \PYG{o}{=} \PYG{n+nb}{min}\PYG{p}{(}\PYG{n}{min\PYGZus{}correct\PYGZus{}additions}\PYG{p}{,} \PYG{n}{counter}\PYG{p}{)}
                \PYG{k}{break}
            \PYG{n}{counter} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
    \PYG{k}{return} \PYG{n}{min\PYGZus{}correct\PYGZus{}additions}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Taking \(T=2, N=16, C=8, \sigma = 1\) and \(Q=2^8\), according to \eqref{equation:Thesis:number-of-additions}, we must be able to perform at least 4 additions, which the following computation underlines.
Remark: The computationally determined value of \(C \approx 8\) (from the section of {\hyperref[\detokenize{Thesis:error-after-BFV-encryption}]{\sphinxcrossref{Lemma 3}}}) should not be used at all for practical purposes, since the bound is only of probabilistic nature (see ibid.)
However, \(C \approx 8\) yields a close estimate:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{how\PYGZus{}many\PYGZus{}additions}\PYG{p}{(}\PYG{l+m+mi}{16}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1000}\PYG{o}{*}\PYG{n}{speed}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
4
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}\phantomsection\label{\detokenize{Thesis:parameter-impact}}
\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Parameter impact}
\end{DUlineblock}

\sphinxAtStartPar
Finally, we want to affirm \eqref{equation:Thesis:number-of-additions} computationally by depicting a diagram, which illustrates the change of the scheme’s parameters and their impact on the (minimum) number of possible additions.
Because we generally work with powers of two for \(N, T\), and \(Q\), we will observe the behaviour of \(\texttt{how-many-additions}\) under doubling each of the parameters and present everything on an exponential/logarithmic scale.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{N}\PYG{p}{,} \PYG{n}{T}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{STD}\PYG{p}{,} \PYG{n}{runs}\PYG{p}{,} \PYG{n}{doublings} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{o}{*}\PYG{n}{speed}\PYG{p}{,} \PYG{l+m+mi}{5}
\PYG{n}{doubling\PYGZus{}N} \PYG{o}{=} \PYG{p}{[}\PYG{n}{how\PYGZus{}many\PYGZus{}additions}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{n}{i}\PYG{p}{)}\PYG{o}{*}\PYG{n}{N}\PYG{p}{,} \PYG{n}{T}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{STD}\PYG{p}{,} \PYG{n}{speed}\PYG{p}{)} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{doublings}\PYG{p}{)}\PYG{p}{]}
\PYG{n}{doubling\PYGZus{}T} \PYG{o}{=} \PYG{p}{[}\PYG{n}{how\PYGZus{}many\PYGZus{}additions}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{n}{i}\PYG{p}{)}\PYG{o}{*}\PYG{n}{T}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{STD}\PYG{p}{,} \PYG{n}{runs}\PYG{p}{)} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{doublings}\PYG{p}{)}\PYG{p}{]}
\PYG{n}{doubling\PYGZus{}Q} \PYG{o}{=} \PYG{p}{[}\PYG{n}{how\PYGZus{}many\PYGZus{}additions}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,} \PYG{n}{T}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{n}{i}\PYG{p}{)}\PYG{o}{*}\PYG{n}{Q}\PYG{p}{,} \PYG{n}{STD}\PYG{p}{,} \PYG{n}{speed}\PYG{p}{)} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{doublings}\PYG{p}{)}\PYG{p}{]}
\PYG{n}{doubling\PYGZus{}STD} \PYG{o}{=} \PYG{p}{[}\PYG{n}{how\PYGZus{}many\PYGZus{}additions}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,} \PYG{n}{T}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{n}{i}\PYG{p}{)}\PYG{o}{*}\PYG{n}{STD}\PYG{p}{,} \PYG{n}{runs}\PYG{p}{)} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{doublings}\PYG{p}{)}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{dpi}\PYG{o}{=}\PYG{l+m+mi}{150}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{doubling\PYGZus{}N}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}\PYGZhy{}o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{label} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Doubling key size N}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{doubling\PYGZus{}T}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}\PYGZhy{}o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{label} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Doubling plaintext modulus T}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{doubling\PYGZus{}Q}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}\PYGZhy{}o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{label} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Doubling ciphertext modulus Q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{doubling\PYGZus{}STD}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}\PYGZhy{}o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{label} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Doubling standard deviation}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{yscale}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{log}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{base} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{xticks}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{doublings}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Minimum of correct additions after }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{runs}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ iterations}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{ (Logarithmic scale)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Times of value doubling}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{ (Exponential Scale)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{Thesis_60_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
To summarize the above, we indeed computationally verify \eqref{equation:Thesis:number-of-additions} containing the factors \(Q, T^{-1}\) and \(1/\sqrt{N}\) as they each correspond to a dotted line.
Furthermore, the diagram shows that doubling the standard deviation \(\sigma\) is even worse than doubling \(T\) in terms of correct additions.

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Multiplying ciphertexts}
\end{DUlineblock}

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Overview}
\end{DUlineblock}

\sphinxAtStartPar
Multiplying RLWE ciphertexts in a clever way is not only a crucial part of designing a homomorphic encryption scheme but it also can be seen as a whole concept in general, which can be extended to several special cases.
Some of these will later be considered during {\hyperref[\detokenize{Thesis:preparations-for-bootstrapping}]{\sphinxcrossref{\DUrole{std,std-ref}{Preparations for bootstrapping}}}}, which underlines the relevance of multiplication for the entire FHE scheme.
For example, the bootstrapping procedure itself can be broken down to scaling up a message hidden in a RLWE ciphertext by a (large) factor.

\sphinxAtStartPar
The state\sphinxhyphen{}of\sphinxhyphen{}the\sphinxhyphen{}art FHE schemes would be significantly faster and more efficient if the inherent multiplication algorithms would be in any way comparable to addition procedures.
Apart from a more advanced description compared with addition, the main thing, which causes multiplication algorithms to be “expensive”, is the error resulting from it.
In the presented scheme, it seems inevitable that the error (during multiplication) will get multiplied by a certain factor, in contrast to addition, where we only added two errors.
Although we will explain some approaches to diminishing the size of this factor and thus the size of the error afterwards in general, scaling up the error size during multiplication procedures still cannot be entirely avoided.

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Motivation}
\end{DUlineblock}

\sphinxAtStartPar
Although we will use multiplication for the more general notion of RLWE ciphertexts later as well (see e.g. {\hyperref[\detokenize{Thesis:operations-on-rlwe-ciphertexts}]{\sphinxcrossref{\DUrole{std,std-ref}{Operations on RLWE ciphertexts}}}}), we will first stick to the BFV case.
For simplicity, and according to our implementation with powers of two \(T<Q\), we will drop the rounding of \(\round{Q/T}\) from now on.
Taking two BFV ciphertexts of their form \((a_i,-a_i\cdot s + e_i + (Q/T) M_i)\) for messages \(M_0,M_1\), we immediately observe that it is mandatory for a BFV multiplication algorithm to multiply the second components \(-a_i\cdot s + e_i + (Q/T) M_i\), yielding a term including \(M_0M_1\).
Because the additive structure is not compatible with multiplication in a linear way, we can already presume that we will obtain several summands, which are dispensable and, in the error case, even obstructive for further operations on ciphertexts.

\sphinxAtStartPar
In total, if we denote the BFV ciphertexts as \((a_0,b_0)\) and \((a_1,b_1)\), the multiplication \(b_0b_1\) yields the following nine summands, which we will need to somehow regroup into three (a secret key component, an error and one containing the hidden \(M_0M_1\)) of a regular BFV ciphertext:
\begin{equation}\label{equation:Thesis:b-0b-1}
\begin{split}\begin{split}
b_0b_1 &= \underbrace{a_0a_1 \mathrm{sk}^2}_{\text{Precomputation of }\mathrm{sk}^2 \text{ is necessary}} \\
&- \underbrace{(a_0e_1+a_1e_0)\mathrm{sk} - (a_0M_1+a_1M_0)( Q/T)\mathrm{sk}}_{\text{Gives rise to first component of the product}} \\
&+ \underbrace{e_0e_1 + ( Q/T) (e_0M_1 +e_1M_0)}_{\text{Inevitable and large error term}} \\
&+ \underbrace{(Q/T)^2 M_0M_1}_{\text{Wrongly scaled message product}}
\end{split}\end{split}
\end{equation}
\sphinxAtStartPar
We will now describe these four aspects in detail.

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Relinearization Keys}
\end{DUlineblock}

\sphinxAtStartPar
We start with the problem of eliminating \(a_0a_1\mathrm{sk}^2\).
For that, we need an outsourced precomputation, i.e. an encryption of \(\mathrm{sk}^2\), which clearly needs to be done by a party with knowledge of \(\mathrm{sk}\).
Since encrypting always comes together with an (additive) error (see {\hyperref[\detokenize{Thesis:error-after-BFV-encryption}]{\sphinxcrossref{Lemma 3}}}) and we need to multiply the encryption of \(\mathrm{sk}^2\) afterwards with \(a_0a_1\), we cannot let this error grow too much.
To clarify the latter, recall that multiplying with \(a_0a_1\) (or any other public ring element) works via multiplying both components of a BFV/RLWE ciphertext by \(a_0a_1\), which also multiplies the intrinsic error with \(a_0a_1\).

\sphinxAtStartPar
This sparks the idea of encrypting \(\mathrm{sk}^2\) via a larger auxiliary modulus \(P\cdot Q\) (for a large \(P\)), in order to scale down the error afterwards by dividing by \(P\) again.
Later, we will investigate this key concept further by introducing a general rescaling procedure (see {\hyperref[\detokenize{Thesis:rescaling}]{\sphinxcrossref{\DUrole{std,std-ref}{Rescaling}}}}).
Needless to say, we then need to encrypt \(P\cdot \mathrm{sk}^2\) instead of \(\mathrm{sk}^2\), since the message, \(P\cdot \mathrm{sk}^2\), will get divided by \(P\) too.

\sphinxAtStartPar
The following algorithm computes the “relinearization keys”, named by the principle of making the multiplied ciphertext \(b_0b_1\) linear in \(\mathrm{sk}\) again.

\sphinxAtStartPar
The relinearization keys are set to:
\begin{equation*}
\begin{split}\mathrm{rlk} := (\mathrm{rlk}_0, \mathrm{rlk}_1) := (\mathrm{rlk}_0, - \mathrm{rlk}_0 \cdot \mathrm{sk} + e_{\text{rlk}} + P\cdot\mathrm{sk}^2 ) \in R_{PQ}^2 \end{split}
\end{equation*}
\sphinxAtStartPar
where \(\mathrm{rlk}_0 \sim \mathcal U(R_{PQ})\) and \(e_{\text{rlk}} \sim \mathcal N_d(0, \sigma^2)\).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{relinearization\PYGZus{}key}\PYG{p}{(}\PYG{n}{ciphertext\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{auxiliary\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{standard\PYGZus{}deviation}\PYG{p}{,} \PYG{n}{secret\PYGZus{}key}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{Q}\PYG{p}{,} \PYG{n}{P}\PYG{p}{,} \PYG{n}{STD}\PYG{p}{,} \PYG{n}{SK} \PYG{o}{=} \PYG{n}{ciphertext\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{auxiliary\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{standard\PYGZus{}deviation}\PYG{p}{,} \PYG{n}{secret\PYGZus{}key}
    \PYG{n}{PQ}\PYG{p}{,} \PYG{n}{N} \PYG{o}{=} \PYG{n}{P}\PYG{o}{*}\PYG{n}{Q}\PYG{p}{,} \PYG{n+nb}{getattr}\PYG{p}{(}\PYG{n}{SK}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ring\PYGZus{}degree}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{rlk\PYGZus{}0} \PYG{o}{=} \PYG{n}{generate\PYGZus{}uniform\PYGZus{}distribution}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{PQ}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{n}{e\PYGZus{}rlk} \PYG{o}{=} \PYG{n}{generate\PYGZus{}gaussian\PYGZus{}distribution}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{STD}\PYG{p}{)}
    \PYG{n}{rlk\PYGZus{}1} \PYG{o}{=} \PYG{n}{SK}\PYG{o}{.}\PYG{n}{multiply}\PYG{p}{(}\PYG{n}{SK}\PYG{p}{)}\PYG{o}{.}\PYG{n}{scalar\PYGZus{}multiply}\PYG{p}{(}\PYG{n}{P}\PYG{p}{)}\PYG{o}{.}\PYG{n}{subtract}\PYG{p}{(}\PYG{n}{rlk\PYGZus{}0}\PYG{o}{.}\PYG{n}{multiply}\PYG{p}{(}\PYG{n}{SK}\PYG{p}{)}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{e\PYGZus{}rlk}\PYG{p}{)}\PYG{p}{,} \PYG{n}{PQ}\PYG{p}{)}
    \PYG{k}{return} \PYG{p}{[}\PYG{n}{rlk\PYGZus{}0}\PYG{p}{,} \PYG{n}{rlk\PYGZus{}1}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
It is important to note that the parameter \(\sigma\) for the error distribution of \(e_{\text{rlk}}\) should greatly differ from the analogous parameter used during (regular) encryption.
In {[}\hyperlink{cite.Thesis:id70}{Fan and Vercauteren, 2012}{]}, Section 6.1, a precise analysis of this subject is given.
Again, because security issues are not the main concern of our implementations and large variances are obstructive to performances of homomorphic operations, we will overlook this fact by continuing to use \(\sigma = 1\) in both cases.

\sphinxAtStartPar
The following lemma (see Section 4 of {[}\hyperlink{cite.Thesis:id70}{Fan and Vercauteren, 2012}{]}) assesses the error after completing the relinerazation process, i.e. the error belonging to an encryption of \(a_0a_1\mathrm{sk}^2\).
\label{Thesis:relinearization-error}
\begin{sphinxadmonition}{note}{Lemma 5 (Relinearization error)}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}
\sphinxAtStartPar
Proof. Set
\begin{equation*}
\begin{split}(r_0,r_1) := \left( \round{\frac{a_0a_1 \mathrm{rlk}_0}{P}}, \round{\frac{a_0a_1 \mathrm{rlk}_1}{P}} \right) \in R_Q^2.\end{split}
\end{equation*}
\sphinxAtStartPar
Then \(\norm{e_{\text{rel}}} = \norm{r_0 \mathrm{sk} + r_1 - a_0a_1\mathrm{sk}^2}\).
It follows that
\begin{equation*}
\begin{split}\norm{e_{\text{rel}}} = \norm{r_0 \mathrm{sk} + \round{\frac{a_0a_1(e_{\text{rlk}} - \mathrm{rlk}_0 \mathrm{sk})}{P}}}.\end{split}
\end{equation*}
\sphinxAtStartPar
Now, we have \(\norm{\round{a_0a_1e_{\text{rlk}}/P}} \le QDN/P\), because \(a_0a_1 \in R_Q\) and \(N\) is the worst\sphinxhyphen{}case expansion factor resulting from multiplying in \(R\).
We are left to estimate a term in the shape of \(\round c \mathrm{sk} - \round{c \cdot \mathrm{sk}} + 1/2\), with \(c = a_0a_1\mathrm{rlk}_0/P \in \Q[x]/\langle x^N + 1\rangle\).
Because \(\norm{\mathrm{sk}} = 1\), the “different rounding” for each coefficient is off by at most \(1/2\), thus in total the infinity norm is bounded by \(N/2 + 1/2\).
The claim follows.
\end{sphinxadmonition}

\sphinxAtStartPar
In the above lemma, \(P\) should be selected such that \(QDN/P < 1\), i.e. keeping \(e_{\text{rel}}\) as small as possible while taking into account that the computational complexity increases with a larger \(P\).
As shown in the proof, the summand \((N+1)/2\) is an estimator for a very unlikely worst case.
Equilibrating effects of summing rounded integers and \(\mathrm{sk} \sim \mathrm{Ter}_{1/3}\) lead to a way smaller error in the average case.

\sphinxAtStartPar
Assuming \(\norm{e_{\text{rlk}}} \le D\), the error \(e_{\text{rel}}\) inside an encryption of \(a_0a_1\mathrm{sk}^2\) satisfies:
\begin{equation*}
\begin{split}\norm{e_{\text{rel}}} \le \frac{Q\cdot D \cdot N}{P} + \frac{N+1}{2}.\end{split}
\end{equation*}
\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large The core of multiplying}
\end{DUlineblock}

\sphinxAtStartPar
After subtracting \(a_0a_1\mathrm{sk}^2\) from \(b_0b_1\) in \eqref{equation:Thesis:b-0b-1}, we proceed with eliminating the dispensable single \(Q/T\) inside \((Q/T)^2 M_0M_1\).
Hence, we need to scale the latter via integer\sphinxhyphen{}dividing (i.e. dividing and rounding) by \(T/Q\), which can naturally only be done implicitly by operating on \(b_0b_1\).
We will employ this technique as well for other terms consisting of \(a_i\) and \(b_i\), see below.

\sphinxAtStartPar
Apart from the inevitable error term of multiplying in \eqref{equation:Thesis:b-0b-1}, we are now left with setting up the first component of the product ciphertext, which consists of a \(R_Q\)\sphinxhyphen{}element, which gets multiplied by \(\mathrm{sk}\) during decryption.
Hence, this \(R_Q\)\sphinxhyphen{}element should correspond to the term linear in \(\mathrm{sk}\) in \eqref{equation:Thesis:b-0b-1}.
For defining the first component we consider the cross\sphinxhyphen{}combination of \(a_i\) and \(b_i\):
\begin{equation*}
\begin{split}a_0b_1 + a_1b_0 = -2a_1a_0\mathrm{sk} + (a_0e_1+a_1e_0) + (a_0M_1+a_1M_0) (Q/T)\end{split}
\end{equation*}
\sphinxAtStartPar
Notice that multiplying the left\sphinxhyphen{}hand side by \(\mathrm{sk}\) (occurs during decryption) yields similar, yet not entirely identical summands compared to the second line in \eqref{equation:Thesis:b-0b-1} (bar the scaling by \(T/Q\)).

\sphinxAtStartPar
All questions raised from \eqref{equation:Thesis:b-0b-1} now being answered in theory, we will introduce the common notation of \(\Delta := Q/T\) before describing the actual algorithm:
As a first step, we want to merge the following three ciphertexts into two:
\begin{equation*}
\begin{split}
c_0 := \lfloor \Delta^{-1} a_0a_1 \rceil, \qquad c_1 := \lfloor \Delta^{-1} (a_0b_1+a_1b_0) \rceil, \qquad c_2 := \lfloor \Delta^{-1} b_0b_1 \rceil
\end{split}
\end{equation*}
\sphinxAtStartPar
Using the relinearization keys \(\mathrm{rlk}\), we define the ciphertext of the product as:
\begin{equation*}
\begin{split}
c_{\text{mult}} := (c_{\text{mult},0},c_{\text{mult},1}) :=  (c_1 + \lfloor(c_0 \cdot \mathrm{rlk}_0) / P\rceil , c_2 + \lfloor (c_0 \cdot \mathrm{rlk}_1) / P \rceil)
\end{split}
\end{equation*}
\sphinxAtStartPar
If we apply the main query of decryption, i.e. computing \(c_{\text{mult},0}\cdot \mathrm{sk} + c_{\text{mult},1}\), we obtain the following:
\begin{equation*}
\begin{split}\begin{split}
c_{\text{mult},0} \cdot \mathrm{sk} + c_{\text{mult},1} &= \lfloor \Delta^{-1} (a_0b_1+a_1b_0) \rceil \mathrm{sk} + \lfloor(c_0 \cdot \mathrm{rlk}_0) / P\rceil \mathrm{sk} + c_2 + \lfloor (c_0 \cdot \mathrm{rlk}_1) / P \rceil\\
    &= \lfloor \Delta^{-1} (a_0(-a_1\cdot \mathrm{sk} + e_1 + \Delta M_1)+a_1(-a_0\cdot \mathrm{sk} + e_0 + \Delta M_0)) \rceil \mathrm{sk} \\
    &+ \lfloor(\lfloor \Delta^{-1} a_0a_1 \rceil \cdot \mathrm{rlk}_0) / P\rceil \mathrm{sk} + \lfloor \Delta^{-1}  (a_0a_1 \mathrm{sk}^2 - (a_0e_1+a_1e_0)\mathrm{sk} - (a_0M_1+a_1M_0)\Delta)\mathrm{sk} \\
    &+ e_0e_1 + \Delta (e_0M_1 +e_1M_0) + \Delta^2 M_0M_1) \rceil + \lfloor (\lfloor \Delta^{-1} a_0a_1 \rceil \cdot (- \mathrm{rlk}_0 \cdot \mathrm{sk} + e_{\text{rlk}} + P\cdot\mathrm{sk}^2 )) / P \rceil \\
    &\approx \lfloor \Delta^{-1} e_0e_1 \rceil + (e_0M_1+e_1M_0) + e_{\text{rel}} + \Delta M_0 M_1
\end{split}\end{split}
\end{equation*}
\sphinxAtStartPar
Remark on the calculation:
For readability reasons all details on the modular arithmetic (e.g. difference of working in \(R\) or \(R_Q\) respectively \(R_{PQ}\)) have been omitted in the above.
Their presence becomes clearer in the code and their effect on the error analysis is described below.

\sphinxAtStartPar
In the last approximation step, all the rounding errors have been temporarily ignored to highlight the main components.
We observe three error summands plus the scaled product of \(M_0M_1\) \sphinxhyphen{} the result precisely satisfies the structure of a BFV ciphertext.
Whereas the size of \(\Delta^{-1}e_0e_1\) and \(e_{\text{rel}}\) (see {\hyperref[\detokenize{Thesis:relinearization-error}]{\sphinxcrossref{Lemma 5}}}) seems decent, the size of the second error term \(e_0M_1+e_1M_0\) remains the main concern since it relies on \(M_i\) (thus on \(T\)) and is of the multiplicative kind, too.
We will investigate the total error after a multiplication further, after stating the code.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{multiply}\PYG{p}{(}\PYG{n}{ciphertext1}\PYG{p}{,} \PYG{n}{ciphertext2}\PYG{p}{,} \PYG{n}{plaintext\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{ciphertext\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{auxiliary\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{relinearization\PYGZus{}keys}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{ct1}\PYG{p}{,} \PYG{n}{ct2}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{T}\PYG{p}{,} \PYG{n}{P}\PYG{p}{,} \PYG{n}{rlk} \PYG{o}{=} \PYG{n}{ciphertext1}\PYG{p}{,} \PYG{n}{ciphertext2}\PYG{p}{,} \PYG{n}{ciphertext\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{plaintext\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{auxiliary\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{relinearization\PYGZus{}keys}    
    \PYG{n}{c\PYGZus{}0} \PYG{o}{=} \PYG{n}{ct1}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{multiply}\PYG{p}{(}\PYG{n}{ct2}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{rounded\PYGZus{}integer\PYGZus{}divide}\PYG{p}{(}\PYG{n}{Q}\PYG{o}{/}\PYG{o}{/}\PYG{n}{T}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{)}
    \PYG{n}{c\PYGZus{}1} \PYG{o}{=} \PYG{n}{ct1}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{multiply}\PYG{p}{(}\PYG{n}{ct2}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{ct1}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{multiply}\PYG{p}{(}\PYG{n}{ct2}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}\PYG{n}{rounded\PYGZus{}integer\PYGZus{}divide}\PYG{p}{(}\PYG{n}{Q}\PYG{o}{/}\PYG{o}{/}\PYG{n}{T}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{)}
    \PYG{n}{c\PYGZus{}2} \PYG{o}{=} \PYG{n}{ct1}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{multiply}\PYG{p}{(}\PYG{n}{ct2}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{rounded\PYGZus{}integer\PYGZus{}divide}\PYG{p}{(}\PYG{n}{Q}\PYG{o}{/}\PYG{o}{/}\PYG{n}{T}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{)}
    \PYG{n}{c\PYGZus{}00} \PYG{o}{=} \PYG{n}{c\PYGZus{}0}\PYG{o}{.}\PYG{n}{multiply}\PYG{p}{(}\PYG{n}{rlk}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{rounded\PYGZus{}integer\PYGZus{}divide}\PYG{p}{(}\PYG{n}{P}\PYG{p}{)}\PYG{o}{.}\PYG{n}{mod}\PYG{p}{(}\PYG{n}{Q}\PYG{p}{)}
    \PYG{n}{c\PYGZus{}01} \PYG{o}{=} \PYG{n}{c\PYGZus{}0}\PYG{o}{.}\PYG{n}{multiply}\PYG{p}{(}\PYG{n}{rlk}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{rounded\PYGZus{}integer\PYGZus{}divide}\PYG{p}{(}\PYG{n}{P}\PYG{p}{)}\PYG{o}{.}\PYG{n}{mod}\PYG{p}{(}\PYG{n}{Q}\PYG{p}{)}
    \PYG{k}{return} \PYG{p}{[}\PYG{n}{c\PYGZus{}1}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{c\PYGZus{}00}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{)}\PYG{p}{,} \PYG{n}{c\PYGZus{}2}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{c\PYGZus{}01}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{)}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
As an example, we compute \(1 \cdot 1\) in ciphertext space:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{N}\PYG{p}{,} \PYG{n}{T}\PYG{p}{,} \PYG{n}{Q} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{20} 
\PYG{n}{rlk} \PYG{o}{=} \PYG{n}{relinearization\PYGZus{}key}\PYG{p}{(}\PYG{n}{Q}\PYG{p}{,} \PYG{n}{Q}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{STD}\PYG{p}{,} \PYG{n}{SK}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} P = Q\PYGZca{}2 yields relinearization modulus Q\PYGZca{}3}
\PYG{n}{Product\PYGZus{}Encryption} \PYG{o}{=} \PYG{n}{multiply}\PYG{p}{(}\PYG{n}{One\PYGZus{}Encryption}\PYG{p}{,} \PYG{n}{One\PYGZus{}Encryption}\PYG{p}{,} \PYG{n}{T}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{Q}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{rlk}\PYG{p}{)}
\PYG{n}{Product\PYGZus{}Decryption} \PYG{o}{=} \PYG{n}{print\PYGZus{}and\PYGZus{}return}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Product of 1*1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{decrypt}\PYG{p}{(}\PYG{n}{Product\PYGZus{}Encryption}\PYG{p}{,} \PYG{n}{T}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{SK}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Multiplied 1*1 correctly?}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Product\PYGZus{}Decryption}\PYG{o}{.}\PYG{n}{is\PYGZus{}equal\PYGZus{}to}\PYG{p}{(}\PYG{n}{generate\PYGZus{}constant\PYGZus{}poly}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Product of 1*1 = 1
Multiplied 1*1 correctly? True
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Error analysis}
\end{DUlineblock}

\sphinxAtStartPar
To derive a worst\sphinxhyphen{}case bound for the error after one multiplication, we will follow the approach in {[}\hyperlink{cite.Thesis:id70}{Fan and Vercauteren, 2012}{]}, Section 4.

\sphinxAtStartPar
Firstly, we will introduce an useful notation for \(\mathrm{ct}_i := (a_i,b_i)\), that is interpreting \(\mathrm{ct}_i\) as a polynomial as \(\mathrm{ct}_i(x) := a_i x + b_i\).
Using that, we have (in \(R\)):
\begin{equation}\label{equation:Thesis:multiplication-approximation}
\begin{split}\Delta^{-1}\cdot (\mathrm{ct}_0 \cdot \mathrm{ct}_1)(\mathrm{sk}) = c_0\mathrm{sk}^2 + c_1\mathrm{sk} + c_2 + e_{\text{approx}}.\end{split}
\end{equation}
\sphinxAtStartPar
The goal is to estimate the left\sphinxhyphen{}hand side.
The right\sphinxhyphen{}hand side is the approximation, whose \(c_i\) are part of the algorithm, and it still contains the relinearization term, which was previously analysed.

\sphinxAtStartPar
Notice that \(e_{\text{approx}} \in \Q[x]/\langle x^N+1\rangle\) in the equation and its norm can be estimated as \(\approx \delta_R^2\).
The multiplication expansion factor \(\delta_R := \max \{\norm{ab}/(\norm a\norm b): a,b \in R\}\) will be further useful (see {\hyperref[\detokenize{Thesis:conclusion-on-delta-r}]{\sphinxcrossref{\DUrole{std,std-ref}{Conclusion on the expansion factor}}}}).
Its value is at most \(\delta_R' = N\) and for special cases, i.e. using \(a, b\) sampled from e.g. \(\mathrm{Ter}_{1/3}, \mathcal N_d(0,\sigma^2), \mathcal U (R_Q)\), usually around \(\delta_R = \sqrt{N}\).
To verify the estimation, consider e.g. for \(c_0\):
\begin{equation*}
\begin{split}\norm{\Delta^{-1}(a_0a_1\mathrm{sk}^2) - c_0\mathrm{sk}^2} = \norm{(\Delta^{-1}a_0a_1 - \round{\Delta^{-1}a_0a_1})\mathrm{sk}^2}\le (1/2) \delta_R \delta_R,\end{split}
\end{equation*}
\sphinxAtStartPar
using \(\norm{\mathrm{sk}^2} \le \delta_R\) for \(\mathrm{sk} \sim \mathrm{Ter}_{1/3}\).
Now, the same bound holds for the terms of \(c_1\) and \(c_2\), yielding (approximately) \(\norm{e_{\text{approx}}} \le \delta_R^2 = N\).

\sphinxAtStartPar
We will now write \(\mathrm{ct}_i(\mathrm{sk}) \in R\) as \(e_i + \Delta \cdot M_i + Q \cdot f_i\) with \(\norm{f_i} \le \delta_R\) as well.

\sphinxAtStartPar
Before starting to estimate the size of the left\sphinxhyphen{}hand side in \eqref{equation:Thesis:multiplication-approximation}, we need two estimations regarding modular reduction (denoted by e.g. \([x]_T\) to clarify \(x \in R_T\)).
\begin{equation*}
\begin{split}M_0M_1 = [M_0M_1]_T + T \cdot f_M, \qquad e_0e_1 = [e_0e_1]_\Delta + \Delta \cdot f_e.\end{split}
\end{equation*}
\sphinxAtStartPar
Because \(\norm{M_i} \le T/2\), we have \(\norm{f_M} \le NT/4\), where \(\delta_R'\) must be used since messages are not drawn samples from distributions.
Similarly, if \(\norm{e_i} \le E\), then \(\norm{f_e} \le \delta_R E^2\Delta^{-1}\).
Now as a calculation shows, the left\sphinxhyphen{}hand side in \eqref{equation:Thesis:multiplication-approximation} equals:
\begin{equation}\label{equation:Thesis:estimation-of-multiplication}
\begin{split}\begin{split}
&\Delta[M_0M_1]_T + (M_0e_1+M_1e_0) + T(e_0f_1+e_1f_0) + f_e + \Delta^{-1}[e_0e_1]_\Delta \\
&+ Q(M_0f_1+M_1f_0+f_M) + QTf_0f_1.
\end{split}\end{split}
\end{equation}
\sphinxAtStartPar
Notice that the second line ultimately vanishes modulo \(Q\) and in the first line only \(\Delta^{-1}[e_0e_1]_\Delta\) (with norm \(\le 1\)) has rational coefficients.

\sphinxAtStartPar
We may now summarize the error analysis in a theorem, which is similar to Lemma 2 in {[}\hyperlink{cite.Thesis:id70}{Fan and Vercauteren, 2012}{]}.
\label{Thesis:error-after-BFV-multiplication}
\begin{sphinxadmonition}{note}{Theorem 6 (Error after BFV multiplication)}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}
\sphinxAtStartPar
Proof. If we substitute \eqref{equation:Thesis:estimation-of-multiplication} in \eqref{equation:Thesis:multiplication-approximation}, reducing modulo \(Q\) and rounding yields:
\begin{equation*}
\begin{split}\Delta [M_0M_1]_T + (M_0e_1+M_1e_0) + T(e_0f_1+e_1f_0) + f_e + \round{\Delta^{-1}[e_0e_1]_\Delta - e_{\text{approx}}}
= [c_0\mathrm{sk}^2 + c_1\mathrm{sk} + c_2]_Q\end{split}
\end{equation*}
\sphinxAtStartPar
The norms of the summands estimate as follows:
\begin{equation*}
\begin{split}\begin{split}
\norm{M_0e_1+M_1e_0} &\le 2 (T/2) E \delta_R = TE\sqrt{N} \\
\norm{T(e_0f_1+e_1f_0)} &\le T \cdot 2 E \delta_R^2 = 2TEN \\
\norm{f_e + \round{\Delta^{-1}[e_0e_1]_\Delta - e_{\text{approx}}}} &\le \delta_R E^2 \Delta^{-1} + (1 + N) \le \sqrt{N}E + N
\end{split}\end{split}
\end{equation*}
\sphinxAtStartPar
since \(E < \Delta\) (for correct decryption).
Clearly, \(2TEN\) is the dominant term.
Together with \(e_{\text{rel}}\) (negligible size, see {\hyperref[\detokenize{Thesis:relinearization-error}]{\sphinxcrossref{Lemma 5}}}), whose relinearzation procedure eliminates \(c_0\mathrm{sk}^2\) in the above, the claim follows.
\end{sphinxadmonition}

\sphinxAtStartPar
Continuing the above example of multiplying \(1\cdot 1\) in encrypted form, we want to test computationally if the bound \(2\cdot TEN\), or more generally \(C\cdot TEN\) with a constant \(C > 2\), holds with high probability.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{N}\PYG{p}{,} \PYG{n}{T}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{iterations}\PYG{p}{,} \PYG{n}{counter}\PYG{p}{,} \PYG{n}{Max\PYGZus{}C} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{10000}\PYG{o}{*}\PYG{n}{speed}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}
\PYG{n}{Delta\PYGZus{}One} \PYG{o}{=} \PYG{n}{generate\PYGZus{}one\PYGZus{}poly}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{o}{.}\PYG{n}{scalar\PYGZus{}multiply}\PYG{p}{(}\PYG{n}{Q}\PYG{o}{/}\PYG{o}{/}\PYG{n}{T}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{iterations}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{One\PYGZus{}Enc} \PYG{o}{=} \PYG{n}{encrypt}\PYG{p}{(}\PYG{n}{generate\PYGZus{}one\PYGZus{}poly}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{,} \PYG{n}{T}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{PK}\PYG{p}{)}
    \PYG{n}{Product} \PYG{o}{=} \PYG{n}{multiply}\PYG{p}{(}\PYG{n}{One\PYGZus{}Enc}\PYG{p}{,} \PYG{n}{One\PYGZus{}Enc}\PYG{p}{,} \PYG{n}{T}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{Q}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{rlk}\PYG{p}{)}
    \PYG{n}{E} \PYG{o}{=} \PYG{n}{One\PYGZus{}Enc}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{multiply}\PYG{p}{(}\PYG{n}{SK}\PYG{p}{)}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{One\PYGZus{}Enc}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{subtract}\PYG{p}{(}\PYG{n}{Delta\PYGZus{}One}\PYG{p}{)}\PYG{o}{.}\PYG{n}{mod\PYGZus{}small}\PYG{p}{(}\PYG{n}{Q}\PYG{p}{)}\PYG{o}{.}\PYG{n}{norm}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{Product\PYGZus{}Norm} \PYG{o}{=} \PYG{n}{Product}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{multiply}\PYG{p}{(}\PYG{n}{SK}\PYG{p}{)}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{Product}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{subtract}\PYG{p}{(}\PYG{n}{Delta\PYGZus{}One}\PYG{p}{)}\PYG{o}{.}\PYG{n}{mod\PYGZus{}small}\PYG{p}{(}\PYG{n}{Q}\PYG{p}{)}\PYG{o}{.}\PYG{n}{norm}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{if} \PYG{n}{Product\PYGZus{}Norm} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{p}{(}\PYG{n}{E}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{N}\PYG{o}{*}\PYG{n}{T}\PYG{p}{:}
        \PYG{n}{counter} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n}{Max\PYGZus{}C} \PYG{o}{=} \PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{Max\PYGZus{}C}\PYG{p}{,} \PYG{n}{Product\PYGZus{}Norm}\PYG{o}{/}\PYG{p}{(}\PYG{n}{E}\PYG{o}{*}\PYG{n}{N}\PYG{o}{*}\PYG{n}{T}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Out of }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{iterations}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ iterations: ratio of correct bound }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{counter}\PYG{o}{/}\PYG{n}{iterations}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Maximum C was }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{Max\PYGZus{}C}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Out of 1000000 iterations: ratio of correct bound 0.997312
Maximum C was 4.125
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}\phantomsection\label{\detokenize{Thesis:preparations-for-bootstrapping}}
\sphinxAtStartPar
The error size after multiplying two BFV ciphertexts \((a_i,-a_i\cdot \mathrm{sk} + e_i + \Delta\cdot M_i)\) with \(\norm{e_i} \le E\) and \(\norm{\mathrm{sk}} = 1\) can approximately be bounded by \(2\cdot T\cdot E\cdot N\).

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Preparations for bootstrapping}
\end{DUlineblock}

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large RLWE ciphertexts}
\end{DUlineblock}

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Motivation}
\end{DUlineblock}

\sphinxAtStartPar
Bootstrapping, apart from some minor precomputations, happens entirely in ciphertext spaces like \(R_Q\).
Hence, as the presented bootstrapping procedure from {[}\hyperlink{cite.Thesis:id72}{Kim \sphinxstyleemphasis{et al.}, 2021}{]} is technically applicable to any RLWE\sphinxhyphen{}based scheme (CKKS, BFV, BGV, etc.), it is helpful to simplify the notion of a ciphertext, such that it becomes independent of various encoding techniques, e.g. BFV.

\sphinxAtStartPar
We universally speak of a RLWE\sphinxhyphen{}ciphertext, similiar to {\hyperref[\detokenize{Thesis:RLWE-distribution}]{\sphinxcrossref{Definition 2}}}, of a message \(m\) encrypted under the secret key \(s\) using the ciphertext modulus \(Q\) and denote it as:
\begin{equation*}
\begin{split}
\mathrm{RLWE}_{Q,s}(m) := (a, -a\cdot s+e+m) \in R_Q^2.
\end{split}
\end{equation*}
\sphinxAtStartPar
We occasionally omit the indices, if \(Q\) respectively \(s\) are clear from the context.
If the corresponding error \(e\) is \(0\), we will write \(\mathrm{RLWE}_{Q,s}^0(m)\) instead.
In the same fashion as in BFV encryption, \(m\) could be RLWE\sphinxhyphen{}encrypted by using a public key only.
Nevertheless, it is not necessary to consider this extension, since we will only work in ciphertext space during bootstrapping.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{rlwe\PYGZus{}encryption}\PYG{p}{(}\PYG{n}{message}\PYG{p}{,} \PYG{n}{ciphertext\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{standard\PYGZus{}deviation}\PYG{p}{,} \PYG{n}{secret\PYGZus{}key}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{Q}\PYG{p}{,} \PYG{n}{s}\PYG{p}{,} \PYG{n}{N} \PYG{o}{=} \PYG{n}{ciphertext\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{secret\PYGZus{}key}\PYG{p}{,} \PYG{n+nb}{getattr}\PYG{p}{(}\PYG{n}{message}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ring\PYGZus{}degree}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{a} \PYG{o}{=} \PYG{n}{generate\PYGZus{}uniform\PYGZus{}distribution}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Q}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{n}{e} \PYG{o}{=} \PYG{n}{generate\PYGZus{}gaussian\PYGZus{}distribution}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{standard\PYGZus{}deviation}\PYG{p}{)}
    \PYG{n}{b} \PYG{o}{=} \PYG{n}{a}\PYG{o}{.}\PYG{n}{scalar\PYGZus{}multiply}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{.}\PYG{n}{multiply}\PYG{p}{(}\PYG{n}{s}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{)}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{e}\PYG{p}{)}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{message}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{)}
    \PYG{k}{return} \PYG{p}{[}\PYG{n}{a}\PYG{p}{,}\PYG{n}{b}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
The goal of bootstrapping now comes down to replacing a large error within \(\mathrm{RLWE}_{Q,s}(m)\) with a small fresh one.
By the latter, we mean an error with the same size and quality as an error coming from an initial encryption to preserve security.
Interestingly, bootstrapping can be deconstructed into the core procedure \(\texttt{scaled-mod}\) and the surrounding adaption to the BFV scheme.
Informally speaking, \(\texttt{scaled-mod}\) only consists of the operation of scaling a \(\mathrm{RLWE}(m)\) to \(\mathrm{RLWE}(\Delta \cdot m)\) for a large \(\Delta\) (different delta from BFV\sphinxhyphen{}multiplication).
Since just computing \(\mathrm{RLWE}(m) \cdot \Delta\) would also scale the intrinsic error \(e\) by \(\Delta\), which itself would imply an impossible decryption, the development of techniques to limit error growth during multiplication with ciphertexts is unavoidable.
In this chapter, which is based on {[}\hyperlink{cite.Thesis:id72}{Kim \sphinxstyleemphasis{et al.}, 2021}{]}, Section 2, we will explain some of these techniques and analyse the resulting effect on the error growth.

\phantomsection\label{\detokenize{Thesis:operations-on-rlwe-ciphertexts}}
\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Operations on RLWE ciphertexts}
\end{DUlineblock}

\sphinxAtStartPar
To start, we have to define two auxiliary functions, which allow us to effectively deal with RLWE ciphertexts.
The most basic operation is again addition.
It can be done in the same direct way as we have realized BFV addition, namely by adding the components.
In the same fashion, this evokes nearly no issues concerning the error, which is only the sum of the previous errors and thus still comparably small.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{rlwe\PYGZus{}add}\PYG{p}{(}\PYG{n}{rlwe1}\PYG{p}{,} \PYG{n}{rlwe2}\PYG{p}{,} \PYG{n}{modulus}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{p}{[}\PYG{n}{rlwe1}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{rlwe2}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{modulus}\PYG{p}{)}\PYG{p}{,} \PYG{n}{rlwe1}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{rlwe2}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{modulus}\PYG{p}{)}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
The second operation is multiplication with a polynomial \(p\) in both components.
As mentioned earlier, this includes multiplication of the error and message likewise.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{rlwe\PYGZus{}multiply\PYGZus{}with\PYGZus{}poly}\PYG{p}{(}\PYG{n}{rlwe}\PYG{p}{,} \PYG{n}{poly}\PYG{p}{,} \PYG{n}{modulus}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{p}{[}\PYG{n}{rlwe}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{multiply}\PYG{p}{(}\PYG{n}{poly}\PYG{p}{,} \PYG{n}{modulus}\PYG{p}{)}\PYG{p}{,} \PYG{n}{rlwe}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{multiply}\PYG{p}{(}\PYG{n}{poly}\PYG{p}{,} \PYG{n}{modulus}\PYG{p}{)}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Because we will need it later, note that the error \(ep\) after multiplying \(\mathrm{RLWE}_{Q,s}(m) := (a, -as+e+m)\) with \(p\) has size at most:
\begin{equation}\label{equation:Thesis:rlwe-multiply-error-growth}
\begin{split}\norm{ e\cdot p}\le \norm e \cdot \#\{p_i : p_i \neq 0\} \cdot \norm{p}.\end{split}
\end{equation}
\sphinxAtStartPar
Since the result of \(\texttt{rlwe-multiply-with-poly}\) is a ciphertext, which relies on correct decryption (see {\hyperref[\detokenize{Thesis:correct-BFV-decryption}]{\sphinxcrossref{Lemma 4}}}), \(p\) must be chosen carefully.
Monomials as \(p\) achieve the sharpest bound in this context, i.e. then \(\norm{ep} = \norm{e}\), because multiplication with \(p\) then only shuffles the coefficients of \(e\) with a possible change in sign.
If we use a sum of monomials as \(p\), we still receive an optimal result, since the error growth is exactly the same, as the comparison between \(\texttt{rlwe-add}(\mathrm{RLWE}(m\cdot x^j),\mathrm{RLWE}(m\cdot x^k))\) and \(\texttt{rlwe-multiply-with-poly}(\mathrm{RLWE}(m),x^j+x^k)\) shows.
For a general polynomial \(p\) and if \(p_i\) and \(e_i\) are i.i.d. with mean zero, we may also use the standard estimation \(\norm{ep}
 \le \delta_R \norm e \norm p\) (see {\hyperref[\detokenize{Thesis:conclusion-on-delta-r}]{\sphinxcrossref{\DUrole{std,std-ref}{Conclusion on the expansion factor}}}}).

\sphinxAtStartPar
Following these observations, we will later outsource a polynomial multiplication to many individual monomial multiplications and in particular, our next objective will be the reduction of \(\norm{p}\) to smaller values by base\sphinxhyphen{}decomposing polynomials/ciphertexts.

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large RLWE’ ciphertexts}
\end{DUlineblock}

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Motivation}
\end{DUlineblock}

\sphinxAtStartPar
Essentially, a RLWE’ ciphertext is a blow\sphinxhyphen{}up of a RLWE ciphertext used to better handle error growth during \(\texttt{rlwe-multiply-with-poly}\).
Constructing a RLWE’ ciphertext will be done by RLWE\sphinxhyphen{}encrypting the corresponding message scalar multiplied by powers of a certain base \(B > 1\).

\sphinxAtStartPar
To specify the latter, we are scalar multiplying our message with a so\sphinxhyphen{}called gadget vector \(g := (1,B,B^2,\dots,B^l)\), where \(l \in \mathbb N\) is maximal in terms of \(B^l < \log_B(Q)\).
The gadget vector has the property of letting any ring element \(r\in R_Q\) uniquely get gadget\sphinxhyphen{}decomposed into:
\begin{equation*}
\begin{split}r = \sum_{i=0}^l g_i \cdot r_i, \qquad \norm{r_i} \le B/2.\end{split}
\end{equation*}
\sphinxAtStartPar
Basically, this is just the extension of base \(B\) decomposition from numbers to polynomials.
The RLWE’ encryption of a message \(m\) with respect to base \(B\) now is defined as:
\begin{equation*}
\begin{split}\mathrm{RLWE'}_{Q,s}(m) := (\mathrm{RLWE}_{Q,s}(B^i \cdot m))_{i \in \{0, \dots, l\}} \in R_Q^{l+1}\end{split}
\end{equation*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{rlwe\PYGZus{}x\PYGZus{}encryption}\PYG{p}{(}\PYG{n}{message}\PYG{p}{,} \PYG{n}{ciphertext\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{B}\PYG{p}{,} \PYG{n}{standard\PYGZus{}deviation}\PYG{p}{,} \PYG{n}{secret\PYGZus{}key}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{m}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{s}\PYG{p}{,} \PYG{n}{STD} \PYG{o}{=} \PYG{n}{message}\PYG{p}{,} \PYG{n}{ciphertext\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{secret\PYGZus{}key}\PYG{p}{,} \PYG{n}{standard\PYGZus{}deviation}
    \PYG{n}{g} \PYG{o}{=} \PYG{p}{[}\PYG{n}{B} \PYG{o}{*}\PYG{o}{*} \PYG{n}{i} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{ceil}\PYG{p}{(}\PYG{n}{log}\PYG{p}{(}\PYG{n}{Q}\PYG{p}{,} \PYG{n}{B}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)} \PYG{p}{]}
    \PYG{k}{return} \PYG{p}{[}\PYG{n}{rlwe\PYGZus{}encryption}\PYG{p}{(}\PYG{n}{m}\PYG{o}{.}\PYG{n}{scalar\PYGZus{}multiply}\PYG{p}{(}\PYG{n}{g}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{STD}\PYG{p}{,} \PYG{n}{s}\PYG{p}{)} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{g}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Remark on \(B\):
Because our scheme uses a power of two as \(Q\), it stands to reason for simplicity to use a power of two as \(B\) as well.
As \(B\) will be a changeable bootstrapping parameter, it has a non\sphinxhyphen{}negligible impact on the running time, too.
As we will analyse in the next section, for a larger \(B\) there is a fine trade\sphinxhyphen{}off between the larger error it induces during RLWE’ operations and the faster running times respectively less memory it requires at the same time.

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Operations on RLWE’ ciphertexts}
\end{DUlineblock}

\sphinxAtStartPar
If one once again considers the error problem concerning the \(\texttt{rlwe-multiply-with-poly}\) algorithm, we may now solve this issue by using our decomposed information hiding inside a RLWE’ ciphertext.
Recall that multiplying with a large polynomial \(r\) results in too large an error for correct decryption.
Utilizing the above property that \(\norm{r_i} \le B/2\), we can improve the size of the error after a multiplication by splitting up the multiplication process among the \(r_i\)’s.

\sphinxAtStartPar
We define the so\sphinxhyphen{}called scalar multiplication \(\odot\) of a RLWE’ ciphertext with a polynomial \(r \in R_Q\) using the above notation as:
\begin{equation*}
\begin{split}\texttt{rlwe-x-scalar-multiply}: r \odot \mathrm{RLWE'}_{Q,s}(m) := \sum_{i=0}^l r_i \cdot \mathrm{RLWE}_{Q,s}(B^i \cdot m)\end{split}
\end{equation*}
\sphinxAtStartPar
The above uses the homomorphic procedures for RLWE ciphertexts, i.e. \(\texttt{rlwe-add}\) and \(\texttt{rlwe-multiply-with-poly}\), to compute the right\sphinxhyphen{}hand side.
Hence, we have:
\begin{equation*}
\begin{split}\sum_{i=0}^l r_i \cdot \mathrm{RLWE}_{Q,s}(B^i \cdot m) = \mathrm{RLWE}_{Q,s} \left( \sum_{i=0}^l r_i \cdot B^i \cdot m \right) = \mathrm{RLWE}_{Q,s}(r\cdot m)\end{split}
\end{equation*}
\sphinxAtStartPar
So in total, \(\texttt{rlwe-x-scalar-multiply}\) enables us to compute \(\texttt{rlwe-multiply-with-poly}(\mathrm{RLWE}(m), r)\) with a smaller error, whose size we will analyse after stating the algorithm.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{rlwe\PYGZus{}x\PYGZus{}scalar\PYGZus{}multiply}\PYG{p}{(}\PYG{n}{r\PYGZus{}Q}\PYG{p}{,} \PYG{n}{rlwe\PYGZus{}x}\PYG{p}{,} \PYG{n}{ciphertext\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{B}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{l} \PYG{o}{=} \PYG{n}{ceil}\PYG{p}{(}\PYG{n}{log}\PYG{p}{(}\PYG{n}{ciphertext\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{B}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{r} \PYG{o}{=} \PYG{n}{r\PYGZus{}Q}\PYG{o}{.}\PYG{n}{base\PYGZus{}decompose}\PYG{p}{(}\PYG{n}{B}\PYG{p}{,} \PYG{n}{l}\PYG{p}{)}
    \PYG{n}{result} \PYG{o}{=} \PYG{p}{[}\PYG{n}{generate\PYGZus{}constant\PYGZus{}poly}\PYG{p}{(}\PYG{n+nb}{getattr}\PYG{p}{(}\PYG{n}{r\PYGZus{}Q}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ring\PYGZus{}degree}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{]}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{l}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{temp} \PYG{o}{=} \PYG{n}{rlwe\PYGZus{}multiply\PYGZus{}with\PYGZus{}poly}\PYG{p}{(}\PYG{n}{rlwe\PYGZus{}x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{r}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ciphertext\PYGZus{}modulus}\PYG{p}{)}
        \PYG{n}{result} \PYG{o}{=} \PYG{n}{rlwe\PYGZus{}add}\PYG{p}{(}\PYG{n}{result}\PYG{p}{,} \PYG{n}{temp}\PYG{p}{,} \PYG{n}{ciphertext\PYGZus{}modulus}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{result}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}\label{Thesis:error-after-rlwe-x-scalar-multiply}
\begin{sphinxadmonition}{note}{Lemma 6 (Error after \protect\(\texttt{rlwe-x-scalar-multiply}\protect\))}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}
\sphinxAtStartPar
Proof. The procedure \(\texttt{rlwe-multiply-with-poly}\) computes \(er\).
Thus the error size afterwards is \(\delta_R^{(')} \cdot \norm{e} \cdot (B/2)\), using an ring expansion factor \(\delta_R^{(')}\) dependent on \(e\) and \(r\) (see {\hyperref[\detokenize{Thesis:conclusion-on-delta-r}]{\sphinxcrossref{\DUrole{std,std-ref}{Conclusion on the expansion factor}}}}).
The claim follows since we then perform \(l \approx \log_B(Q)\) additions using \(\texttt{rlwe-add}\).
\end{sphinxadmonition}

\sphinxAtStartPar
Remark: Interestingly, \(B \cdot l \approx B \cdot \log_B(Q)\) inside the error bound gets minimal for \(B\) equal to Euler’s number \(\mathrm{e}\), which an easy calculation shows.
If we use a large \(B\), on the one hand, the running time/memory usage will be faster/lesser by a factor \(\log_B(Q)/\ln(Q) = 1/\ln(B)\) than in the error\sphinxhyphen{}wise optimal case with Euler’s number.
On the other hand, the error size will then be larger by a factor \(B\log_B(Q)/(\mathrm{e}\ln(Q)) = B/(\mathrm{e}\ln(B))\).
Since we will later investigate techniques to scale down an error more efficiently anyway, the trade\sphinxhyphen{}off of a larger \(B\) and faster computation times etc. is definitely preferable at this point.

\sphinxAtStartPar
Scalar multiplying \(\mathrm{RLWE'}_{Q,s}(m)\) (with an error \(e\)) with \(r \in R_Q\), yields an error of size at most \((B/2) \cdot \log_B(Q) \cdot \norm{e} \cdot \delta_R^{(')}\).

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large RGSW ciphertexts}
\end{DUlineblock}

\sphinxAtStartPar
The notion of a RGSW (name and idea originate from {[}\hyperlink{cite.Thesis:id73}{Gentry \sphinxstyleemphasis{et al.}, 2013}{]}) ciphertext adds another layer of complexity.
Namely, it consists of RLWE’ encryptions of both \(s \cdot m\) and \(m\), where \(s\) is the secret key.
The scaling with \(s\) is necessary, if we extend the idea behind \(\texttt{rlwe-x-scalar-multiply}\) to a multiplication with a RLWE ciphertext (and not just a ring element).
This will enable us to define something like \(\mathrm{RLWE}(m_1) \circledast \mathrm{RGSW}(m_2) \approx \mathrm{RLWE}(m_1m_2)\), because if \(\mathrm{RLWE}(m_1) = (a,b)\), then \(as+b = e_1 + m_1\) can be computed without knowledge of \(m_1\) by implicitly transferring the multiplication with \(s\) to \(\mathrm{RGSW}(m_2)\).

\sphinxAtStartPar
We save the details on the \(\texttt{star-multiplication}\) \(\circledast\) for later and define:
\begin{equation*}
\begin{split}\mathrm{RGSW}_{Q,s}(m) := (\mathrm{RLWE'}_{Q,s}(s\cdot m), \mathrm{RLWE'}_{Q,s}(m)) \in R_Q^{2(l+1)}.\end{split}
\end{equation*}
\sphinxAtStartPar
Note that given \(\RLWEx(m)\), one does not explicitly need \(s\) for obtaining \(\RLWEx(s \cdot m)\), because it holds that:
\begin{equation*}
\begin{split}\RLWE(s \cdot B^i \cdot m) = \RLWE(0) + (B^i \cdot m, 0).\end{split}
\end{equation*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{rgsw\PYGZus{}encryption}\PYG{p}{(}\PYG{n}{message}\PYG{p}{,} \PYG{n}{ciphertext\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{B}\PYG{p}{,} \PYG{n}{standard\PYGZus{}deviation}\PYG{p}{,} \PYG{n}{secret\PYGZus{}key}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{m}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{s}\PYG{p}{,} \PYG{n}{STD} \PYG{o}{=} \PYG{n}{message}\PYG{p}{,} \PYG{n}{ciphertext\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{secret\PYGZus{}key}\PYG{p}{,} \PYG{n}{standard\PYGZus{}deviation}
    \PYG{k}{return} \PYG{p}{[}\PYG{n}{rlwe\PYGZus{}x\PYGZus{}encryption}\PYG{p}{(}\PYG{n}{m}\PYG{o}{.}\PYG{n}{multiply}\PYG{p}{(}\PYG{n}{s}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{B}\PYG{p}{,} \PYG{n}{STD}\PYG{p}{,} \PYG{n}{s}\PYG{p}{)}\PYG{p}{,} \PYG{n}{rlwe\PYGZus{}x\PYGZus{}encryption}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{B}\PYG{p}{,} \PYG{n}{STD}\PYG{p}{,} \PYG{n}{s}\PYG{p}{)}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Operations on RGSW ciphertexts}
\end{DUlineblock}

\sphinxAtStartPar
Again, we start with the straightforward component\sphinxhyphen{}wise addition \(\texttt{rgsw-add}\) to obtain \(\RGSW(m_1+m_2)\) from \(\RGSW(m_1)\) and \(\RGSW(m_2)\).
Since a \(\RGSW\) ciphertext builds on \(\RLWEx\) ciphertexts, which themself build on \(\RLWE\) ciphertext, we apply \(\texttt{rlwe-add}\) in the bottom level to obtain the desired result.
The error analysis is identical to the one in \(\texttt{rlwe-add}\).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{rgsw\PYGZus{}add}\PYG{p}{(}\PYG{n}{rgsw1}\PYG{p}{,} \PYG{n}{rgsw2}\PYG{p}{,} \PYG{n}{ciphertext\PYGZus{}modulus} \PYG{o}{=} \PYG{k+kc}{None}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{l} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{rgsw1}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{result} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{l}\PYG{p}{)}\PYG{p}{]} \PYG{p}{,} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{l}\PYG{p}{)}\PYG{p}{]}\PYG{p}{]}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{l}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{result}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n}{rlwe\PYGZus{}add}\PYG{p}{(}\PYG{n}{rgsw1}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,} \PYG{n}{rgsw2}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ciphertext\PYGZus{}modulus}\PYG{p}{)}             
    \PYG{k}{return} \PYG{n}{result}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
In the above fashion of RLWE ciphertexts, we can extend the component\sphinxhyphen{}wise multiplication with a specific polynomial \(r \in R_Q\) to RGSW ciphertexts.
Needless to say, the same error discussion as in \(\texttt{rlwe-multiply-with-poly}\) applies:
It is mandatory that we only multiply with a \(r\) of small size, otherwise, we will decrypt the result wrongly (below indicated by \(\leadsto\)).

\sphinxAtStartPar
More formally we have:
\begin{equation*}
\begin{split}\begin{split}
\texttt{rgsw-multiply-with-poly}: \mathrm{RGSW}_{Q,s} \times R_Q &\longrightarrow \mathrm{RGSW}_{Q,s}, \\
(\mathrm{RGSW}_{Q,s}(m), r) &\leadsto \mathrm{RGSW}_{Q,s}(r\cdot m)
\end{split}\end{split}
\end{equation*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{rgsw\PYGZus{}multiply\PYGZus{}with\PYGZus{}poly}\PYG{p}{(}\PYG{n}{rgsw}\PYG{p}{,} \PYG{n}{poly}\PYG{p}{,} \PYG{n}{ciphertext\PYGZus{}modulus}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{l} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{rgsw}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{result} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{l}\PYG{p}{)}\PYG{p}{]} \PYG{p}{,} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{l}\PYG{p}{)}\PYG{p}{]}\PYG{p}{]}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{l}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{result}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n}{rlwe\PYGZus{}multiply\PYGZus{}with\PYGZus{}poly}\PYG{p}{(}\PYG{n}{rgsw}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,} \PYG{n}{poly}\PYG{p}{,} \PYG{n}{ciphertext\PYGZus{}modulus}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{result}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large The star multiplication}
\end{DUlineblock}

\sphinxAtStartPar
The star multiplication \(\circledast\) can be seen as the most central auxiliary operation of the bootstrapping scheme.
It effectively minimizes the error growth when multiplying a particular kind of ciphertext (a RGSW\sphinxhyphen{}encrypted monomial) by exploiting the structure of RLWE’ ciphertexts.
Unlike BFV multiplication (see {\hyperref[\detokenize{Thesis:error-after-BFV-multiplication}]{\sphinxcrossref{Theorem 6}}}), the error after \(\circledast\) directly depends on the size of a message belonging to (only) one factor.

\sphinxAtStartPar
As a description of \(\circledast\) we have:
\begin{equation*}
\begin{split}\begin{split}
\texttt{star-multiplication} = \circledast: \mathrm{RLWE}_{Q,s} \times \mathrm{RGSW}_{Q,s} &\longrightarrow \mathrm{RLWE}_{Q,s}, \\ (\mathrm{RLWE}_{Q,s}(m_1), \mathrm{RGSW}_{Q,s}(m_2)) &\leadsto \mathrm{RLWE}_{Q,s}(m_1\cdot m_2+e_1m_2)
\end{split}\end{split}
\end{equation*}
\sphinxAtStartPar
The above shows what the result is rather than how it is actually defined.
Unfolding the components gives rise to the definition:
\begin{equation*}
\begin{split}\begin{split}
\underbrace{\mathrm{RLWE}_{Q,s}(m_1)}_{=: (a,b)} \circledast \mathrm{RGSW}_{Q,s}(m_2) &:= a \odot \mathrm{RLWE'}_{Q,s}(s\cdot m_2) + b \odot \mathrm{RLWE'}_{Q,s}(m_2) \\
&= \mathrm{RLWE}_{Q,s}((a\cdot s +b)m_2) \\
&= \mathrm{RLWE}_{Q,s}(m_1\cdot m_2+e_1m_2).
\end{split}\end{split}
\end{equation*}
\sphinxAtStartPar
Here we have implicitly applied the auxiliary functions \(\odot\) and \(\texttt{rlwe-add}\) from above and we have used that \(a \cdot s + b = m_1 + e_1\).
Finally, it becomes clear, why we originally needed the concept of RGSW ciphertexts (i.e. the additional multiplication with \(s\)).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{star\PYGZus{}multiplication}\PYG{p}{(}\PYG{n}{rlwe}\PYG{p}{,} \PYG{n}{rgsw}\PYG{p}{,} \PYG{n}{ciphertext\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{B}\PYG{p}{)}\PYG{p}{:} 
    \PYG{n}{summand1} \PYG{o}{=} \PYG{n}{rlwe\PYGZus{}x\PYGZus{}scalar\PYGZus{}multiply}\PYG{p}{(}\PYG{n}{rlwe}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{rgsw}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ciphertext\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{B}\PYG{p}{)}
    \PYG{n}{summand2} \PYG{o}{=} \PYG{n}{rlwe\PYGZus{}x\PYGZus{}scalar\PYGZus{}multiply}\PYG{p}{(}\PYG{n}{rlwe}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{rgsw}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ciphertext\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{B}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{rlwe\PYGZus{}add}\PYG{p}{(}\PYG{n}{summand1}\PYG{p}{,} \PYG{n}{summand2}\PYG{p}{,} \PYG{n}{ciphertext\PYGZus{}modulus}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
The error analysis is simple:
\label{Thesis:error-after-star-multiplication}
\begin{sphinxadmonition}{note}{Lemma 7 (Error after \protect\(\texttt{star-multiplication}\protect\))}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}
\sphinxAtStartPar
Proof. The result after \(\circledast\) is an encryption of \(m_1m_2\) altered by \(e_1m_2\), thus \(\norm{e_1m_2}\) is the estimation.
Now, following {\hyperref[\detokenize{Thesis:error-after-rlwe-x-scalar-multiply}]{\sphinxcrossref{Lemma 6}}}, both components from \(\RLWE(m_1)\) can be treated as \(\mathcal U(R_Q)\) samples due to {\hyperref[\detokenize{Thesis:decision-RLWE}]{\sphinxcrossref{Definition 3}}}.
Together with the assumption that \(e_2\) (i.e. its coefficients) is distributed with mean zero (see {\hyperref[\detokenize{Thesis:conclusion-on-delta-r}]{\sphinxcrossref{\DUrole{std,std-ref}{Conclusion on the expansion factor}}}}), we can select \(\delta_R = \sqrt{N}\) in {\hyperref[\detokenize{Thesis:error-after-rlwe-x-scalar-multiply}]{\sphinxcrossref{Lemma 6}}}.
Since we add two RLWE ciphertexts at the end, the claim follows.
\end{sphinxadmonition}

\sphinxAtStartPar
Notice that \(\norm{e_1m_2} \le N \norm{e_1}\norm{m_2}\) in the worst case, since \(m_2\) could be arbitrary.
However, we will only use monomials as \(m_2\) in our algorithm, such that \(\norm{e_1m_2} = \norm{e_1}\) holds.

\sphinxAtStartPar
We can extend the star multiplication from RLWE to RLWE’ ciphertexts by again applying it component\sphinxhyphen{}wise.
Using the same notation out of comfort, the map is:
\begin{equation*}
\begin{split}\begin{split}
\texttt{star-x-multiplication} = \circledast: \mathrm{RLWE'}_{Q,s} \times \mathrm{RGSW}_{Q,s} &\longrightarrow \mathrm{RLWE'}_{Q,s}, \\ (\mathrm{RLWE'}_{Q,s}(m_1), \mathrm{RGSW}_{Q,s}(m_2)) &\leadsto \mathrm{RLWE'}_{Q,s}(m_1\cdot m_2+e_1m_2)
\end{split}\end{split}
\end{equation*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{star\PYGZus{}x\PYGZus{}multiplication}\PYG{p}{(}\PYG{n}{rlwe\PYGZus{}x}\PYG{p}{,} \PYG{n}{rgsw}\PYG{p}{,} \PYG{n}{modulus}\PYG{p}{,} \PYG{n}{B}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{p}{[}\PYG{n}{star\PYGZus{}multiplication}\PYG{p}{(}\PYG{n}{rlwe\PYGZus{}x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{rgsw}\PYG{p}{,} \PYG{n}{modulus}\PYG{p}{,} \PYG{n}{B}\PYG{p}{)} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{rlwe\PYGZus{}x}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Technically, the \(\texttt{star-x-multiplication}\) can now be extended even to a multiplication of two RGSW ciphertexts, as suggested in Section 2 of {[}\hyperlink{cite.Thesis:id74}{Micciancio and Polyakov, 2020}{]}.
Although we will not use it, if one needs a RGSW encryption of the result of \(\circledast\), the \(\diamondsuit\) operation may be useful:
\begin{equation*}
\begin{split}\diamondsuit: \RGSW \times \RGSW \longrightarrow \RGSW, \qquad ((c_1,c_2),C) \longmapsto (c_1 \circledast C, c_2 \circledast C).\end{split}
\end{equation*}\phantomsection\label{\detokenize{Thesis:automorphisms-of-r}}
\sphinxAtStartPar
The error size after \(\RLWE_{Q,s}(m_1) \circledast \RGSW_{Q,s}(m_2)\) is approximately bounded by \(B \cdot \log_B(Q) \cdot \norm {e_2} \cdot \sqrt{N} + \norm{e_1m_2}\).

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{Automorphisms of \(R\)}
\end{DUlineblock}

\sphinxAtStartPar
Before getting to bootstrapping, we need two more auxiliary operations.
The first one is an automorphism evaluation on elements of \(R\) and thus on RLWE ciphertexts, too.
It is a well\sphinxhyphen{}known fact that there are exactly \(N\) automorphisms of \(R\), namely \(\psi_i\) for each coprime \(i \perp 2N\) (recall that \(N\) is a power to two), and they can be denoted by:
\begin{equation*}
\begin{split}\psi_i : R \longrightarrow R,  \qquad a(x) \longmapsto a(x^i), \qquad i \in \{1,3,5,\dots,2N-1\}.\end{split}
\end{equation*}
\sphinxAtStartPar
If we apply \(\psi_i\) to a RLWE ciphertext \((a(x), b(x))\), we obtain the ciphertext \((a(x^i), b(x^i))\), which, though it technically encrypts \(m(x^i)\), it unfortunately uses \(s(x^i)\) as a secret key.
We will get rid of this complication by introducing the \(\texttt{key-switch}\) procedure.
Further notice that the application of \(\psi_i\) to a ciphertext preserves the error size since \(\norm{e(x^i)} = \norm{e(x)}\).

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Key switching}
\end{DUlineblock}

\sphinxAtStartPar
The objective of this section is to enable the bootstrapping party to execute all \(N\) automorphisms (without knowledge of \(s\)).
To begin with, we mention that for this step we will need the \(s(x^i)\) as pre\sphinxhyphen{}computed information.
Obviously, we need to encrypt \(s(x^i)\), thus the following function comes in handy.
It is run by a secret\sphinxhyphen{}key holder, sent to the bootstrapping party in advance of bootstrapping, and involves RLWE’ encryptions (to control the error growth for \(\texttt{key-switch}\) later):
\begin{equation*}
\begin{split}\texttt{key-switch-for-eval-auto}: (\mathrm{RLWE'}_{Q,s}(s(x^i)))_{i\in \{1,3,\dots,2N-1\}}.\end{split}
\end{equation*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{key\PYGZus{}switch\PYGZus{}for\PYGZus{}eval\PYGZus{}auto}\PYG{p}{(}\PYG{n}{secret\PYGZus{}key}\PYG{p}{,} \PYG{n}{ciphertext\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{B}\PYG{p}{,} \PYG{n}{standard\PYGZus{}deviation}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{s}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{STD}\PYG{p}{,} \PYG{n}{N} \PYG{o}{=} \PYG{n}{secret\PYGZus{}key}\PYG{p}{,} \PYG{n}{ciphertext\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{standard\PYGZus{}deviation}\PYG{p}{,} \PYG{n+nb}{getattr}\PYG{p}{(}\PYG{n}{secret\PYGZus{}key}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ring\PYGZus{}degree}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{k}{return} \PYG{p}{[}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{n}{rlwe\PYGZus{}x\PYGZus{}encryption}\PYG{p}{(}\PYG{n}{s}\PYG{o}{.}\PYG{n}{variable\PYGZus{}powering}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{B}\PYG{p}{,} \PYG{n}{STD}\PYG{p}{,} \PYG{n}{s}\PYG{p}{)}\PYG{p}{]} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{N}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Now, the procedure \(\texttt{key-switch}\) below will actually perform the key switching from a secret key \(s_1\) to another secret key \(s_2\).
So, starting from a ciphertext \(\mathrm{RLWE}_{Q,s_1}(m) =: (a,b)\), it outputs \(\mathrm{RLWE}_{Q,s_2}(m)\) plus a key\sphinxhyphen{}switching error \(e_{\text{key-switch}}\).
The defining calculation:
\begin{equation*}
\begin{split}\begin{split}
\texttt{key-switch}: \mathrm{RLWE}_{s_2}(m) &:= a \odot \mathrm{RLWE'}_{s_2}(s_1) + (0,b) \\
&= \mathrm{RLWE}_{s_2}(a\cdot s_1) + \mathrm{RLWE}_{s_2}^0(b) \\
&= \mathrm{RLWE}_{s_2}(a\cdot s_1 + b) 
\\ &= \mathrm{RLWE}_{s_2}(m+e_{\text{key-switch}})
\end{split}\end{split}
\end{equation*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{key\PYGZus{}switch}\PYG{p}{(}\PYG{n}{rlwe}\PYG{p}{,} \PYG{n}{ciphertext\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{B}\PYG{p}{,} \PYG{n}{key\PYGZus{}switch\PYGZus{}rlwe\PYGZus{}x}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{ks} \PYG{o}{=} \PYG{n}{rlwe}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{rlwe}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ciphertext\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{key\PYGZus{}switch\PYGZus{}rlwe\PYGZus{}x}
    \PYG{n}{zero} \PYG{o}{=} \PYG{n}{generate\PYGZus{}zero\PYGZus{}poly}\PYG{p}{(}\PYG{n+nb}{getattr}\PYG{p}{(}\PYG{n}{b}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ring\PYGZus{}degree}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{rlwe\PYGZus{}add}\PYG{p}{(}\PYG{n}{rlwe\PYGZus{}x\PYGZus{}scalar\PYGZus{}multiply}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{ks}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{B}\PYG{p}{)}\PYG{p}{,} \PYG{p}{[}\PYG{n}{zero}\PYG{p}{,} \PYG{n}{b}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
By construction, \(\texttt{key-switch}\) yields the exact same error as in \(\texttt{rlwe-x-scalar-multiply}\) (see {\hyperref[\detokenize{Thesis:error-after-rlwe-x-scalar-multiply}]{\sphinxcrossref{Lemma 6}}}).
That means an error of size at most \((B/2) \cdot \log_B(Q) \cdot \norm e \cdot \sqrt{N}\), since \(\delta_R' = \sqrt{N}\) in the lemma, because \(a\) is uniformly at random (see {\hyperref[\detokenize{Thesis:conclusion-on-delta-r}]{\sphinxcrossref{\DUrole{std,std-ref}{Conclusion on the expansion factor}}}}).
Note that here \(e\) stands for a RLWE encryption error, independent of the error inside \(\RLWE_{s_2}(m)\).

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Evaluating automorphism}
\end{DUlineblock}

\sphinxAtStartPar
We are now able to evaluate \(\psi_t\) for an arbitrary \(t\perp 2N\) on a RLWE ciphertext, since we can change the secret key from \(s(x^i)\) to \(s\) again after applying \(\psi_t\).
The function below transforms \(\mathrm{RLWE}_{Q,s}(m(x))\) into \(\mathrm{RLWE}_{Q,s}(m(x^t))\) by using \(\texttt{key-switch}\) after \(t\)\sphinxhyphen{}powering the polynomial variable \(x\).

\sphinxAtStartPar
Remark on the code:
We highlight the pre\sphinxhyphen{}computational part by storing \(t\) right along with the RLWE’ encryption of \(s(x^t)\) (instead of accessing it directly) since this information will get transmitted by the holder of \(s\).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{eval\PYGZus{}auto}\PYG{p}{(}\PYG{n}{rlwe}\PYG{p}{,} \PYG{n}{t}\PYG{p}{,} \PYG{n}{ciphertext\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{B}\PYG{p}{,} \PYG{n}{key\PYGZus{}switch\PYGZus{}array}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{N}\PYG{p}{,} \PYG{n}{Q} \PYG{o}{=} \PYG{n}{rlwe}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{rlwe}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n+nb}{getattr}\PYG{p}{(}\PYG{n}{rlwe}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ring\PYGZus{}degree}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{ciphertext\PYGZus{}modulus}
    \PYG{n}{eval\PYGZus{}a}\PYG{p}{,} \PYG{n}{eval\PYGZus{}b} \PYG{o}{=} \PYG{n}{a}\PYG{o}{.}\PYG{n}{variable\PYGZus{}powering}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{o}{.}\PYG{n}{mod}\PYG{p}{(}\PYG{n}{Q}\PYG{p}{)}\PYG{p}{,} \PYG{n}{b}\PYG{o}{.}\PYG{n}{variable\PYGZus{}powering}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{o}{.}\PYG{n}{mod}\PYG{p}{(}\PYG{n}{Q}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{key\PYGZus{}switch\PYGZus{}array}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{key\PYGZus{}switch\PYGZus{}array}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{==} \PYG{p}{(}\PYG{n}{t} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{N}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{return} \PYG{n}{key\PYGZus{}switch}\PYG{p}{(}\PYG{p}{[}\PYG{n}{eval\PYGZus{}a}\PYG{p}{,} \PYG{n}{eval\PYGZus{}b}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{B}\PYG{p}{,} \PYG{n}{key\PYGZus{}switch\PYGZus{}array}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Clearly, the error during an automorphism evaluation is precisely equal to the error of \(\texttt{key-switch}\).

\sphinxAtStartPar
As a demonstration, we apply the transformation \(x \longmapsto x^3\) for a randomly selected message.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{B} \PYG{o}{=} \PYG{l+m+mi}{8}  \PYG{c+c1}{\PYGZsh{} example selection}
\PYG{n}{key\PYGZus{}switch\PYGZus{}array} \PYG{o}{=} \PYG{n}{key\PYGZus{}switch\PYGZus{}for\PYGZus{}eval\PYGZus{}auto}\PYG{p}{(}\PYG{n}{SK}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{B}\PYG{p}{,} \PYG{n}{STD}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} precomputation}

\PYG{n}{Random\PYGZus{}Poly} \PYG{o}{=} \PYG{n}{print\PYGZus{}and\PYGZus{}return}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Message}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{generate\PYGZus{}uniform\PYGZus{}distribution}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{T}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{Random\PYGZus{}Poly\PYGZus{}Enc} \PYG{o}{=} \PYG{n}{encrypt}\PYG{p}{(}\PYG{n}{Random\PYGZus{}Poly}\PYG{p}{,} \PYG{n}{T}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{STD}\PYG{p}{,} \PYG{n}{PK}\PYG{p}{)}
\PYG{n}{Morphed} \PYG{o}{=} \PYG{n}{eval\PYGZus{}auto}\PYG{p}{(}\PYG{n}{Random\PYGZus{}Poly\PYGZus{}Enc}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{B}\PYG{p}{,} \PYG{n}{key\PYGZus{}switch\PYGZus{}array}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Message after eval\PYGZhy{}auto: x \PYGZhy{}\PYGZhy{}\PYGZgt{} x\PYGZca{}3: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{decrypt}\PYG{p}{(}\PYG{n}{Morphed}\PYG{p}{,} \PYG{n}{T}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{SK}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Note that x\PYGZca{}(}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{two\PYGZus{}power}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{) = \PYGZhy{}1 and coefficients are mod }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{two\PYGZus{}power}\PYG{p}{(}\PYG{n}{T}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{KS\PYGZus{}error} \PYG{o}{=} \PYG{n}{Morphed}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{multiply}\PYG{p}{(}\PYG{n}{SK}\PYG{p}{)}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{Morphed}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{subtract}\PYG{p}{(}\PYG{n}{Random\PYGZus{}Poly}\PYG{o}{.}\PYG{n}{variable\PYGZus{}powering}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{o}{.}\PYG{n}{scalar\PYGZus{}multiply}\PYG{p}{(}\PYG{n}{Q}\PYG{o}{/}\PYG{o}{/}\PYG{n}{T}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Error size after key switching: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{KS\PYGZus{}error}\PYG{o}{.}\PYG{n}{mod\PYGZus{}small}\PYG{p}{(}\PYG{n}{Q}\PYG{p}{)}\PYG{o}{.}\PYG{n}{norm}\PYG{p}{(}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Factor from error bound: (B/2) * log\PYGZus{}B(Q) * sqrt(N) = }\PYG{l+s+si}{\PYGZob{}}\PYG{p}{(}\PYG{n}{B}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{*}\PYG{n}{log}\PYG{p}{(}\PYG{n}{Q}\PYG{p}{,}\PYG{n}{B}\PYG{p}{)} \PYG{o}{*} \PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Message = 3x\PYGZca{}3 + x\PYGZca{}2 + 3x + 2
Message after eval\PYGZhy{}auto: x \PYGZhy{}\PYGZhy{}\PYGZgt{} x\PYGZca{}3: 3x\PYGZca{}3 + 3x\PYGZca{}2 + 3x + 2
Note that x\PYGZca{}(2\PYGZca{}2) = \PYGZhy{}1 and coefficients are mod 2\PYGZca{}2.
Error size after key switching: 37
Factor from error bound: (B/2) * log\PYGZus{}B(Q) * sqrt(N) = 53.333333333333336
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
The code also illustrates the error growth during \(\texttt{key-switch}\).
It prints the factor \((B/2) \log_B(Q) \sqrt{N}\) from {\hyperref[\detokenize{Thesis:error-after-rlwe-x-scalar-multiply}]{\sphinxcrossref{Lemma 6}}}, which gets multiplied with the intrinsic error size from the original encryption.
We observe that the error after key switching is usually much smaller than the bound times at least 1.

\phantomsection\label{\detokenize{Thesis:rescaling}}
\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Rescaling}
\end{DUlineblock}

\sphinxAtStartPar
The last key step, which has already been implicitly employed during the multiplication of BFV ciphertexts, is the rescaling procedure.
Recall how we introduced the auxiliary modulus \(P\) within the relinearization key (see e.g. {\hyperref[\detokenize{Thesis:relinearization-error}]{\sphinxcrossref{Lemma 5}}}).
To sum it up, its main purpose was scaling down a big error to a small one.
The simple way to do that was just to divide both components of a ciphertext by the factor \(P\).
Notice that in this case the hidden message gets divided by \(P\), too.
We had handled this side effect by having multiplied the message by \(P\) beforehand, such that division by \(P\) afterwards just yields the message again.

\sphinxAtStartPar
Now, the same idea can be generalized to RLWE ciphertexts, in which we want to solely scale down the ciphertext modulus while a priori not preserving the encryption of the same message, but a scaled\sphinxhyphen{}down version.
So for powers of two \(q < Q\), we define:
\begin{equation*}
\begin{split}\texttt{rescale}: \mathrm{RLWE}_{Q,s}(m) := (a,b) \longmapsto \left(\round{ \frac{a}{Q/q}} , \round{ \frac{b}{Q/q} } \right)  =: \mathrm{RLWE}_{q,s}\left(\round {\frac{m}{Q/q} }\right).\end{split}
\end{equation*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{rescale}\PYG{p}{(}\PYG{n}{rlwe}\PYG{p}{,} \PYG{n}{old\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{new\PYGZus{}modulus}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{Q}\PYG{p}{,} \PYG{n}{q} \PYG{o}{=} \PYG{n}{old\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{new\PYGZus{}modulus}
    \PYG{k}{return} \PYG{p}{[}\PYG{n}{rlwe}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{rounded\PYGZus{}integer\PYGZus{}divide}\PYG{p}{(}\PYG{n}{q}\PYG{p}{,} \PYG{n}{Q}\PYG{o}{/}\PYG{o}{/}\PYG{n}{q}\PYG{p}{)}\PYG{p}{,} \PYG{n}{rlwe}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{rounded\PYGZus{}integer\PYGZus{}divide}\PYG{p}{(}\PYG{n}{q}\PYG{p}{,} \PYG{n}{Q}\PYG{o}{/}\PYG{o}{/}\PYG{n}{q}\PYG{p}{)}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Remark:
Needless to say, the rounding introduces a rescaling error \(e_{\text{res}}\).
As in the proof of {\hyperref[\detokenize{Thesis:relinearization-error}]{\sphinxcrossref{Lemma 5}}}, we can estimate its size via:
\begin{equation*}
\begin{split}\norm{e_{\text{res}}} = \norm{ \round{ \frac{a}{Q/q}} \cdot s + \round{ \frac{b}{Q/q} } - \round{(as+b)/(Q/q)} } \le \delta_R/2 + 1/2.\end{split}
\end{equation*}
\sphinxAtStartPar
Since we use the estimation \(\delta_R \approx \sqrt{N}\) anyway, we conclude that \(\norm{e_{\text{res}}} \le \sqrt{N}/2\).

\sphinxAtStartPar
Rescaling will later be the last part of the core \(\texttt{scaled-mod}\) procedure and, thus, the total error, which has been accumulated beforehand, can be scaled down appropriately by \(\texttt{rescale}\).

\phantomsection\label{\detokenize{Thesis:bootstrapping}}
\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Bootstrapping}
\end{DUlineblock}

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{The \(\texttt{scaled-mod}\) procedure}
\end{DUlineblock}

\sphinxAtStartPar
The main task during bootstrapping is scaling up a message inside a RLWE ciphertext by a large factor \(\Delta\).
Precisely, we want to transform \(\mathrm{RLWE}_{2N,s}^0(u)\), with \(u\) satisfying \(\norm u < N/2\), into \(\mathrm{RLWE}_{Q,s}(\Delta \cdot u)\).
How this procedure (\(\texttt{scaled-mod}\)) can be used to serve the actual purpose of bootstrapping, i.e. scaling down a big error, will be described afterwards.

\sphinxAtStartPar
The above discussion in {\hyperref[\detokenize{Thesis:preparations-for-bootstrapping}]{\sphinxcrossref{\DUrole{std,std-ref}{Preparations for bootstrapping}}}} of multiplying RLWE ciphertexts and especially {\hyperref[\detokenize{Thesis:error-after-rlwe-x-scalar-multiply}]{\sphinxcrossref{Lemma 6}}} points out that this is a non\sphinxhyphen{}trivial task when using a large \(\Delta\), because of error issues.
Once this has been achieved, the rest of our bootstrapping procedure consists of fitting the BFV encryption scheme towards the \(\texttt{scaled-mod}\) procedure, i.e. how to obtain the ciphertext of \(u\) from a BFV ciphertext and vice versa afterwards.
The name “scaled modulus raising” comes from scaling up by \(\Delta\) and from using a significantly larger modulus \(Q\) during the process to handle error growth.
At this point, we leave questions, e.g. why we initially assume an errorless encryption etc., for later.

\sphinxAtStartPar
\(\texttt{scaled-mod}\) itself, which Section 3 of {[}\hyperlink{cite.Thesis:id72}{Kim \sphinxstyleemphasis{et al.}, 2021}{]} covers, includes three steps:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
The extraction of LWE ciphertexts, where we essentially split up the problem in \(N\) single\sphinxhyphen{}dimensional (LWE) versions.

\item {} 
\sphinxAtStartPar
Blind rotation, where the main transformation towards \(\Delta \cdot u\) is realized.
It is by far the most costly operation.

\item {} 
\sphinxAtStartPar
Repacking, where we reunite our split\sphinxhyphen{}up ciphertexts into a single one, which contains all information.

\end{enumerate}
\phantomsection\label{\detokenize{Thesis:extraction-of-lwe-ciphertexts}}
\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Step 1: Extraction of LWE ciphertexts}
\end{DUlineblock}

\sphinxAtStartPar
In defining LWE ciphertexts, losing the letter ‘R’ ≙ ring leaves us with integers as messages (whereas in RLWE we have \(N\) integers encoded in a polynomial message).
Apart from that, it has a very similar representation:
\begin{equation*}
\begin{split}\mathrm{LWE}_{Q,\vec s}(m) := (\vec a, -\langle \vec a, \vec s\rangle + e + m) \in \mathbb Z_Q^{N+1},\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\vec a, \vec s \in \Z_Q^N\) and \(e, m \in \Z_Q\).
Again, if \(e = 0\), then we will write \(\mathrm{LWE}^0\).

\sphinxAtStartPar
Naturally, the LWE ciphertext security has been thoroughly analysed, as the concept was already existent prior to RLWE.
An extensive survey on this topic can be found in Section 4.2 of {[}\hyperlink{cite.Thesis:id65}{Peikert, 2015}{]}.
Moreover, since RLWE is based on LWE, if we generate LWE ciphertexts from RLWE ciphertexts, all the security measures (as described in {\hyperref[\detokenize{Thesis:security}]{\sphinxcrossref{\DUrole{std,std-ref}{Security}}}}) apply as well.
To preserve these, we write \(\vec s := (s_0,\dots,s_{N-1})\) as the coefficient vector of \(s\) and since the RLWE distributions for \(a,s\) and \(e\) are employed coefficient\sphinxhyphen{}wise, their properties still hold up in the context of the related LWE security.

\sphinxAtStartPar
The goal of the extraction essentially is properly representing the calculation of the linear combinations of the coefficients during a polynomial multiplication in \(R\):
\begin{equation*}
\begin{split}s\cdot a = \left( \sum_{i=0}^{N-1} s_i x^i \right) \left( \sum_{i=0}^{N-1} a_i x^i \right) = \sum_{i=0}^{N-1}\left( \sum_{j=0}^{i} s_j a_{i-j} + \sum_{j=i+1}^{N-1} - s_j a_{i+N-j}\right) x^i =: \sum_{i=0}^{N-1} c_i x^i\end{split}
\end{equation*}
\sphinxAtStartPar
Notice that the minus sign originates from the choice of \(R\), i.e. \(x^N=-1\).
Hence, if we want to create a LWE ciphertext per coefficient \(c_i\) of the above, we define:
\begin{equation*}
\begin{split}\tilde a_i := (a_i,a_{i-1},\dots,a_0,-a_{N-1},-a_{N-2},\dots,-a_{i+1}) \qquad \text{and} \qquad c_i := \langle \tilde a_i, \vec s \rangle = (a \cdot s)_i.\end{split}
\end{equation*}
\sphinxAtStartPar
In total, we receive \(N\) LWE ciphertexts of the form \(\mathrm{LWE}_{2N,\vec s}^0(u_i)\), extracted from the given \(\mathrm{RLWE}_{2N,s}^0(u) = (a,b)\):
\begin{equation*}
\begin{split}\mathrm{LWE}_{2N,\vec s}^0(u_i) := (\tilde{a}_i, b_i) \qquad \text{with} \qquad \langle \tilde a_i, \vec s \rangle + b_i = u_i.\end{split}
\end{equation*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{extraction}\PYG{p}{(}\PYG{n}{rlwe}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{a\PYGZus{}coeffs}\PYG{p}{,} \PYG{n}{b\PYGZus{}coeffs}\PYG{p}{,} \PYG{n}{N} \PYG{o}{=} \PYG{n+nb}{getattr}\PYG{p}{(}\PYG{n}{rlwe}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{coeffs}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{getattr}\PYG{p}{(}\PYG{n}{rlwe}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{coeffs}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{getattr}\PYG{p}{(}\PYG{n}{rlwe}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ring\PYGZus{}degree}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{a\PYGZus{}rotation} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0} \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{]} \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{]}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{a\PYGZus{}rotation}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n}{a\PYGZus{}coeffs}\PYG{p}{[}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{n}{j}\PYG{p}{]}
        \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{a\PYGZus{}rotation}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{a\PYGZus{}coeffs}\PYG{p}{[}\PYG{n}{N} \PYG{o}{+} \PYG{n}{i} \PYG{o}{\PYGZhy{}} \PYG{n}{j}\PYG{p}{]}
    \PYG{k}{return} \PYG{p}{[}\PYG{p}{[}\PYG{n}{mod}\PYG{p}{(}\PYG{n}{a\PYGZus{}rotation}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{N}\PYG{p}{)}\PYG{p}{,} \PYG{n}{mod}\PYG{p}{(}\PYG{n}{b\PYGZus{}coeffs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{N}\PYG{p}{)}\PYG{p}{]} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}\phantomsection\label{\detokenize{Thesis:blind-rotation}}
\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Step 2: Blind rotation}
\end{DUlineblock}

\sphinxAtStartPar
Starting from an extracted \(\mathrm{LWE}_{2N,\vec s}^0(u) := (\vec \alpha, \beta)\) ciphertext, we want to obtain a RLWE encryption of \(\Delta \cdot u\) by using the techniques of {\hyperref[\detokenize{Thesis:preparations-for-bootstrapping}]{\sphinxcrossref{\DUrole{std,std-ref}{Preparations for bootstrapping}}}} to handle the error growth.
Recall that here \(u\) is an integer, thus \(\Delta \cdot u\) is as well, and therefore we have plenty of liberty in choosing the polynomial RLWE message, apart from the desired constant coefficient \(\Delta \cdot u\).
On the other hand, we will also need this liberty, because we have no knowledge of what exactly \(u\) is, just knowledge of the size estimation \(\abs u \le N/2\).

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Rotation function}
\end{DUlineblock}

\sphinxAtStartPar
The above observation leads to the notion of the blind rotation function \(f\), which prepares the right scaling with \(\Delta\) at all possible coefficients of a RLWE message polynomial.

\sphinxAtStartPar
We define:
\begin{equation*}
\begin{split}f := \sum_{j=-c}^c -\Delta\cdot j \cdot x^j \in R, \qquad \text{ where } \abs u \le c < N/2.\end{split}
\end{equation*}
\sphinxAtStartPar
We will provide the details of \(c\) later on (see \eqref{equation:Thesis:norm-u}).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{initialize\PYGZus{}rotation\PYGZus{}function}\PYG{p}{(}\PYG{n}{key\PYGZus{}size}\PYG{p}{,} \PYG{n}{Delta}\PYG{p}{,} \PYG{n}{c\PYGZus{}boundary}\PYG{p}{,} \PYG{n}{ciphertext\PYGZus{}modulus}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{function\PYGZus{}coeffs} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0} \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{key\PYGZus{}size}\PYG{p}{)}\PYG{p}{]}
    \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{c\PYGZus{}boundary} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{function\PYGZus{}coeffs}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{j}\PYG{o}{*}\PYG{n}{Delta}
    \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{c\PYGZus{}boundary} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{function\PYGZus{}coeffs}\PYG{p}{[}\PYG{n}{key\PYGZus{}size} \PYG{o}{\PYGZhy{}} \PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{j}\PYG{o}{*}\PYG{n}{Delta}
    \PYG{k}{return} \PYG{n}{Poly}\PYG{p}{(}\PYG{n}{key\PYGZus{}size}\PYG{p}{,} \PYG{n}{function\PYGZus{}coeffs}\PYG{p}{)}\PYG{o}{.}\PYG{n}{mod}\PYG{p}{(}\PYG{n}{ciphertext\PYGZus{}modulus}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
This now allows us, regardless of the special value of \(u\), to have that \((f\cdot x^u)(0) = \Delta \cdot u\) (here we have used \(\abs u \le c < N/2\) and thus \(\mathrm{deg}(f\cdot x^u) < N\)) as an easy calculation shows.
Note that at this point the LWE extraction serves its purpose, since \(u\) as an integer can be selected as an exponent of \(x\) (contrary to a polynomial message).
Moving \(u\) to the exponent, instead of e.g. multiplying it directly with \(\Delta\), yields a notably smaller error.
Recall, that it was already briefly mentioned beforehand (see \eqref{equation:Thesis:rlwe-multiply-error-growth}) that monomials can be cheaply multiplied with ciphertexts (in terms of error growth) compared to e.g. constants.
We make use of that, but \(x^u\) still does not suffice, because it is unknown, hence we have to perform monomial multiplication \(N\) times:
\begin{equation*}
\begin{split}x^u = x^\beta \cdot x^{\alpha_0 s_0} \cdots x^{\alpha_{N-1} s_{N-1}}, \qquad \text{since } u = \beta + \langle \vec \alpha, \vec s \rangle.\end{split}
\end{equation*}
\sphinxAtStartPar
Here we utilized the properties of a LWE ciphertext.

\sphinxAtStartPar
Finally, we need to consider:
It is inevitable for a secret key holder to do some precomputation, which on the one hand, encrypts the secret key bits \(s_i\) one\sphinxhyphen{}by\sphinxhyphen{}one, and is, on the other hand, compatible with exponent multiplication, i.e. for later obtaining \(x^{\alpha_i s_i}\).
RGSW ciphertexts solve both issues.

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Blind rotation keys}
\end{DUlineblock}

\sphinxAtStartPar
We hide the information about the bits of our ternary secret key \(s\) in a stack of \(2N\) RGSW ciphertexts.
First of all, a coefficient \(s_i \in \{-1,0,1\}\) gets separated into its positive and its negative part.
So we define:
\begin{equation*}
\begin{split}s_i^+ = 1 :\iff s_i = 1, \qquad s_i^- = 1 :\iff s_i = -1.\end{split}
\end{equation*}
\sphinxAtStartPar
Otherwise \(s_i^+\) respectively \(s_i^-\) is set to \(0\).
Now we define the blind rotation keys computed by a secret key holder in advance as:
\begin{equation*}
\begin{split}\texttt{blind-rotation-keys}: (\mathrm{RGSW}_{Q,s}(s_i^+), \mathrm{RGSW}_{Q,s}(s_i^-))_{i \in \{0,\dots,N-1\}}.\end{split}
\end{equation*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{blind\PYGZus{}rotation\PYGZus{}keys}\PYG{p}{(}\PYG{n}{ciphertext\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{B}\PYG{p}{,} \PYG{n}{standard\PYGZus{}deviation}\PYG{p}{,} \PYG{n}{secret\PYGZus{}key}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{Q}\PYG{p}{,} \PYG{n}{s}\PYG{p}{,} \PYG{n}{STD}\PYG{p}{,} \PYG{n}{N} \PYG{o}{=} \PYG{n}{ciphertext\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{secret\PYGZus{}key}\PYG{p}{,} \PYG{n}{standard\PYGZus{}deviation}\PYG{p}{,} \PYG{n+nb}{getattr}\PYG{p}{(}\PYG{n}{secret\PYGZus{}key}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ring\PYGZus{}degree}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{s\PYGZus{}coeffs}\PYG{p}{,} \PYG{n}{zeropoly}\PYG{p}{,} \PYG{n}{onepoly} \PYG{o}{=} \PYG{n+nb}{getattr}\PYG{p}{(}\PYG{n}{s}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{coeffs}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{generate\PYGZus{}zero\PYGZus{}poly}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{,} \PYG{n}{generate\PYGZus{}one\PYGZus{}poly}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}
    \PYG{n}{brk} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{]}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{s\PYGZus{}coeffs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{==} \PYG{l+m+mi}{1}\PYG{p}{:}
            \PYG{n}{brk}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{rgsw\PYGZus{}encryption}\PYG{p}{(}\PYG{n}{onepoly}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{B}\PYG{p}{,} \PYG{n}{STD}\PYG{p}{,} \PYG{n}{s}\PYG{p}{)}
        \PYG{k}{else}\PYG{p}{:}
            \PYG{n}{brk}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{rgsw\PYGZus{}encryption}\PYG{p}{(}\PYG{n}{zeropoly}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{B}\PYG{p}{,} \PYG{n}{STD}\PYG{p}{,} \PYG{n}{s}\PYG{p}{)}
        \PYG{k}{if} \PYG{n}{s\PYGZus{}coeffs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{==} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{:}
            \PYG{n}{brk}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{rgsw\PYGZus{}encryption}\PYG{p}{(}\PYG{n}{onepoly}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{B}\PYG{p}{,} \PYG{n}{STD}\PYG{p}{,} \PYG{n}{s}\PYG{p}{)}
        \PYG{k}{else}\PYG{p}{:}
            \PYG{n}{brk}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{rgsw\PYGZus{}encryption}\PYG{p}{(}\PYG{n}{zeropoly}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{B}\PYG{p}{,} \PYG{n}{STD}\PYG{p}{,} \PYG{n}{s}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{brk}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Blind rotation algorithm}
\end{DUlineblock}

\sphinxAtStartPar
The last missing piece is a trivial (i.e. error\sphinxhyphen{}free and not using the secret key \(s\)) RGSW encryption of \(1\).
We need it such that the following equation holds:
\begin{equation*}
\begin{split}\mathrm{RGSW}_{Q,s}(x^{\alpha_i s_i}) = \mathrm{RGSW}_{Q,s}^0(1) + (x^{\alpha_i}-1)\cdot \mathrm{RGSW}_{Q,s}(s_i^+) + (x^{-\alpha_i}-1)\cdot \mathrm{RGSW}_{Q,s}(s_i^-)\end{split}
\end{equation*}
\sphinxAtStartPar
Recall that either \(s_i^+\) or \(s_i^-\) is zero.
In this case, the corresponding summand is equal to \(\mathrm{RGSW}_{Q,s}(0)\).
Because RGSW errors behave favorably during additions, we merge everything into the result while only performing two \(\texttt{rgsw-multiply-with-poly}\) operations with a polynomial \((x^{\pm \alpha_i}-1)\) which is still almost as optimal as a monomial (see below \eqref{equation:Thesis:rlwe-multiply-error-growth}).

\sphinxAtStartPar
We realize the trivial RGSW encryption of \(1\) as follows:
\begin{equation*}
\begin{split}\RGSW_{Q,s}^0(1) = (\RLWEx_{Q,s}^0(s), \mathrm{RLWE'}_{Q,s}^0(1)) := ((B^i,0)_{i\in \{0,\dots,l-1\}}, (0,B^i)_{i\in \{0,\dots,l-1\}})\end{split}
\end{equation*}
\sphinxAtStartPar
with \(l = \lceil \log_B(Q) \rceil\).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{get\PYGZus{}trivial\PYGZus{}rgsw\PYGZus{}of\PYGZus{}one}\PYG{p}{(}\PYG{n}{ciphertext\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{B}\PYG{p}{,} \PYG{n}{key\PYGZus{}size}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{g} \PYG{o}{=} \PYG{p}{[}\PYG{n}{generate\PYGZus{}constant\PYGZus{}poly}\PYG{p}{(}\PYG{n}{key\PYGZus{}size}\PYG{p}{,} \PYG{n}{B} \PYG{o}{*}\PYG{o}{*} \PYG{n}{i}\PYG{p}{)} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{ceil}\PYG{p}{(}\PYG{n}{log}\PYG{p}{(}\PYG{n}{ciphertext\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{B}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]}
    \PYG{n}{zero} \PYG{o}{=} \PYG{n}{generate\PYGZus{}zero\PYGZus{}poly}\PYG{p}{(}\PYG{n}{key\PYGZus{}size}\PYG{p}{)}
    \PYG{k}{return} \PYG{p}{[}\PYG{p}{[}\PYG{p}{[}\PYG{n}{g}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{zero}\PYG{p}{]} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{g}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{p}{[}\PYG{n}{zero}\PYG{p}{,} \PYG{n}{g}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{g}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
After having done the above RGSW ciphertext merging for every index \(i\), we need to multiplicatively put everything into a RLWE ciphertext.
Starting from \(\mathrm{RLWE}_{Q,s}^0(f \cdot x^\beta) := (0,f\cdot x^{\beta})\) we apply the \(\texttt{star-multiplication}\) \(N\) times to accumulate our RGSW ciphertexts of the single monomials \(x^{\alpha_i s_i}\).

\sphinxAtStartPar
The right\sphinxhyphen{}hand side being computed from left to right, we have:
\begin{equation*}
\begin{split}\mathrm{RLWE}_{Q,s}(f \cdot x^u) := \mathrm{RLWE}_{Q,s}^0(f \cdot x^\beta) \circledast \mathrm{RGSW}_{Q,s}(x^{\alpha_0 s_0}) \circledast \dots \circledast \mathrm{RGSW}_{Q,s}(x^{\alpha_{N-1}  s_{N-1}})\end{split}
\end{equation*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{blind\PYGZus{}rotation}\PYG{p}{(}\PYG{n}{lwe\PYGZus{}ciphertext}\PYG{p}{,} \PYG{n}{blind\PYGZus{}rotation\PYGZus{}keys}\PYG{p}{,} \PYG{n}{Delta}\PYG{p}{,} \PYG{n}{c\PYGZus{}boundary}\PYG{p}{,} \PYG{n}{ciphertext\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{B}\PYG{p}{,} \PYG{n}{rgsw\PYGZus{}one}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{alpha}\PYG{p}{,} \PYG{n}{beta}\PYG{p}{,} \PYG{n}{brk}\PYG{p}{,} \PYG{n}{D}\PYG{p}{,} \PYG{n}{c} \PYG{o}{=} \PYG{n}{lwe\PYGZus{}ciphertext}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{lwe\PYGZus{}ciphertext}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{blind\PYGZus{}rotation\PYGZus{}keys}\PYG{p}{,} \PYG{n}{Delta}\PYG{p}{,} \PYG{n}{c\PYGZus{}boundary}
    \PYG{n}{Q}\PYG{p}{,} \PYG{n}{N} \PYG{o}{=} \PYG{n}{ciphertext\PYGZus{}modulus}\PYG{p}{,} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{alpha}\PYG{p}{)}
    \PYG{n}{f} \PYG{o}{=} \PYG{n}{initialize\PYGZus{}rotation\PYGZus{}function}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,} \PYG{n}{D}\PYG{p}{,} \PYG{n}{c}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{)}
    \PYG{n}{ACC} \PYG{o}{=} \PYG{p}{[}\PYG{n}{generate\PYGZus{}zero\PYGZus{}poly}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{,} \PYG{n}{f}\PYG{o}{.}\PYG{n}{multiply}\PYG{p}{(}\PYG{n}{generate\PYGZus{}monomial}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,} \PYG{n}{beta}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{)}\PYG{p}{]}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{:}        
        \PYG{n}{pos\PYGZus{}rotation} \PYG{o}{=} \PYG{n}{rotation\PYGZus{}poly}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,} \PYG{n}{alpha}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{)}
        \PYG{n}{neg\PYGZus{}rotation} \PYG{o}{=} \PYG{n}{rotation\PYGZus{}poly}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{alpha}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{)}
        \PYG{n}{rgsw\PYGZus{}plus} \PYG{o}{=} \PYG{n}{rgsw\PYGZus{}multiply\PYGZus{}with\PYGZus{}poly}\PYG{p}{(}\PYG{n}{brk}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{pos\PYGZus{}rotation}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{)}
        \PYG{n}{rgsw\PYGZus{}minus} \PYG{o}{=} \PYG{n}{rgsw\PYGZus{}multiply\PYGZus{}with\PYGZus{}poly}\PYG{p}{(}\PYG{n}{brk}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{neg\PYGZus{}rotation}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{)}
        \PYG{n}{rgsw} \PYG{o}{=} \PYG{n}{rgsw\PYGZus{}add}\PYG{p}{(}\PYG{n}{rgsw\PYGZus{}add}\PYG{p}{(}\PYG{n}{rgsw\PYGZus{}plus}\PYG{p}{,} \PYG{n}{rgsw\PYGZus{}minus}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{)}\PYG{p}{,} \PYG{n}{rgsw\PYGZus{}one}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{)}
        \PYG{n}{ACC} \PYG{o}{=} \PYG{n}{star\PYGZus{}multiplication}\PYG{p}{(}\PYG{n}{ACC}\PYG{p}{,} \PYG{n}{rgsw}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{B}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{ACC}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Summary:
Taking \(\mathrm{LWE}_{2N,s}^0(u)\) and blind rotating it to \(\mathrm{RLWE}_{Q,s}(f \cdot x^u) := (a,b)\) has the desired effect of having \(\Delta \cdot u\) as the constant coefficient of \(f \cdot x^u\).
Moreover, we have:
\begin{equation}\label{equation:Thesis:blind-rotation-decryption}
\begin{split}a\cdot s+b = e_{\text{br}} + (\Delta \cdot u + \star \cdot x + \dots + \star \cdot x^{N-1}).\end{split}
\end{equation}
\sphinxAtStartPar
Here \(e_{\text{br}}\) denotes the blind rotation error and \(\star\) stands for an arbitrary coefficient.

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Error discussion}
\end{DUlineblock}
\label{Thesis:blind-rotation-error}
\begin{sphinxadmonition}{note}{Lemma 8 (Blind rotation error)}
\end{sphinxadmonition}

\sphinxAtStartPar
By \(E\) we mean an error size bound coming from a fresh RLWE encryption, thus depending on the standard deviation parameter (see {\hyperref[\detokenize{Thesis:error-after-BFV-encryption}]{\sphinxcrossref{Lemma 3}}}, {\hyperref[\detokenize{Thesis:sampling-bound}]{\sphinxcrossref{Theorem 2}}}).

\begin{sphinxadmonition}{note}
\sphinxAtStartPar
Proof. During the computation of \(\RGSW_{Q,s}(x^{\alpha_i s_i})\), we perform \(\texttt{rgsw-multiply-with-poly}\) two times.
Following \eqref{equation:Thesis:rlwe-multiply-error-growth}, the error size after this multiplication is at most \(2E\) in each RLWE component of RGSW, since we are using the sum of monomials \(x^{\pm \alpha_i} - 1\).
Adding both together (and adding the errorfree \(\RGSW^0(1)\)) yields an error size bounded by \(4E\) inside each \(\RGSW_{Q,s}(x^{\alpha_i s_i})\).

\sphinxAtStartPar
Applying \(\circledast\), thus applying {\hyperref[\detokenize{Thesis:error-after-star-multiplication}]{\sphinxcrossref{Lemma 7}}} \(N\) times with \(\norm{m_2} = 1\) and \(\norm{e_2} \le 4E\), yields the claim.
\end{sphinxadmonition}

\sphinxAtStartPar
If a RLWE encryption error has size at most \(E\), then the error after blind rotation \(e_{\text{br}}\) satisfies:
\begin{equation*}
\begin{split}\norm{e_{\text{br}}} \le 4N^{3/2}B \log_B(Q) E.\end{split}
\end{equation*}
\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Sparseness after blind rotation}
\end{DUlineblock}

\sphinxAtStartPar
It is important for the upcoming \(\texttt{repack}\) procedure to further specify a property about the \(\star\)’s in \eqref{equation:Thesis:blind-rotation-decryption}.
After \(\texttt{blind-rotation}\), we obtained a RLWE encryption of \(f \cdot x^u =: \tilde u\).
Recall that, starting from \(x^u\), the multiplication with the rotation function \(f\) only produces non\sphinxhyphen{}zero coefficients of \(\tilde u\) in the range \(x^{u-c},\dots, x^{u+c}\).
Because \(\abs u\) was initially bounded by \(c\), we can conclude that \(\tilde u\) only has non\sphinxhyphen{}zero coefficients in the range \(x^{-2c},\dots, x^{2c}\).
So, if later \(4c\) is much smaller than \(N\), we can use the remaining coefficients being zero to our advantage by simplifying and speeding up the \(\texttt{repack}\) procedure.

\phantomsection\label{\detokenize{Thesis:repacking}}
\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Step 3: Repacking}
\end{DUlineblock}

\sphinxAtStartPar
Having applied \(\texttt{blind-rotation}\) to \(N\) LWE ciphertexts (with messages \(u_0,\dots,u_{N-1}\)), we are left with merging the information contained in the latter, which only lies in the \(N\) constant coefficients.
So the \(\texttt{repack}\) procedure takes ciphertexts \(\mathrm{RLWE}_{Q,s}(\tilde u_i)\) for \(i \in \{0,\dots,N-1\}\) as an input.

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Simple merging from sparseness}
\end{DUlineblock}

\sphinxAtStartPar
First of all, we make use of the sparseness described above.
Select a minimal \(n\), a power of two for which \(n > 2c\) (recall that \(\abs {u_i} \le c\) for all \(i\)) holds.
Because the \(\tilde u_i\) have at most \(n\) non\sphinxhyphen{}zero coefficients, we may now merge subsets of \(N/n\) ciphertexts into a single one, by individually shifting the corresponding coefficients all by \(0,n,2n,\dots,N-n\) and afterwards adding all ciphertexts.
Shifting is done by the (error\sphinxhyphen{}wise cheap) \(\texttt{rlwe-multiply-with-poly}\) with \(x^{nk}\) for \(k \in \{0,1,\dots,N/n-1\}\). We do this for every integer \(i \in [0,n-1]\).

\sphinxAtStartPar
More precisely: Taking a subset of ciphertexts of \((\tilde u_{i+nk})_{k \in \{0,1,\dots,N/n-1\}}\) for a specific \(i\), we compute:
\begin{equation*}
\begin{split}\mathrm{RLWE}_{Q,s}(u_{i,n}) := \sum_{k=0}^{N/n-1} x^{nk} \cdot \mathrm{RLWE}_{Q,s}(\tilde u_{i+nk})\end{split}
\end{equation*}
\sphinxAtStartPar
via \(\texttt{rlwe-multiply-with-poly}\) and \(\texttt{rlwe-add}\).
Note that \(u_{i,n}\) still contains the desired information, i.e. \(\Delta \cdot u_{i+nk}\) is the coefficient of \(x^{nk}\) inside \(u_{i,n}\).

\sphinxAtStartPar
The error size of \(\mathrm{RLWE}_{Q,s}(u_{i,n})\) will be bounded by \(N/n \cdot \norm{ e_{\text{br}}}\), since the monomial multiplication does not increase the error size at all.

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Merging via automorphisms}
\end{DUlineblock}

\sphinxAtStartPar
The final goal is to obtain \(u_{0,1} = \Delta \cdot u = \Delta \cdot \sum_{i=0}^{N-1} u_i x^i\) by reducing the index \(n\) in \(u_{i,n}\) step\sphinxhyphen{}by\sphinxhyphen{}step to finally, \(1\).
We approach it by divide\sphinxhyphen{}and\sphinxhyphen{}conquer, i.e. always halving \(n\), thus also the number of ciphertexts per iteration and simultaneously doubling the information contained within each \(u_{i,(\cdot)}\).
In the end, every coefficient of \(u_{0,1}\) accommodates the matching \(u_i\) as information.

\sphinxAtStartPar
To keep the order of the \(u_i\) sound, the idea is to compute:
\begin{equation*}
\begin{split}\mathrm{RLWE}_{Q,s}(u_{i,n/2}) :\approx \mathrm{RLWE}_{Q,s}(u_{i,n}) + x^{n/2} \cdot \mathrm{RLWE}_{Q,s}(u_{i+n/2,n}),\end{split}
\end{equation*}
\sphinxAtStartPar
since \(\mathrm{RLWE}_{Q,s}(u_{i+n/2,n})\) contains \(\Delta\cdot u_{i+n/2+nk} \cdot x^{nk}\) for every \(k\);
and if one multiplies this with \(x^{n/2}\) it fulfills the above definition of \(u_{i,n}\).
But as a matter of fact, this is now incomplete (indicated by \(\approx\)) and wrong, since the \(\star\)\sphinxhyphen{}coefficients are interfering.

\sphinxAtStartPar
To resolve this issue, we make use of the \(N\) automorphisms \(\psi_t: R \rightarrow R, a(x) \mapsto a(x^t)\) for every \(t \perp 2N\).
They have the fruitful property of, when using the right \(t\), only permutating some subset of the coefficients.
Hence, if we transform that subset into just being the indices that we want to merge, we will be able to get rid of the undesirable \(\star\)\sphinxhyphen{}coefficients at the crucial monomials \(x^{nk}\) and \(x^{nk+n/2}\) for every \(k\).

\sphinxAtStartPar
Setting \(t := 1+2N/n\) will result in
\begin{equation*}
\begin{split}\psi_t(x^{nk}) = x^{nk+2Nk} = x^{nk}, \qquad \psi_t(x^{nk+n/2}) = x^{nk+n/2+2Nk+N} = - x^{nk+n/2},\end{split}
\end{equation*}
\sphinxAtStartPar
most importantly preserving the right exponent at the investigated monomials.

\sphinxAtStartPar
Thus if we apply \(\psi_t\) to e.g. \(\mathrm{RLWE}_{Q,s}(u_{i,n})\) we will still retain \(\Delta \cdot u_{i+nk} \cdot x^{nk}\) for every \(k\) as part of the message.
Moreover, in this case, the automorphism empowers us to liberate the other monomial of concern \(x^{nk+n/2}\) from its \(\star\) coefficient.
So by computing \(\mathrm{RLWE}_{Q,s}(u_{i,n}) + \psi_t(\mathrm{RLWE}_{Q,s}(u_{i,n}))\) we eliminate the term \(\star \cdot x^{nk+n/2}\) for every \(k\).
As we are mirroring this technique with the other RLWE ciphertext, \(\star \cdot x^{nk}\) inside \(x^{n/2} \cdot \mathrm{RLWE}_{Q,s}(u_{i+n/2,n})\) gets deleted for every \(k\), too.

\sphinxAtStartPar
In total we compute at each iteration for every \(i\):
\begin{equation*}
\begin{split}\begin{split}
\mathrm{RLWE}_{Q,s}(2\cdot u_{i,n/2}) &:= \mathrm{RLWE}_{Q,s}(u_{i,n}) + x^{n/2} \cdot \mathrm{RLWE}_{Q,s}(u_{i+n/2,n}) \\ &+ \texttt{eval-auto}_{t=1+\frac{2N}{n}}\left( \mathrm{RLWE}_{Q,s}(u_{i,n}) - x^{n/2} \cdot \mathrm{RLWE}_{Q,s}(u_{i+n/2,n})\right).
\end{split}\end{split}
\end{equation*}
\sphinxAtStartPar
We move on to the next iteration by halving \(n\).

\sphinxAtStartPar
Notice that we have picked up a factor of two while merging two RLWE ciphertexts.
As we perform \(\log_2(n)\) iterations, we will arrive at a factor \(2^{\log_2(n)}\) which translates to the ciphertext \(\mathrm{RLWE}_{Q,s}(n\cdot u_{i,n}) = \mathrm{RLWE}_{Q,s}(n\cdot \Delta \cdot u)\) after repacking.
This will not cause any further problems, since we can eliminate this factor \(n\) via \(\texttt{rescale}\) at the end of our algorithm, which we have to do anyhow to scale down the bootstrapping error accumulated up to this point.
Further details on this issue will be provided after we have stated the algorithm.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{repack}\PYG{p}{(}\PYG{n}{rlwe\PYGZus{}ciphertexts}\PYG{p}{,} \PYG{n}{ciphertext\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{B}\PYG{p}{,} \PYG{n}{auxiliary\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{n}\PYG{p}{,} \PYG{n}{key\PYGZus{}switch\PYGZus{}array}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{Q}\PYG{p}{,} \PYG{n}{rlwe} \PYG{o}{=} \PYG{n}{ciphertext\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{rlwe\PYGZus{}ciphertexts} \PYG{c+c1}{\PYGZsh{} actually here Q equals Q*n*p (*T in BFV)}
    \PYG{n}{N}\PYG{p}{,} \PYG{n}{p} \PYG{o}{=} \PYG{n+nb}{getattr}\PYG{p}{(}\PYG{n}{rlwe}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ring\PYGZus{}degree}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{auxiliary\PYGZus{}modulus}
    \PYG{n}{u} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0} \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{]} \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{]}
    \PYG{c+c1}{\PYGZsh{} Sparseness merging:}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{u}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]} \PYG{o}{=} \PYG{n}{rlwe}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
        \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{N}\PYG{o}{/}\PYG{o}{/}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{u}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]} \PYG{o}{=} \PYG{n}{rlwe\PYGZus{}add}\PYG{p}{(}\PYG{n}{rlwe\PYGZus{}multiply\PYGZus{}with\PYGZus{}poly}\PYG{p}{(}\PYG{n}{rlwe}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{n}{n}\PYG{o}{*}\PYG{n}{k}\PYG{p}{]}\PYG{p}{,} \PYG{n}{generate\PYGZus{}monomial}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,} \PYG{n}{n}\PYG{o}{*}\PYG{n}{k}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{)}\PYG{p}{,} \PYG{n}{u}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{} Automorphism merging:}
    \PYG{n}{k} \PYG{o}{=} \PYG{n}{n}
    \PYG{k}{while} \PYG{n}{k} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1}\PYG{p}{:}
        \PYG{n}{x\PYGZus{}to\PYGZus{}the\PYGZus{}k\PYGZus{}halfed} \PYG{o}{=} \PYG{n}{generate\PYGZus{}monomial}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,} \PYG{n}{k}\PYG{o}{/}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{k}\PYG{o}{/}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{u}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{k}\PYG{o}{/}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{n}{rlwe\PYGZus{}add}\PYG{p}{(}\PYG{n}{u}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{,} \PYG{n}{rlwe\PYGZus{}multiply\PYGZus{}with\PYGZus{}poly}\PYG{p}{(}\PYG{n}{u}\PYG{p}{[}\PYG{n}{i} \PYG{o}{+} \PYG{p}{(}\PYG{n}{k}\PYG{o}{/}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{,} \PYG{n}{x\PYGZus{}to\PYGZus{}the\PYGZus{}k\PYGZus{}halfed}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{)}
            \PYG{n}{to\PYGZus{}be\PYGZus{}evaluated} \PYG{o}{=} \PYG{n}{rlwe\PYGZus{}multiply\PYGZus{}with\PYGZus{}poly}\PYG{p}{(}\PYG{n}{u}\PYG{p}{[}\PYG{n}{i} \PYG{o}{+} \PYG{p}{(}\PYG{n}{k}\PYG{o}{/}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{,} \PYG{n}{x\PYGZus{}to\PYGZus{}the\PYGZus{}k\PYGZus{}halfed}\PYG{o}{.}\PYG{n}{scalar\PYGZus{}multiply}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{)}
            \PYG{n}{to\PYGZus{}be\PYGZus{}evaluated} \PYG{o}{=} \PYG{n}{rlwe\PYGZus{}add}\PYG{p}{(}\PYG{n}{to\PYGZus{}be\PYGZus{}evaluated}\PYG{p}{,} \PYG{n}{u}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{)}
            \PYG{n}{u\PYGZus{}rotated} \PYG{o}{=} \PYG{n}{eval\PYGZus{}auto}\PYG{p}{(}\PYG{n}{to\PYGZus{}be\PYGZus{}evaluated}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{o}{+} \PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{N}\PYG{p}{)}\PYG{o}{/}\PYG{o}{/}\PYG{n}{k}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{B}\PYG{p}{,} \PYG{n}{key\PYGZus{}switch\PYGZus{}array}\PYG{p}{)}
            \PYG{n}{u}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{k}\PYG{o}{/}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{n}{rlwe\PYGZus{}add}\PYG{p}{(}\PYG{n}{u\PYGZus{}rotated}\PYG{p}{,} \PYG{n}{u}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{k}\PYG{o}{/}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{)}
        \PYG{n}{k} \PYG{o}{/}\PYG{o}{/}\PYG{o}{=} \PYG{l+m+mi}{2}
    \PYG{k}{return} \PYG{n}{rescale}\PYG{p}{(}\PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{n}\PYG{o}{*}\PYG{n}{p}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{Analysis of \(\texttt{scaled-mod}\)}
\end{DUlineblock}

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Error analysis}
\end{DUlineblock}

\sphinxAtStartPar
The above code still raises some yet unanswered questions, concerning the \(\texttt{rescale}\) procedure at the end and the different moduli used.
Rescaling solves two issues at once:
\begin{itemize}
\item {} 
\sphinxAtStartPar
To finally receive a RLWE ciphertext of \(\Delta \cdot u\) and not \(n\cdot\Delta\cdot u\), we augment the ciphertext modulus from \(Q\) to \(Q\cdot n\) during \(\texttt{scaled-mod}\) and rescale the final result by \(n\).

\item {} 
\sphinxAtStartPar
To handle the error growth accumulated during \(\texttt{blind-rotation}\) and \(\texttt{repack}\) (discussion below), we will further introduce another auxiliary modulus \(p\), i.e. the bootstrapping modulus will be again enlarged.
It should be large enough (but still be minimal for complexity reasons) to let \(\texttt{rescale}\) lessen the error inside our RLWE ciphertext, such that it becomes comparable to an encryption error.
Recall, that \(\texttt{rescale}\) still adds a small error, too.

\end{itemize}

\sphinxAtStartPar
Summarized, inside the whole \(\texttt{scaled-mod}\) procedure we work with a ciphertext modulus of \(Q \cdot n \cdot p\), where \(Q\) is selected according to the underlying scheme of encoding (e.g. BFV).

\sphinxAtStartPar
Below we put together the parts of the \(\texttt{scaled-mod}\) procedure.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{scaled\PYGZus{}mod}\PYG{p}{(}\PYG{n}{rlwe}\PYG{p}{,} \PYG{n}{Delta}\PYG{p}{,} \PYG{n}{c\PYGZus{}boundary}\PYG{p}{,} \PYG{n}{ciphertext\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{auxiliary\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{blind\PYGZus{}rotation\PYGZus{}keys}\PYG{p}{,} \PYG{n}{rgsw\PYGZus{}one}\PYG{p}{,} \PYG{n}{key\PYGZus{}switch\PYGZus{}array}\PYG{p}{,} \PYG{n}{B}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{Q}\PYG{p}{,} \PYG{n}{p}\PYG{p}{,} \PYG{n}{N}\PYG{p}{,} \PYG{n}{c}\PYG{p}{,} \PYG{n}{brk}\PYG{p}{,} \PYG{n}{n} \PYG{o}{=} \PYG{n}{ciphertext\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{auxiliary\PYGZus{}modulus}\PYG{p}{,} \PYG{n+nb}{getattr}\PYG{p}{(}\PYG{n}{rlwe}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ring\PYGZus{}degree}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{c\PYGZus{}boundary}\PYG{p}{,} \PYG{n}{blind\PYGZus{}rotation\PYGZus{}keys}\PYG{p}{,} \PYG{l+m+mi}{1}
    \PYG{k}{while}\PYG{p}{(}\PYG{n}{n} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{c} \PYG{o+ow}{and} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{n} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{n} \PYG{o}{*}\PYG{o}{=} \PYG{l+m+mi}{2}
    \PYG{n}{lwe} \PYG{o}{=} \PYG{n}{extraction}\PYG{p}{(}\PYG{n}{rlwe}\PYG{p}{)}
    \PYG{n}{rotated} \PYG{o}{=} \PYG{p}{[}\PYG{n}{blind\PYGZus{}rotation}\PYG{p}{(}\PYG{n}{lwe}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{brk}\PYG{p}{,} \PYG{n}{Delta}\PYG{o}{*}\PYG{n}{p}\PYG{p}{,} \PYG{n}{c}\PYG{p}{,} \PYG{n}{Q}\PYG{o}{*}\PYG{n}{n}\PYG{o}{*}\PYG{n}{p}\PYG{p}{,} \PYG{n}{B}\PYG{p}{,} \PYG{n}{rgsw\PYGZus{}one}\PYG{p}{)} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{]}
    \PYG{k}{return} \PYG{n}{repack}\PYG{p}{(}\PYG{n}{rotated}\PYG{p}{,} \PYG{n}{Q}\PYG{o}{*}\PYG{n}{n}\PYG{o}{*}\PYG{n}{p}\PYG{p}{,} \PYG{n}{B}\PYG{p}{,} \PYG{n}{p}\PYG{p}{,} \PYG{n}{n}\PYG{p}{,} \PYG{n}{key\PYGZus{}switch\PYGZus{}array}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}\label{Thesis:error-size-after-scaled-mod}
\begin{sphinxadmonition}{note}{Theorem 7 (Error size after \protect\(\texttt{scaled-mod}\protect\))}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}
\sphinxAtStartPar
Proof. {\hyperref[\detokenize{Thesis:blind-rotation-error}]{\sphinxcrossref{Lemma 8}}} bounds the size of the error \(e_{\text{br}}\) after the blind rotation step by \(4N^{3/2}B\log_B(Q)E\).
The error bound from the first part of merging inside \(\texttt{repack}\) was \(N/n \cdot \norm{ e_{\text{br}}}\).

\sphinxAtStartPar
In the automorphism merging of \(\texttt{repack}\), per iteration an error \(\tilde e\) passes on with size:
\begin{equation*}
\begin{split}\norm{4 \tilde e + (B/2)\log_B(Q) E \sqrt{N}},\end{split}
\end{equation*}
\sphinxAtStartPar
since we perform \(4\) RLWE additions and introduce the additional \(\texttt{eval-auto}\) error of size \((B/2)\log_B(Q) E \sqrt{N}\) (see {\hyperref[\detokenize{Thesis:automorphisms-of-r}]{\sphinxcrossref{\DUrole{std,std-ref}{Automorphisms of R}}}}).

\sphinxAtStartPar
In total, we perform \(\log_2(n)\) iterations, making the error before rescaling as large as:
\begin{equation*}
\begin{split}\begin{split}
\norm{e_{\text{sm}}} &= 4^{\log_2(n)}\frac{N}{n}\norm{e_{\text{br}}} + \frac{B}{2}\log_B(Q)E\sqrt{N}\sum_{i=0}^{\log_2(n)-1} 4^i \\
&\le nN\norm{e_{\text{br}}} + \frac{B}{2}\log_B(Q)E\sqrt{N}n^2 \\
&\le 5nN^{5/2}B\log_B(Q)E.
\end{split}\end{split}
\end{equation*}\end{sphinxadmonition}

\sphinxAtStartPar
If a RLWE encryption error has size at most \(E\), then the error \(e_{\text{sm}}\) after \(\texttt{scaled-mod}\) without rescaling satisfies:
\begin{equation*}
\begin{split}\norm{e_{\text{sm}}} \le 5nN^{5/2}B\log_B(Q)E.\end{split}
\end{equation*}
\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Computational complexity}
\end{DUlineblock}

\sphinxAtStartPar
At this point, we can already provide the runtime analysis of the entire \(\texttt{bootstrapping}\) procedure since \(\texttt{scaled-mod}\) and especially the blind rotation is the dominant part of it.
Following the approach in {[}\hyperlink{cite.Thesis:id72}{Kim \sphinxstyleemphasis{et al.}, 2021}{]}, Section 6.1., we describe a high\sphinxhyphen{}level complexity analysis by employing the common \(\mathcal O\) notation as well as founding the analysis on the universal operation of multiplying elements of \(R_Q\).
\label{Thesis:complexity-of-scaled-mod}
\begin{sphinxadmonition}{note}{Theorem 8 (Complexity of \protect\(\texttt{scaled-mod}\protect\))}
\end{sphinxadmonition}

\sphinxAtStartPar
Before proving the theorem, we remark on the following (by referring to the previous chapters):
\begin{itemize}
\item {} 
\sphinxAtStartPar
A RLWE multiplication involves \(\mathcal O(1)\) multiplications in \(R_Q\).

\item {} 
\sphinxAtStartPar
A RLWE addition can always be estimated by a RLWE multiplication considering the computation time.

\item {} 
\sphinxAtStartPar
Consequently, a \(\texttt{rlwe-x-scalar-multiplication}\) \(\odot\) can be performed in \(\mathcal O(\log_B(Q))\) multiplications in \(R_Q\).

\item {} 
\sphinxAtStartPar
Similarly, adding/multiplying polynomials with RGSW ciphertexts requires \(\mathcal O(\log_B(Q))\) multiplications in \(R_Q\), too.

\item {} 
\sphinxAtStartPar
\(\texttt{eval-auto}\) essentially executes \(\odot\) once.

\end{itemize}

\begin{sphinxadmonition}{note}
\sphinxAtStartPar
Proof. The {\hyperref[\detokenize{Thesis:extraction-of-lwe-ciphertexts}]{\sphinxcrossref{\DUrole{std,std-ref}{Step 1: Extraction of LWE ciphertexts}}}} clearly has a negligible running time compared to the one given in the theorem.

\sphinxAtStartPar
Inside {\hyperref[\detokenize{Thesis:blind-rotation}]{\sphinxcrossref{\DUrole{std,std-ref}{Step 2: Blind rotation}}}}, we perform \(N\) \(\texttt{blind-rotation}\)s.
Each one consists of \(N\) \(\texttt{star-multiplication}\)s and \(N\) computations of \(\RGSW(x^{\alpha_i s_i})\).
Since \(\circledast\) involves two \(\odot\) operations and \(\RGSW(x^{\alpha_i s_i})\) requires three \(\texttt{rgsw-multiply-with-poly}\), we conclude a running time of \(\mathcal O(N^2 \cdot \log_B(Q))\) for the \(\texttt{blind-rotation}\).

\sphinxAtStartPar
The {\hyperref[\detokenize{Thesis:repacking}]{\sphinxcrossref{\DUrole{std,std-ref}{Step 3: Repacking}}}} includes loops of length \(n\) in both merging processes.
Inside each iteration, we perform \(\mathcal O(1)\) RLWE multiplications/additions and one \(\texttt{eval-auto}\).
Estimating \(n \le N\) and thus estimating the \(\texttt{repack}\) procedure with the \(\texttt{blind-rotation}\) procedure yields the claim.
\end{sphinxadmonition}

\sphinxAtStartPar
The entire \(\texttt{scaled-mod}\) procedure can be performed with \(\mathcal O(N^2 \cdot \log_B(Q))\) polynomial multiplications in \(R_Q\).

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{Adapting \(\texttt{scaled-mod}\) to BFV encoding}
\end{DUlineblock}

\sphinxAtStartPar
Finally, we want to clarify, how the upscaling of a message (\(u\) to \(\Delta \cdot u\) during \(\texttt{scaled-mod}\)) allows us to regain a small error for a BFV ciphertext in particular.
We also provide the missing details, e.g. how to select \(c\) in \(\texttt{scaled-mod}\) or why we could assume an errorless encryption at the start of it, along the way.
This section bases on Section 4.3.1. in {[}\hyperlink{cite.Thesis:id72}{Kim \sphinxstyleemphasis{et al.}, 2021}{]}.

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Removing the big error}
\end{DUlineblock}

\sphinxAtStartPar
The issue of replacing a big error can be best described by treating RLWE ciphertexts in \(R\) (i.e. without a modulus).
Assume we have a BFV encryption of \(m \in R_T\) as:
\begin{equation*}
\begin{split}\mathrm{BFV}_{T,Q,s}(m) := (a,b) := (a, -a\cdot s +e + (Q/T)\cdot m) \in R_Q^2,\end{split}
\end{equation*}
\sphinxAtStartPar
where \(a \in R_Q\), \(e\) is an error of size that still leads to a correct decryption, and \(Q\) and \(T\) are powers of two to avoid the rounding.
We conveniently denote the essential decryption query in general (not only for the above ciphertext) as \(\mathrm{ct}(s) := a\cdot s+b \ (\equiv e + (Q/T)\cdot m \in R_Q)\).

\sphinxAtStartPar
Subtracting the big error is technically easy, but it elicits the problem of needing to scale up a message (which then gets passed on to \(\texttt{scaled-mod}\)).

\sphinxAtStartPar
Starting from our \(\mathrm{ct} := (a,b)\) with the property \(\mathrm{ct}(s) =: e + (Q/T)m + Q \cdot w \in R\) above, let us define (component\sphinxhyphen{}wise):
\begin{equation*}
\begin{split}\mathrm{ct'} := T\cdot \mathrm{ct} \mod Q,\qquad \mathrm{ct''} := \mathrm{ct'} \mod Q',\end{split}
\end{equation*}
\sphinxAtStartPar
where \(Q' := Q/2N\).
Observe that \(\mathrm{ct'}\) removes the denominator \(T\) and \(\mathrm{ct''}\) enables us to already subtract the big error \(e\) as well as preparing our \(\mathrm{RLWE}_{2N,s}^0(\cdot)\) ciphertext, which \(\texttt{scaled-mod}\) requires.
Removing the big error becomes comprehensible by considering:
\begin{equation}\label{equation:Thesis:definition-of-u}
\begin{split}\mathrm{ct'}(s) = T\cdot e + Q\cdot \underbrace{(m+T\cdot w)}_{=: v} \in R, \qquad \mathrm{ct''}(s) =: T\cdot e + Q' \cdot u \in R.\end{split}
\end{equation}
\sphinxAtStartPar
If we take the difference \((\mathrm{ct'} - \mathrm{ct''})(s)\), we will successfully remove the \(T\cdot e\) term. Furthermore, getting rid of \(Q'\), which divides \(Q\) anyway, we arrive at:
\begin{equation*}
\begin{split}\mathrm{ct}_{\text{prep}}(s) := \left(\frac{\mathrm{ct'}-\mathrm{ct''}}{Q'}\right)(s) = -u + 2N \cdot v \in R.\end{split}
\end{equation*}
\sphinxAtStartPar
This is precisely the error\sphinxhyphen{}free encryption of \(-u\) within the modulus \(2N\) that \(\texttt{scaled-mod}\) takes as input.
The above also answers the question of why we can assume an errorless RLWE encryption:
Since we are not explicitly encrypting with an error equal to zero but only using a transformation from a RLWE ciphertext to an error\sphinxhyphen{}free encryption, we still can rely on the RLWE security described in {\hyperref[\detokenize{Thesis:security}]{\sphinxcrossref{\DUrole{std,std-ref}{Security}}}}.

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{Restoring \(m\) after \(\texttt{scaled-mod}\)}
\end{DUlineblock}

\sphinxAtStartPar
Because we are using \(\mathrm{ct'} \in R_Q^2\) involving the sophisticated \(0 \equiv Q \cdot m \mod Q\) and the obstructive \(Q\cdot T \cdot w\) inside \(\mathrm{ct'}(s)\), we clearly have to expand the modulus from \(Q\) to \(Q\cdot T\) during \(\texttt{scaled-mod}\), to have any chance of piecing everything together correctly afterwards.
Notice that now the bootstrapping modulus is \(Q\cdot T \cdot n \cdot p\) in total.

\sphinxAtStartPar
Consider the following three ciphertexts in \(R_{QT}\):
\begin{equation*}
\begin{split}\begin{split}
(T \cdot \mathrm{ct})(s) = T \cdot e + Q \cdot m, \qquad
 \mathrm{ct}''(s) &= T\cdot e + Q' \cdot u, \\
\texttt{scaled-mod}(\mathrm{ct}_{\mathrm{prep}}, \ \Delta = -Q',\ \text{modulus} = Q\cdot T)(s) &= Q'\cdot u + e_{\text{sm}}.
\end{split}\end{split}
\end{equation*}
\sphinxAtStartPar
By cleverly adding/subtracting them together, we only end up with the desired \(Q\cdot m \in R_{QT}\) plus the already rescaled error \(e_{\text{sm}}\) from \(\texttt{scaled-mod}\).

\sphinxAtStartPar
The last step involves \(\texttt{rescale}\) once again, to scale down the modulus from \(Q\cdot T\) to \(Q\) as well as the message from \(Q\cdot m\) to BFV\sphinxhyphen{}fitting \((Q/T)\cdot m\).
As described in {\hyperref[\detokenize{Thesis:rescaling}]{\sphinxcrossref{\DUrole{std,std-ref}{Rescaling}}}}, we will also downscale \(e_{sm}\) by \(T\) and only add a small \(\texttt{rescale}\) error with \(\norm{e_{\text{rs}}} \le \sqrt{N}/2\) to the final result.
If \(\mathrm{ct}_{\text{sm}}\) denotes the ciphertext after \(\texttt{scaled-mod}\), we set the ciphertext \(\mathrm{ct}_{\text{boot}}\) after \(\texttt{bootstrapping}\) to:
\begin{equation*}
\begin{split}\mathrm{ct}_{\text{boot}} := \texttt{rescale}_{Q\cdot T \longrightarrow Q} \left(\mathrm{ct}_{\text{sm}} - \mathrm{ct''} + T \cdot \mathrm{ct} \right) \in R_Q.\end{split}
\end{equation*}
\sphinxAtStartPar
\(\texttt{bootstrapping}\) returns \(\mathrm{ct}_{\text{boot}}(s) = \round{e_{\text{sm}}/T} + e_{\text{rs}} + (Q/T)\cdot m\).

\sphinxAtStartPar
We are left to determine \(c\), which occurs during \(\texttt{blind-rotation}\) (definition of \(f\)) and which satisfies \(\norm u < c\).
Consider \eqref{equation:Thesis:definition-of-u}, i.e. the implicit definition of \(u\).
It follows that
\begin{equation}\label{equation:Thesis:norm-u}
\begin{split}\norm u = \frac{1}{Q'} \norm{[T \cdot a]_{Q'} \cdot s + [T \cdot b]_{Q'} - T \cdot e} \le \frac{C\sqrt{N}+1}{2} + \frac{\gamma}{Q'} < N/2,\end{split}
\end{equation}
\sphinxAtStartPar
where \(\norm{T \cdot e} \le \gamma\) and the {\hyperref[\detokenize{Thesis:conclusion-on-delta-r}]{\sphinxcrossref{\DUrole{std,std-ref}{Conclusion on the expansion factor}}}} with \(\delta_R = C\cdot\sqrt{N}\) were used.

\sphinxAtStartPar
Since \(\norm u < N/2\) is required during \(\texttt{scaled-mod}\) (its coefficients serve as an exponent of a ring element), \(\gamma\) can be selected such that \(T \norm{e} < \gamma < (Q/4N)(N-C\sqrt{N}-1)\) holds as an easy calculation shows.
Note that this also implies a condition on the size of the error \(e\) before entering the bootstrapping procedure.

\sphinxAtStartPar
In total we define \(c := \lfloor (C\sqrt{N}+1)/2 + \gamma/Q' \rfloor\) obtained from \eqref{equation:Thesis:norm-u}.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{bootstrapping}\PYG{p}{(}\PYG{n}{ciphertext}\PYG{p}{,} \PYG{n}{ciphertext\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{plaintext\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{auxiliary\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{blind\PYGZus{}rotation\PYGZus{}keys}\PYG{p}{,} \PYG{n}{rgsw\PYGZus{}one}\PYG{p}{,} \PYG{n}{key\PYGZus{}switch\PYGZus{}array}\PYG{p}{,} \PYG{n}{B}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{ct}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{T}\PYG{p}{,} \PYG{n}{p}\PYG{p}{,} \PYG{n}{brk} \PYG{o}{=} \PYG{n}{ciphertext}\PYG{p}{,} \PYG{n}{ciphertext\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{plaintext\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{auxiliary\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{blind\PYGZus{}rotation\PYGZus{}keys}
    \PYG{n}{N} \PYG{o}{=} \PYG{n+nb}{getattr}\PYG{p}{(}\PYG{n}{ciphertext}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ring\PYGZus{}degree}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{} Preprocessing:}
    \PYG{n}{ct\PYGZus{}x} \PYG{o}{=} \PYG{p}{[}\PYG{n}{ct}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{scalar\PYGZus{}multiply}\PYG{p}{(}\PYG{n}{T}\PYG{p}{)}\PYG{o}{.}\PYG{n}{mod\PYGZus{}small}\PYG{p}{(}\PYG{n}{Q}\PYG{p}{)}\PYG{p}{,} \PYG{n}{ct}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{scalar\PYGZus{}multiply}\PYG{p}{(}\PYG{n}{T}\PYG{p}{)}\PYG{o}{.}\PYG{n}{mod\PYGZus{}small}\PYG{p}{(}\PYG{n}{Q}\PYG{p}{)}\PYG{p}{]}
    \PYG{n}{Q\PYGZus{}x} \PYG{o}{=} \PYG{n}{Q} \PYG{o}{/}\PYG{o}{/} \PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{N}\PYG{p}{)}
    \PYG{n}{ct\PYGZus{}xx} \PYG{o}{=} \PYG{p}{[}\PYG{n}{ct\PYGZus{}x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{mod\PYGZus{}small}\PYG{p}{(}\PYG{n}{Q\PYGZus{}x}\PYG{p}{)}\PYG{p}{,} \PYG{n}{ct\PYGZus{}x}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{mod\PYGZus{}small}\PYG{p}{(}\PYG{n}{Q\PYGZus{}x}\PYG{p}{)}\PYG{p}{]}
    \PYG{n}{ct\PYGZus{}prep1} \PYG{o}{=} \PYG{n}{ct\PYGZus{}x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{subtract}\PYG{p}{(}\PYG{n}{ct\PYGZus{}xx}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{scalar\PYGZus{}integer\PYGZus{}divide}\PYG{p}{(}\PYG{n}{Q\PYGZus{}x}\PYG{p}{)}\PYG{o}{.}\PYG{n}{mod\PYGZus{}small}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{N}\PYG{p}{)}
    \PYG{n}{ct\PYGZus{}prep2} \PYG{o}{=} \PYG{n}{ct\PYGZus{}x}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{subtract}\PYG{p}{(}\PYG{n}{ct\PYGZus{}xx}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{scalar\PYGZus{}integer\PYGZus{}divide}\PYG{p}{(}\PYG{n}{Q\PYGZus{}x}\PYG{p}{)}\PYG{o}{.}\PYG{n}{mod\PYGZus{}small}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{N}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{} scaled\PYGZhy{}mod procedure:}
    \PYG{n}{gamma} \PYG{o}{=} \PYG{n}{floor}\PYG{p}{(}\PYG{n}{Q}\PYG{o}{*}\PYG{n}{floor}\PYG{p}{(}\PYG{n}{N}\PYG{o}{\PYGZhy{}}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{/}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{o}{*}\PYG{n}{N}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{c} \PYG{o}{=} \PYG{n+nb}{min}\PYG{p}{(}\PYG{n}{floor}\PYG{p}{(}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)} \PYG{o}{+} \PYG{n}{gamma}\PYG{o}{/}\PYG{n}{Q\PYGZus{}x}\PYG{p}{)}\PYG{p}{,} \PYG{n}{floor}\PYG{p}{(}\PYG{n}{N}\PYG{o}{/}\PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{ct\PYGZus{}sm} \PYG{o}{=} \PYG{n}{scaled\PYGZus{}mod}\PYG{p}{(}\PYG{p}{[}\PYG{n}{ct\PYGZus{}prep1}\PYG{p}{,} \PYG{n}{ct\PYGZus{}prep2}\PYG{p}{]}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{Q\PYGZus{}x}\PYG{p}{,} \PYG{n}{c}\PYG{p}{,} \PYG{n}{Q}\PYG{o}{*}\PYG{n}{T}\PYG{p}{,} \PYG{n}{p}\PYG{p}{,} \PYG{n}{brk}\PYG{p}{,} \PYG{n}{rgsw\PYGZus{}one}\PYG{p}{,} \PYG{n}{key\PYGZus{}switch\PYGZus{}array}\PYG{p}{,} \PYG{n}{B}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{} Restoring:}
    \PYG{n}{t\PYGZus{}ct} \PYG{o}{=} \PYG{p}{[}\PYG{n}{ct}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{scalar\PYGZus{}multiply}\PYG{p}{(}\PYG{n}{T}\PYG{p}{,} \PYG{n}{Q}\PYG{o}{*}\PYG{n}{T}\PYG{p}{)}\PYG{p}{,} \PYG{n}{ct}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{scalar\PYGZus{}multiply}\PYG{p}{(}\PYG{n}{T}\PYG{p}{,} \PYG{n}{Q}\PYG{o}{*}\PYG{n}{T}\PYG{p}{)}\PYG{p}{]}
    \PYG{n}{minus\PYGZus{}ct\PYGZus{}xx} \PYG{o}{=} \PYG{p}{[}\PYG{n}{ct\PYGZus{}xx}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{scalar\PYGZus{}multiply}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{ct\PYGZus{}xx}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{scalar\PYGZus{}multiply}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{]}
    \PYG{n}{ct\PYGZus{}xxx} \PYG{o}{=} \PYG{n}{rlwe\PYGZus{}add}\PYG{p}{(}\PYG{n}{ct\PYGZus{}sm}\PYG{p}{,} \PYG{n}{rlwe\PYGZus{}add}\PYG{p}{(}\PYG{n}{t\PYGZus{}ct}\PYG{p}{,} \PYG{n}{minus\PYGZus{}ct\PYGZus{}xx}\PYG{p}{,} \PYG{n}{Q}\PYG{o}{*}\PYG{n}{T}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Q}\PYG{o}{*}\PYG{n}{T}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{rescale}\PYG{p}{(}\PYG{n}{ct\PYGZus{}xxx}\PYG{p}{,} \PYG{n}{Q}\PYG{o}{*}\PYG{n}{T}\PYG{p}{,} \PYG{n}{T}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Remark on the code:
Especially when working with a small \(N\), we have to ensure that \(c < N/2\) by providing a very small \(\gamma\), since also \(C\) inside \(\delta_R\) may be unusually large.
In the worst case, \eqref{equation:Thesis:norm-u} does not hold, because \(C\sqrt{N}\) would be replaced by \(N\) instead.
For large \(N\) this only happens with negligible probability, as pointed out in {\hyperref[\detokenize{Thesis:bound-for-multiplying-two-ring-elements}]{\sphinxcrossref{\DUrole{std,std-ref}{Bound for multiplying two R\sphinxhyphen{}elements}}}}.

\phantomsection\label{\detokenize{Thesis:parameters-for-bootstrapping}}
\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Parameters for bootstrapping}
\end{DUlineblock}

\sphinxAtStartPar
Choosing the optimal parameters \(\{N, T, Q, p, B\}\) is very important since we already have shown that they can heavily influence the computation time.

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{Message length \(N\)}
\end{DUlineblock}

\sphinxAtStartPar
The main security parameter \(N\) defines the number of coefficients of a polynomial.
Clearly, a small \(N\) as selected in our example Python demonstration cannot possibly satisfy any modern security measures.
In the Homomorphic Encryption Security Standard (see {[}\hyperlink{cite.Thesis:id68}{Albrecht \sphinxstyleemphasis{et al.}, 2018}{]}) a security analysis for \(N\) ranging in \(2^{10},\dots,2^{15}\) is provided.

\sphinxAtStartPar
Note that multiplying polynomials of degree \(N-1\), which the Karatsuba algorithm performs in roughly \(N^{\log_2(3)}\) integer multiplications, is the basic operation of our scheme.
Moreover, \(N\) has an even greater impact on the runtime, because, inter alia, we perform \(N\) \(\texttt{blind-rotation}\)s.
In total, a larger \(N\) yields a significantly longer running time:
In practice we observed that, when we double \(N\), we can expect a running time of \(\approx\) 10\sphinxhyphen{}12 times the original one.
In theory, if we combine {\hyperref[\detokenize{Thesis:complexity-of-scaled-mod}]{\sphinxcrossref{Theorem 8}}} with Karatsuba, we have \((2N)^{2+\log_2(3)} = 12N\), too.

\sphinxAtStartPar
Naturally, this also points out why fully homomorphic encryption in general (still) lacks viability in modern applications.

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{Plaintext modulus \(T\)}
\end{DUlineblock}

\sphinxAtStartPar
The encoding parameter \(T\) allows us to encode \(T^N\) distinct integers in one (BFV) ciphertext.
As we have seen during the BFV multiplication algorithm, choosing a larger \(T\) also demands a larger \(Q\) (see {\hyperref[\detokenize{Thesis:error-after-BFV-multiplication}]{\sphinxcrossref{Theorem 6}}}) for the same amount of possible operations, which leads to longer computation times.
Additionally, \(T\) also scales the bootstrapping modulus quasi\sphinxhyphen{}linearly.
For demonstration purposes and simplicity we set \(T = 2\).

\phantomsection\label{\detokenize{Thesis:ciphertext-modulus-q}}
\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{Ciphertext modulus \(Q\)}
\end{DUlineblock}

\sphinxAtStartPar
By combining {\hyperref[\detokenize{Thesis:correct-BFV-decryption}]{\sphinxcrossref{Lemma 4}}} and {\hyperref[\detokenize{Thesis:error-after-BFV-multiplication}]{\sphinxcrossref{Theorem 6}}}, we observe that the BFV scheme can evaluate circuits of multiplicative depth \(k\) if (roughly):
\begin{equation*}
\begin{split}(2TN)^k < \frac{Q}{2N} \iff k < \frac{\log_2(Q)-\log_2(2T)}{\log_2(2TN)}.\end{split}
\end{equation*}
\sphinxAtStartPar
This shows that we need to square \(Q\) if we want to double the multiplicative depth \(k\).
In this case, although we will only need half of the \(\texttt{bootstrapping}\) procedures, {\hyperref[\detokenize{Thesis:complexity-of-scaled-mod}]{\sphinxcrossref{Theorem 8}}} shows that the bootstrapping time will double as well inside the \(\mathcal O\)\sphinxhyphen{}notation.
Furthermore, a multiplication in \(R_Q\) will be costlier as the following computation points out.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{N}\PYG{p}{,} \PYG{n}{Q} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{50}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{testing\PYGZus{}poly} \PYG{o}{=} \PYG{n}{generate\PYGZus{}uniform\PYGZus{}distribution}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{Q}\PYG{o}{/}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{Q}\PYG{o}{/}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}
    \PYG{n}{start} \PYG{o}{=} \PYG{n}{timer}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{n}{speed}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{testing\PYGZus{}poly}\PYG{o}{.}\PYG{n}{multiply}\PYG{p}{(}\PYG{n}{testing\PYGZus{}poly}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Multiplying in R\PYGZus{}Q with Q = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{two\PYGZus{}power}\PYG{p}{(}\PYG{n}{Q}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ and N = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{two\PYGZus{}power}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ in }\PYG{l+s+si}{\PYGZob{}}\PYG{p}{(}\PYG{n}{timedelta}\PYG{p}{(}\PYG{n}{seconds} \PYG{o}{=} \PYG{n}{timer}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{start}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{n}{speed}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{Q} \PYG{o}{=} \PYG{n}{Q} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Multiplying in R\PYGZus{}Q with Q = 2\PYGZca{}50 and N = 2\PYGZca{}10 in 0:00:00.058310
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Multiplying in R\PYGZus{}Q with Q = 2\PYGZca{}100 and N = 2\PYGZca{}10 in 0:00:00.061184
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Multiplying in R\PYGZus{}Q with Q = 2\PYGZca{}200 and N = 2\PYGZca{}10 in 0:00:00.067906
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Multiplying in R\PYGZus{}Q with Q = 2\PYGZca{}400 and N = 2\PYGZca{}10 in 0:00:00.095581
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Multiplying in R\PYGZus{}Q with Q = 2\PYGZca{}800 and N = 2\PYGZca{}10 in 0:00:00.170846
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Multiplying in R\PYGZus{}Q with Q = 2\PYGZca{}1600 and N = 2\PYGZca{}10 in 0:00:00.454988
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
We observe that the computation time at least doubles during doubling a large \(Q\).
Note that, for comparably small \(Q\), the running times are more or less equal, since in these cases they greatly depend on \(N\) exclusively.

\sphinxAtStartPar
We conclude that there is a limit, for which the augmentation of the ciphertext modulus \(Q\) is viable.

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{Auxiliary modulus \(p\)}
\end{DUlineblock}

\sphinxAtStartPar
We need an auxiliary modulus \(p\) to scale down the \(\texttt{scaled-mod}\) error during its final rescaling step.
Consider {\hyperref[\detokenize{Thesis:error-size-after-scaled-mod}]{\sphinxcrossref{Theorem 7}}}, which gives rise to the size of \(p\):
\begin{equation*}
\begin{split}p = 5 n N^{5/2} B \log_B(QTnp),\end{split}
\end{equation*}
\sphinxAtStartPar
since the error size after \(\texttt{scaled-mod}\) should be comparable to the RLWE encryption error size \(E\) in the theorem.
We simplify the above with the estimation \(\log_B(p) < \log_B(QTn)\) to \(p := 10 n N^{5/2} B\log_B(QTn)\).

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{Decomposition parameter \(B\)}
\end{DUlineblock}

\sphinxAtStartPar
The choice of \(B\) is somewhat subtle, too, since \(B\) depends on \(p\) and vice versa.
In {\hyperref[\detokenize{Thesis:complexity-of-scaled-mod}]{\sphinxcrossref{Theorem 8}}} we have shown that squaring \(B\) halves the time required for \(\texttt{bootstrapping}\).
Aside from that, \(B\) also occurs during the error discussion and its increase generates larger error sizes.
Thus, for correct decryption (see {\hyperref[\detokenize{Thesis:correct-BFV-decryption}]{\sphinxcrossref{Lemma 4}}}), the error in {\hyperref[\detokenize{Thesis:error-size-after-scaled-mod}]{\sphinxcrossref{Theorem 7}}} must not be greater than \(Qnp/2\).
Since \(p\) already assures the latter, we have plenty of liberty in choosing \(B\).
In fact, it technically could be even larger than \(Q\) itself to boost the runtime (this effect has a limit, see {\hyperref[\detokenize{Thesis:ciphertext-modulus-q}]{\sphinxcrossref{\DUrole{std,std-ref}{Ciphertext modulus Q}}}}).
We will examine this computationally (see {\hyperref[\detokenize{Thesis:runtime-analysis}]{\sphinxcrossref{\DUrole{std,std-ref}{Runtime observations}}}}).

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Wrapper for parameters}
\end{DUlineblock}

\sphinxAtStartPar
Below we define an auxiliary function, which computes all necessary bootstrapping parameters \(\{N,T,Q,B,n,p,c,QTnp\}\), the \(\texttt{key-switch}\) array, and the \(\texttt{blind-rotation-keys}\).
Because knowledge of \(s\) is required, these precomputations need to be run by a secret key holder.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{bootstrapping\PYGZus{}parameters}\PYG{p}{(}\PYG{n}{secret\PYGZus{}key}\PYG{p}{,} \PYG{n}{plaintext\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{ciphertext\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{standard\PYGZus{}deviation}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{N}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{n}\PYG{p}{,} \PYG{n}{p} \PYG{o}{=} \PYG{n+nb}{getattr}\PYG{p}{(}\PYG{n}{secret\PYGZus{}key}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ring\PYGZus{}degree}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{ciphertext\PYGZus{}modulus}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}
    \PYG{n}{B} \PYG{o}{=} \PYG{n}{Q}
    \PYG{n}{gamma} \PYG{o}{=} \PYG{n}{floor}\PYG{p}{(}\PYG{p}{(}\PYG{p}{(}\PYG{n}{Q}\PYG{o}{*}\PYG{p}{(}\PYG{n}{N}\PYG{o}{\PYGZhy{}}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{o}{*}\PYG{n}{N}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{c} \PYG{o}{=} \PYG{n+nb}{min}\PYG{p}{(}\PYG{n}{floor}\PYG{p}{(}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)} \PYG{o}{+} \PYG{n}{gamma}\PYG{o}{/}\PYG{p}{(}\PYG{n}{Q}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{N}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{n}{floor}\PYG{p}{(}\PYG{n}{N}\PYG{o}{/}\PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
    \PYG{k}{while}\PYG{p}{(}\PYG{n}{n} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{c} \PYG{o+ow}{and} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{n} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{n} \PYG{o}{*}\PYG{o}{=} \PYG{l+m+mi}{2}
    \PYG{k}{while}\PYG{p}{(}\PYG{n}{p} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n}{n}\PYG{o}{*}\PYG{p}{(}\PYG{n}{N}\PYG{o}{*}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{n}{B}\PYG{o}{*}\PYG{n}{log}\PYG{p}{(}\PYG{n}{Q}\PYG{o}{*}\PYG{n}{T}\PYG{o}{*}\PYG{n}{n}\PYG{p}{,}\PYG{n}{B}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{p} \PYG{o}{*}\PYG{o}{=} \PYG{l+m+mi}{2}
    \PYG{n}{boot\PYGZus{}modulus} \PYG{o}{=} \PYG{n}{Q}\PYG{o}{*}\PYG{n}{T}\PYG{o}{*}\PYG{n}{n}\PYG{o}{*}\PYG{n}{p}
    \PYG{n}{brk} \PYG{o}{=} \PYG{n}{blind\PYGZus{}rotation\PYGZus{}keys}\PYG{p}{(}\PYG{n}{boot\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{B}\PYG{p}{,} \PYG{n}{standard\PYGZus{}deviation}\PYG{p}{,} \PYG{n}{secret\PYGZus{}key}\PYG{p}{)}
    \PYG{n}{rgsw\PYGZus{}one} \PYG{o}{=} \PYG{n}{get\PYGZus{}trivial\PYGZus{}rgsw\PYGZus{}of\PYGZus{}one}\PYG{p}{(}\PYG{n}{boot\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{B}\PYG{p}{,} \PYG{n}{N}\PYG{p}{)}
    \PYG{n}{key\PYGZus{}switch} \PYG{o}{=} \PYG{n}{key\PYGZus{}switch\PYGZus{}for\PYGZus{}eval\PYGZus{}auto}\PYG{p}{(}\PYG{n}{secret\PYGZus{}key}\PYG{p}{,} \PYG{n}{boot\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{B}\PYG{p}{,} \PYG{n}{standard\PYGZus{}deviation}\PYG{p}{)}
    \PYG{k}{return} \PYG{p}{(}\PYG{n}{N}\PYG{p}{,} \PYG{n}{T}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{B}\PYG{p}{,} \PYG{n}{n}\PYG{p}{,} \PYG{n}{p}\PYG{p}{,} \PYG{n}{c}\PYG{p}{,} \PYG{n}{boot\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{brk}\PYG{p}{,} \PYG{n}{rgsw\PYGZus{}one}\PYG{p}{,} \PYG{n}{key\PYGZus{}switch}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
As the parameters are public information, now any party, which wants to bootstrap a ciphertext, can use the parameter array and the following \(\texttt{bootstrapping-wrapper}\) to perform the refreshing of the error within the ciphertext.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{bootstrapping\PYGZus{}wrapper}\PYG{p}{(}\PYG{n}{ciphertext}\PYG{p}{,} \PYG{n}{parameters}\PYG{p}{,} \PYG{n}{info} \PYG{o}{=} \PYG{k+kc}{None}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{start} \PYG{o}{=} \PYG{n}{timer}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{N}\PYG{p}{,} \PYG{n}{T}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{B}\PYG{p}{,} \PYG{n}{n}\PYG{p}{,} \PYG{n}{p}\PYG{p}{,} \PYG{n}{c}\PYG{p}{,} \PYG{n}{boot\PYGZus{}modulus}\PYG{p}{,} \PYG{n}{brk}\PYG{p}{,} \PYG{n}{rgsw\PYGZus{}one}\PYG{p}{,} \PYG{n}{key\PYGZus{}switch} \PYG{o}{=} \PYG{n}{parameters}
    \PYG{n}{boot} \PYG{o}{=} \PYG{n}{bootstrapping}\PYG{p}{(}\PYG{n}{ciphertext}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{T}\PYG{p}{,} \PYG{n}{p}\PYG{p}{,} \PYG{n}{brk}\PYG{p}{,} \PYG{n}{rgsw\PYGZus{}one}\PYG{p}{,} \PYG{n}{key\PYGZus{}switch}\PYG{p}{,} \PYG{n}{B}\PYG{p}{)}
    \PYG{k}{if} \PYG{n}{info}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Time taken for bootstrapping: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{timedelta}\PYG{p}{(}\PYG{n}{seconds} \PYG{o}{=} \PYG{n}{timer}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{start}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Bootstrapping parameters: Modulus = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{two\PYGZus{}power}\PYG{p}{(}\PYG{n}{Q}\PYG{o}{*}\PYG{n}{n}\PYG{o}{*}\PYG{n}{p}\PYG{o}{*}\PYG{n}{T}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{, B = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{two\PYGZus{}power}\PYG{p}{(}\PYG{n}{B}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{, N = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{two\PYGZus{}power}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{boot} 
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{Testing \(\texttt{bootstrapping}\)}
\end{DUlineblock}

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Correctness}
\end{DUlineblock}

\sphinxAtStartPar
As a proof of concept, we want to test our bootstrapping algorithm by taking a random message and encrypting it, then measuring the error size after having added an error of a certain size.
For that instance, we print the error after bootstrapping, which should ideally be about the same size as a regular encrypting error.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{N}\PYG{p}{,} \PYG{n}{T}\PYG{p}{,} \PYG{n}{Q} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{100}
\PYG{n}{SK}\PYG{p}{,} \PYG{n}{PK} \PYG{o}{=} \PYG{n}{keygen}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{STD}\PYG{p}{)}
\PYG{n}{M} \PYG{o}{=} \PYG{n}{generate\PYGZus{}uniform\PYGZus{}distribution}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{T}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{encryption} \PYG{o}{=} \PYG{n}{encrypt}\PYG{p}{(}\PYG{n}{M}\PYG{p}{,} \PYG{n}{T}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{STD}\PYG{p}{,} \PYG{n}{PK}\PYG{p}{)}
\PYG{n}{unnecessary\PYGZus{}error} \PYG{o}{=} \PYG{n}{generate\PYGZus{}uniform\PYGZus{}distribution}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{Q}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{N}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Q}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{N}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Adding an error of size: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{two\PYGZus{}power}\PYG{p}{(}\PYG{n}{unnecessary\PYGZus{}error}\PYG{o}{.}\PYG{n}{norm}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ within the ciphertext modulus: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{two\PYGZus{}power}\PYG{p}{(}\PYG{n}{Q}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{...}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} 
\PYG{n}{noisy\PYGZus{}ciphertext} \PYG{o}{=} \PYG{p}{[}\PYG{n}{encryption}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{encryption}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{unnecessary\PYGZus{}error}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{)}\PYG{p}{]}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{...to the encryption of the message: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{M}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ and refreshing the obtained noisy ciphertext by bootstrapping...}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{start} \PYG{o}{=} \PYG{n}{timer}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{parameters} \PYG{o}{=} \PYG{n}{bootstrapping\PYGZus{}parameters}\PYG{p}{(}\PYG{n}{SK}\PYG{p}{,} \PYG{n}{T}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{STD}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Time taken for the precomputation: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{timedelta}\PYG{p}{(}\PYG{n}{seconds} \PYG{o}{=} \PYG{n}{timer}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{start}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{refreshed\PYGZus{}ciphertext} \PYG{o}{=} \PYG{n}{bootstrapping\PYGZus{}wrapper}\PYG{p}{(}\PYG{n}{noisy\PYGZus{}ciphertext}\PYG{p}{,} \PYG{n}{parameters}\PYG{p}{,} \PYG{k+kc}{True}\PYG{p}{)}
\PYG{n}{refreshed\PYGZus{}decryption} \PYG{o}{=} \PYG{n}{decrypt}\PYG{p}{(}\PYG{n}{refreshed\PYGZus{}ciphertext}\PYG{p}{,} \PYG{n}{T}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{SK}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Decryption of refreshed ciphertext after bootstrapping: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{refreshed\PYGZus{}decryption}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Still correct? }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{M}\PYG{o}{.}\PYG{n}{is\PYGZus{}equal\PYGZus{}to}\PYG{p}{(}\PYG{n}{refreshed\PYGZus{}decryption}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{refreshed\PYGZus{}error} \PYG{o}{=} \PYG{n}{refreshed\PYGZus{}ciphertext}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{multiply}\PYG{p}{(}\PYG{n}{SK}\PYG{p}{)}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{refreshed\PYGZus{}ciphertext}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{n}{Q}\PYG{p}{)}\PYG{o}{.}\PYG{n}{subtract}\PYG{p}{(}\PYG{n}{M}\PYG{o}{.}\PYG{n}{scalar\PYGZus{}multiply}\PYG{p}{(}\PYG{n}{Q}\PYG{o}{/}\PYG{o}{/}\PYG{n}{T}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Error size after bootstrapping: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{refreshed\PYGZus{}error}\PYG{o}{.}\PYG{n}{mod\PYGZus{}small}\PYG{p}{(}\PYG{n}{Q}\PYG{p}{)}\PYG{o}{.}\PYG{n}{norm}\PYG{p}{(}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Adding an error of size: 2\PYGZca{}94 within the ciphertext modulus: 2\PYGZca{}100...
...to the encryption of the message: x\PYGZca{}13 + x\PYGZca{}11 + x\PYGZca{}10 + x\PYGZca{}9 + x\PYGZca{}8 + x\PYGZca{}7 + x\PYGZca{}6 + x\PYGZca{}4 + x\PYGZca{}2 + 1 and refreshing the obtained noisy ciphertext by bootstrapping...
Time taken for the precomputation: 0:00:00.027394
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Time taken for bootstrapping: 0:00:00.696923
Bootstrapping parameters: Modulus = 2\PYGZca{}223, B = 2\PYGZca{}100, N = 2\PYGZca{}4
Decryption of refreshed ciphertext after bootstrapping: x\PYGZca{}13 + x\PYGZca{}11 + x\PYGZca{}10 + x\PYGZca{}9 + x\PYGZca{}8 + x\PYGZca{}7 + x\PYGZca{}6 + x\PYGZca{}4 + x\PYGZca{}2 + 1
Still correct? True
Error size after bootstrapping: 2
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}\phantomsection\label{\detokenize{Thesis:runtime-analysis}}
\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Runtime observations}
\end{DUlineblock}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{runtime}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,} \PYG{n}{T}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{B}\PYG{p}{,} \PYG{n}{runs}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{SK}\PYG{p}{,} \PYG{n}{PK} \PYG{o}{=} \PYG{n}{keygen}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{n}{CT} \PYG{o}{=} \PYG{p}{[}\PYG{n}{generate\PYGZus{}uniform\PYGZus{}distribution}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{Q}\PYG{o}{/}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{Q}\PYG{o}{/}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{]}\PYG{o}{*}\PYG{l+m+mi}{2} 
    \PYG{n}{parameters} \PYG{o}{=} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{bootstrapping\PYGZus{}parameters}\PYG{p}{(}\PYG{n}{SK}\PYG{p}{,} \PYG{n}{T}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{parameters}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{parameters}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{parameters}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{parameters}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{o}{=} \PYG{n}{N}\PYG{p}{,} \PYG{n}{T}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{B}
    \PYG{n}{start} \PYG{o}{=} \PYG{n}{timer}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{runs}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{bootstrapping\PYGZus{}wrapper}\PYG{p}{(}\PYG{n}{CT}\PYG{p}{,} \PYG{n+nb}{tuple}\PYG{p}{(}\PYG{n}{parameters}\PYG{p}{)}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Running with N = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{two\PYGZus{}power}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{, Q = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{two\PYGZus{}power}\PYG{p}{(}\PYG{n}{Q}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{, B = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{two\PYGZus{}power}\PYG{p}{(}\PYG{n}{B}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ and taking }\PYG{l+s+si}{\PYGZob{}}\PYG{p}{(}\PYG{n}{timer}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{start}\PYG{p}{)}\PYG{o}{/}\PYG{n}{runs}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ seconds.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
With the \(\texttt{runtime}\) procedure, we want to confirm some observations from {\hyperref[\detokenize{Thesis:parameters-for-bootstrapping}]{\sphinxcrossref{\DUrole{std,std-ref}{Parameters for bootstrapping}}}} computationally:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Selecting \(B\) larger than \(Q\) yields a faster running time:

\end{itemize}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{runtime}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{o}{*}\PYG{n}{speed}\PYG{p}{)}
\PYG{n}{runtime}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{200}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{o}{*}\PYG{n}{speed}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Running with N = 2\PYGZca{}2, Q = 2\PYGZca{}100, B = 2\PYGZca{}100 and taking 0.008603536633400017 seconds.
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Running with N = 2\PYGZca{}2, Q = 2\PYGZca{}100, B = 2\PYGZca{}200 and taking 0.0077161744749999345 seconds.
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}\begin{itemize}
\item {} 
\sphinxAtStartPar
Doubling \(N\) multiplies the running time by about a factor 10\sphinxhyphen{}12:

\end{itemize}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{runtime}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{speed}\PYG{p}{)}
\PYG{n}{runtime}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{speed}\PYG{p}{)}
\PYG{n}{runtime}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{speed}\PYG{p}{)}
\PYG{n}{runtime}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{speed}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Running with N = 2\PYGZca{}2, Q = 2\PYGZca{}50, B = 2\PYGZca{}50 and taking 0.007532426806665171 seconds.
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Running with N = 2\PYGZca{}3, Q = 2\PYGZca{}50, B = 2\PYGZca{}50 and taking 0.05812609944333417 seconds.
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Running with N = 2\PYGZca{}4, Q = 2\PYGZca{}50, B = 2\PYGZca{}50 and taking 0.6767606268066689 seconds.
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Running with N = 2\PYGZca{}5, Q = 2\PYGZca{}50, B = 2\PYGZca{}50 and taking 8.406653655 seconds.
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}\begin{itemize}
\item {} 
\sphinxAtStartPar
Squaring \(Q\) along with \(B\) has nearly no impact on the running time for comparably small \(Q\) and \(B\). For large \(Q\) and \(B\) it approximately doubles the time:

\end{itemize}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{runtime}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{25}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{25}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{o}{*}\PYG{n}{speed}\PYG{p}{)}
\PYG{n}{runtime}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{o}{*}\PYG{n}{speed}\PYG{p}{)}
\PYG{n}{runtime}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{500}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{500}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{o}{*}\PYG{n}{speed}\PYG{p}{)}
\PYG{n}{runtime}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{1000}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{1000}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{o}{*}\PYG{n}{speed}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Running with N = 2\PYGZca{}2, Q = 2\PYGZca{}25, B = 2\PYGZca{}25 and taking 0.007967066783300015 seconds.
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Running with N = 2\PYGZca{}2, Q = 2\PYGZca{}50, B = 2\PYGZca{}50 and taking 0.008403664325000046 seconds.
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Running with N = 2\PYGZca{}2, Q = 2\PYGZca{}500, B = 2\PYGZca{}500 and taking 0.022475497808300042 seconds.
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Running with N = 2\PYGZca{}2, Q = 2\PYGZca{}1000, B = 2\PYGZca{}1000 and taking 0.037977714775000004 seconds.
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Application: Homomorphic Comparisons}
\end{DUlineblock}

\sphinxAtStartPar
As the last section, we want to present a simple application, which points out, how more complex homomorphic operations, building on additions and multiplications, can be realized.
Since it is crucial for any advanced computer program to handle if\sphinxhyphen{}statements, we state a basic algorithm, which checks if \(a \ge b\) in ciphertext space and gives the answer in an encrypted binary form.
This method is due to Section 4.B in {[}\hyperlink{cite.Thesis:id79}{Narumanchi \sphinxstyleemphasis{et al.}, 2017}{]}.

\sphinxAtStartPar
More precisely, given two (BFV) ciphertexts \(C_a\) and \(C_a\) including the hidden messages \(a, b \in \Z\), the algorithm outputs a ciphertext \(C_0\) containing the message \(0\) (i.e. true), if \(a \ge b\), and otherwise \(C_1\) (i.e. false).

\sphinxAtStartPar
The idea is to compare the difference \(a-b\) with zero since this works for arbitrary \(a\) and \(b\).
Therefore we select a prime \(p\), such that \(p/2 \ge \abs{a} + \abs{b}\), because then \(a-b \in (-p/2,p/2]\).
Now, for all integers \(y\) in \((-p/2,p/2]\), we determine the polynomial in \(l(y) \in (\Z/p\Z)[y]\) of degree \(p-1\), which satisfies \(f(y) = 0 \mod p\), if \(y \ge 0\), and \(f(y) = 1 \mod p\), if \(y < 0\).
This can be done by Lagrange interpolation followed by a modular reduction by \(p\).

\sphinxAtStartPar
In total, we now define our result ciphertext as \(l(C_a - C_b) = l(C_{a-b})\), which can be evaluated by the (BFV) scheme’s homomorphic addition/multiplication operations.

\sphinxAtStartPar
Below we implement a homomorphic comparison example with \(a,b \in {-1,0,1}\) and \(p = 5\).
Thus we have \(l(y) = 3y^4+3y^3-y\) in this case.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{N}\PYG{p}{,} \PYG{n}{T}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{STD} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{l+m+mi}{1}
\PYG{n}{SK}\PYG{p}{,} \PYG{n}{PK} \PYG{o}{=} \PYG{n}{keygen}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{STD}\PYG{p}{)}
\PYG{n}{rel\PYGZus{}keys} \PYG{o}{=} \PYG{n}{relinearization\PYGZus{}key}\PYG{p}{(}\PYG{n}{Q}\PYG{p}{,} \PYG{n}{Q}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{STD}\PYG{p}{,} \PYG{n}{SK}\PYG{p}{)}

\PYG{n}{a}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{c+c1}{\PYGZsh{} from \PYGZob{}\PYGZhy{}1,0,1\PYGZcb{}}
\PYG{n}{a\PYGZus{}enc} \PYG{o}{=} \PYG{n}{encrypt}\PYG{p}{(}\PYG{n}{generate\PYGZus{}constant\PYGZus{}poly}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,} \PYG{n}{a}\PYG{p}{)}\PYG{p}{,} \PYG{n}{T}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{STD}\PYG{p}{,} \PYG{n}{PK}\PYG{p}{)}
\PYG{n}{b\PYGZus{}enc} \PYG{o}{=} \PYG{n}{encrypt}\PYG{p}{(}\PYG{n}{generate\PYGZus{}constant\PYGZus{}poly}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{,} \PYG{n}{T}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{STD}\PYG{p}{,} \PYG{n}{PK}\PYG{p}{)}
\PYG{n}{difference} \PYG{o}{=} \PYG{n}{subtract}\PYG{p}{(}\PYG{n}{a\PYGZus{}enc}\PYG{p}{,} \PYG{n}{b\PYGZus{}enc}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Evaluating 3*y\PYGZca{}4 + 3*y\PYGZca{}3 \PYGZhy{} y with y = C\PYGZus{}\PYGZob{}a\PYGZhy{}b\PYGZcb{} homomorphically:}
\PYG{n}{y\PYGZus{}squared} \PYG{o}{=} \PYG{n}{multiply}\PYG{p}{(}\PYG{n}{difference}\PYG{p}{,} \PYG{n}{difference}\PYG{p}{,} \PYG{n}{T}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{Q}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{rel\PYGZus{}keys}\PYG{p}{)}
\PYG{n}{y\PYGZus{}to\PYGZus{}the\PYGZus{}three} \PYG{o}{=} \PYG{n}{multiply}\PYG{p}{(}\PYG{n}{y\PYGZus{}squared}\PYG{p}{,} \PYG{n}{difference}\PYG{p}{,} \PYG{n}{T}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{Q}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{rel\PYGZus{}keys}\PYG{p}{)}
\PYG{n}{y\PYGZus{}to\PYGZus{}the\PYGZus{}four} \PYG{o}{=} \PYG{n}{multiply}\PYG{p}{(}\PYG{n}{y\PYGZus{}squared}\PYG{p}{,} \PYG{n}{y\PYGZus{}squared}\PYG{p}{,} \PYG{n}{T}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{Q}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{rel\PYGZus{}keys}\PYG{p}{)}
\PYG{n}{three\PYGZus{}y\PYGZus{}to\PYGZus{}the\PYGZus{}three} \PYG{o}{=} \PYG{n}{rlwe\PYGZus{}multiply\PYGZus{}with\PYGZus{}poly}\PYG{p}{(}\PYG{n}{y\PYGZus{}to\PYGZus{}the\PYGZus{}three}\PYG{p}{,} \PYG{n}{generate\PYGZus{}constant\PYGZus{}poly}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{)}
\PYG{n}{three\PYGZus{}y\PYGZus{}to\PYGZus{}the\PYGZus{}four} \PYG{o}{=} \PYG{n}{rlwe\PYGZus{}multiply\PYGZus{}with\PYGZus{}poly}\PYG{p}{(}\PYG{n}{y\PYGZus{}to\PYGZus{}the\PYGZus{}four}\PYG{p}{,} \PYG{n}{generate\PYGZus{}constant\PYGZus{}poly}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{)}
\PYG{n}{result} \PYG{o}{=} \PYG{n}{add}\PYG{p}{(}\PYG{n}{three\PYGZus{}y\PYGZus{}to\PYGZus{}the\PYGZus{}four}\PYG{p}{,} \PYG{n}{subtract}\PYG{p}{(}\PYG{n}{three\PYGZus{}y\PYGZus{}to\PYGZus{}the\PYGZus{}three}\PYG{p}{,} \PYG{n}{difference}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{)}

\PYG{k}{if} \PYG{n}{decrypt}\PYG{p}{(}\PYG{n}{result}\PYG{p}{,} \PYG{n}{T}\PYG{p}{,} \PYG{n}{Q}\PYG{p}{,} \PYG{n}{SK}\PYG{p}{)}\PYG{o}{.}\PYG{n}{evaluate}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{a}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ greater equal to b = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{b}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{!}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{else}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{a}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ smaller than b = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{b}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{!}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
a = \PYGZhy{}1 smaller than b = 1!
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Remarks:
\begin{itemize}
\item {} 
\sphinxAtStartPar
For large \(p\), the above procedure is quite inefficient, since evaluating \(\mathcal O(p)\) multiplications usually involves many intermediary bootstrapping procedures because of the error growth (see {\hyperref[\detokenize{Thesis:error-after-BFV-multiplication}]{\sphinxcrossref{Theorem 6}}}) and because we have put only the constant coefficient of a message polynomial to use.

\item {} 
\sphinxAtStartPar
Homomorphic comparison could be utilized to formulate a homomorphic division algorithm.
The naïve division algorithm solely consists of comparisons and subtractions, repeated until the quotient is \(0\) (checked by comparison).
However, there are more sophisticated approaches, see e.g. {[}\hyperlink{cite.Thesis:id78}{Okada \sphinxstyleemphasis{et al.}, 2019}{]}.

\end{itemize}

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large Bibliography}
\end{DUlineblock}

\begin{sphinxthebibliography}{LStehle1}
\bibitem[ACC+18]{Thesis:id68}
\sphinxAtStartPar
Martin Albrecht, Melissa Chase, Hao Chen, Jintai Ding, Shafi Goldwasser, Sergey Gorbunov, Shai Halevi, Jeffrey Hoffstein, Kim Laine, Kristin Lauter, Satya Lokam, Daniele Micciancio, Dustin Moody, Travis Morrison, Amit Sahai, and Vinod Vaikuntanathan. Homomorphic encryption security standard. Technical Report, HomomorphicEncryption.org, Toronto, Canada, November 2018.
\bibitem[An21]{Thesis:id63}
\sphinxAtStartPar
J. An. Sample variance of rounded variables. 2021. URL: \sphinxurl{https://arxiv.org/abs/2102.08483}, \sphinxhref{https://doi.org/10.48550/ARXIV.2102.08483}{doi:10.48550/ARXIV.2102.08483}.
\bibitem[BRT20]{Thesis:id76}
\sphinxAtStartPar
Mădălina Bolboceanu, Miruna Roșca, and Radu Țițiu. Homomorphic encryption: a toy implementation in python. \sphinxurl{https://bit-ml.github.io/blog/post/homomorphic-encryption-toy-implementation-in-python/}, 2020.
\bibitem[CKKS17]{Thesis:id69}
\sphinxAtStartPar
Jung Hee Cheon, Andrey Kim, Miran Kim, and Yongsoo Song. Homomorphic encryption for arithmetic of approximate numbers. In Tsuyoshi Takagi and Thomas Peyrin, editors, \sphinxstyleemphasis{Advances in Cryptology – ASIACRYPT 2017}, 409–437. Cham, 2017. Springer International Publishing.
\bibitem[Era20]{Thesis:id75}
\sphinxAtStartPar
Saroja Erabelli. A python library for fully homomorphic encryption. \sphinxurl{https://github.com/sarojaerabelli/py-fhe}, 2020.
\bibitem[FV12]{Thesis:id70}
\sphinxAtStartPar
Junfeng Fan and Frederik Vercauteren. Somewhat practical fully homomorphic encryption. Cryptology ePrint Archive, Paper 2012/144, 2012. \sphinxurl{https://eprint.iacr.org/2012/144}. URL: \sphinxurl{https://eprint.iacr.org/2012/144}.
\bibitem[Gen09]{Thesis:id77}
\sphinxAtStartPar
Craig Gentry. \sphinxstyleemphasis{A fully homomorphic encryption scheme}. PhD thesis, Stanford University, 2009. \sphinxurl{crypto.stanford.edu/craig}.
\bibitem[GSW13]{Thesis:id73}
\sphinxAtStartPar
Craig Gentry, Amit Sahai, and Brent Waters. Homomorphic encryption from learning with errors: conceptually\sphinxhyphen{}simpler, asymptotically\sphinxhyphen{}faster, attribute\sphinxhyphen{}based. Cryptology ePrint Archive, Paper 2013/340, 2013. \sphinxurl{https://eprint.iacr.org/2013/340}. URL: \sphinxurl{https://eprint.iacr.org/2013/340}.
\bibitem[HPS18]{Thesis:id64}
\sphinxAtStartPar
Shai Halevi, Yuriy Polyakov, and Victor Shoup. An improved rns variant of the bfv homomorphic encryption scheme. Cryptology ePrint Archive, Paper 2018/117, 2018. \sphinxurl{https://eprint.iacr.org/2018/117}. URL: \sphinxurl{https://eprint.iacr.org/2018/117}, \sphinxhref{https://doi.org/10.1007/978-3-030-12612-4\_5}{doi:10.1007/978\sphinxhyphen{}3\sphinxhyphen{}030\sphinxhyphen{}12612\sphinxhyphen{}4\_5}.
\bibitem[KDE+21]{Thesis:id72}
\sphinxAtStartPar
Andrey Kim, Maxim Deryabin, Jieun Eom, Rakyong Choi, Yongwoo Lee, Whan Ghang, and Donghoon Yoo. General bootstrapping approach for rlwe\sphinxhyphen{}based homomorphic encryption. Cryptology ePrint Archive, Paper 2021/691, 2021. \sphinxurl{https://eprint.iacr.org/2021/691}. URL: \sphinxurl{https://eprint.iacr.org/2021/691}.
\bibitem[LStehle12]{Thesis:id66}
\sphinxAtStartPar
Adeline Langlois and Damien Stehlé. Hardness of decision (r)lwe for any modulus. \sphinxstyleemphasis{IACR Cryptol. ePrint Arch.}, 2012:91, 2012.
\bibitem[LMK+22]{Thesis:id67}
\sphinxAtStartPar
Yongwoo Lee, Daniele Micciancio, Andrey Kim, Rakyong Choi, Maxim Deryabin, Jieun Eom, and Donghoon Yoo. Efficient fhew bootstrapping with small evaluation keys, and applications to threshold homomorphic encryption. Cryptology ePrint Archive, Paper 2022/198, 2022. \sphinxurl{https://eprint.iacr.org/2022/198}. URL: \sphinxurl{https://eprint.iacr.org/2022/198}.
\bibitem[LPR13]{Thesis:id71}
\sphinxAtStartPar
Vadim Lyubashevsky, Chris Peikert, and Oded Regev. A toolkit for ring\sphinxhyphen{}lwe cryptography. Cryptology ePrint Archive, Paper 2013/293, 2013. \sphinxurl{https://eprint.iacr.org/2013/293}. URL: \sphinxurl{https://eprint.iacr.org/2013/293}.
\bibitem[MP20]{Thesis:id74}
\sphinxAtStartPar
Daniele Micciancio and Yuriy Polyakov. Bootstrapping in fhew\sphinxhyphen{}like cryptosystems. Cryptology ePrint Archive, Paper 2020/086, 2020. \sphinxurl{https://eprint.iacr.org/2020/086}. URL: \sphinxurl{https://eprint.iacr.org/2020/086}.
\bibitem[NGEG17]{Thesis:id79}
\sphinxAtStartPar
Harika Narumanchi, Dishant Goyal, Nitesh Emmadi, and Praveen Gauravaram. Performance analysis of sorting of fhe data: integer\sphinxhyphen{}wise comparison vs bit\sphinxhyphen{}wise comparison. In \sphinxstyleemphasis{2017 IEEE 31st International Conference on Advanced Information Networking and Applications (AINA)}, volume, 902–908. 2017. \sphinxhref{https://doi.org/10.1109/AINA.2017.85}{doi:10.1109/AINA.2017.85}.
\bibitem[OCHK19]{Thesis:id78}
\sphinxAtStartPar
Hiroki Okada, Carlos Cid, Seira Hidano, and Shinsaku Kiyomoto. Linear depth integer\sphinxhyphen{}wise homomorphic division. In Olivier Blazy and Chan Yeob Yeun, editors, \sphinxstyleemphasis{Information Security Theory and Practice}, 91–106. Cham, 2019. Springer International Publishing.
\bibitem[Pei15]{Thesis:id65}
\sphinxAtStartPar
Chris Peikert. A decade of lattice cryptography. Cryptology ePrint Archive, Paper 2015/939, 2015. \sphinxurl{https://eprint.iacr.org/2015/939}. URL: \sphinxurl{https://eprint.iacr.org/2015/939}.
\bibitem[Tri84]{Thesis:id62}
\sphinxAtStartPar
A. R. Tricker. Effects of rounding on the moments of a probability distribution. \sphinxstyleemphasis{Journal of the Royal Statistical Society. Series D (The Statistician)}, 33(4):381–390, 1984. URL: \sphinxurl{http://www.jstor.org/stable/2987741} (visited on 2022\sphinxhyphen{}09\sphinxhyphen{}21).
\end{sphinxthebibliography}






\renewcommand{\indexname}{Proof Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{RLWE\sphinxhyphen{}distribution}
\item\relax\sphinxstyleindexentry{RLWE\sphinxhyphen{}distribution}\sphinxstyleindexextra{Thesis}\sphinxstyleindexpageref{Thesis:\detokenize{RLWE-distribution}}
\indexspace
\bigletter{RLWE\sphinxhyphen{}security}
\item\relax\sphinxstyleindexentry{RLWE\sphinxhyphen{}security}\sphinxstyleindexextra{Thesis}\sphinxstyleindexpageref{Thesis:\detokenize{RLWE-security}}
\indexspace
\bigletter{R\_integral}
\item\relax\sphinxstyleindexentry{R\_integral}\sphinxstyleindexextra{Thesis}\sphinxstyleindexpageref{Thesis:\detokenize{R_integral}}
\indexspace
\bigletter{approximate\sphinxhyphen{}shortest\sphinxhyphen{}vector\sphinxhyphen{}problem}
\item\relax\sphinxstyleindexentry{approximate\sphinxhyphen{}shortest\sphinxhyphen{}vector\sphinxhyphen{}problem}\sphinxstyleindexextra{Thesis}\sphinxstyleindexpageref{Thesis:\detokenize{approximate-shortest-vector-problem}}
\indexspace
\bigletter{blind\sphinxhyphen{}rotation\sphinxhyphen{}error}
\item\relax\sphinxstyleindexentry{blind\sphinxhyphen{}rotation\sphinxhyphen{}error}\sphinxstyleindexextra{Thesis}\sphinxstyleindexpageref{Thesis:\detokenize{blind-rotation-error}}
\indexspace
\bigletter{complexity\sphinxhyphen{}of\sphinxhyphen{}scaled\sphinxhyphen{}mod}
\item\relax\sphinxstyleindexentry{complexity\sphinxhyphen{}of\sphinxhyphen{}scaled\sphinxhyphen{}mod}\sphinxstyleindexextra{Thesis}\sphinxstyleindexpageref{Thesis:\detokenize{complexity-of-scaled-mod}}
\indexspace
\bigletter{correct\sphinxhyphen{}BFV\sphinxhyphen{}decryption}
\item\relax\sphinxstyleindexentry{correct\sphinxhyphen{}BFV\sphinxhyphen{}decryption}\sphinxstyleindexextra{Thesis}\sphinxstyleindexpageref{Thesis:\detokenize{correct-BFV-decryption}}
\indexspace
\bigletter{decision\sphinxhyphen{}RLWE}
\item\relax\sphinxstyleindexentry{decision\sphinxhyphen{}RLWE}\sphinxstyleindexextra{Thesis}\sphinxstyleindexpageref{Thesis:\detokenize{decision-RLWE}}
\indexspace
\bigletter{discrete\sphinxhyphen{}variance}
\item\relax\sphinxstyleindexentry{discrete\sphinxhyphen{}variance}\sphinxstyleindexextra{Thesis}\sphinxstyleindexpageref{Thesis:\detokenize{discrete-variance}}
\indexspace
\bigletter{error\sphinxhyphen{}after\sphinxhyphen{}BFV\sphinxhyphen{}encryption}
\item\relax\sphinxstyleindexentry{error\sphinxhyphen{}after\sphinxhyphen{}BFV\sphinxhyphen{}encryption}\sphinxstyleindexextra{Thesis}\sphinxstyleindexpageref{Thesis:\detokenize{error-after-BFV-encryption}}
\indexspace
\bigletter{error\sphinxhyphen{}after\sphinxhyphen{}BFV\sphinxhyphen{}multiplication}
\item\relax\sphinxstyleindexentry{error\sphinxhyphen{}after\sphinxhyphen{}BFV\sphinxhyphen{}multiplication}\sphinxstyleindexextra{Thesis}\sphinxstyleindexpageref{Thesis:\detokenize{error-after-BFV-multiplication}}
\indexspace
\bigletter{error\sphinxhyphen{}after\sphinxhyphen{}rlwe\sphinxhyphen{}x\sphinxhyphen{}scalar\sphinxhyphen{}multiply}
\item\relax\sphinxstyleindexentry{error\sphinxhyphen{}after\sphinxhyphen{}rlwe\sphinxhyphen{}x\sphinxhyphen{}scalar\sphinxhyphen{}multiply}\sphinxstyleindexextra{Thesis}\sphinxstyleindexpageref{Thesis:\detokenize{error-after-rlwe-x-scalar-multiply}}
\indexspace
\bigletter{error\sphinxhyphen{}after\sphinxhyphen{}star\sphinxhyphen{}multiplication}
\item\relax\sphinxstyleindexentry{error\sphinxhyphen{}after\sphinxhyphen{}star\sphinxhyphen{}multiplication}\sphinxstyleindexextra{Thesis}\sphinxstyleindexpageref{Thesis:\detokenize{error-after-star-multiplication}}
\indexspace
\bigletter{error\sphinxhyphen{}function}
\item\relax\sphinxstyleindexentry{error\sphinxhyphen{}function}\sphinxstyleindexextra{Thesis}\sphinxstyleindexpageref{Thesis:\detokenize{error-function}}
\indexspace
\bigletter{error\sphinxhyphen{}size\sphinxhyphen{}after\sphinxhyphen{}scaled\sphinxhyphen{}mod}
\item\relax\sphinxstyleindexentry{error\sphinxhyphen{}size\sphinxhyphen{}after\sphinxhyphen{}scaled\sphinxhyphen{}mod}\sphinxstyleindexextra{Thesis}\sphinxstyleindexpageref{Thesis:\detokenize{error-size-after-scaled-mod}}
\indexspace
\bigletter{multiplication\sphinxhyphen{}bound\sphinxhyphen{}gaussian\sphinxhyphen{}ternary}
\item\relax\sphinxstyleindexentry{multiplication\sphinxhyphen{}bound\sphinxhyphen{}gaussian\sphinxhyphen{}ternary}\sphinxstyleindexextra{Thesis}\sphinxstyleindexpageref{Thesis:\detokenize{multiplication-bound-gaussian-ternary}}
\indexspace
\bigletter{multiplication\sphinxhyphen{}bound\sphinxhyphen{}uniform\sphinxhyphen{}ternary}
\item\relax\sphinxstyleindexentry{multiplication\sphinxhyphen{}bound\sphinxhyphen{}uniform\sphinxhyphen{}ternary}\sphinxstyleindexextra{Thesis}\sphinxstyleindexpageref{Thesis:\detokenize{multiplication-bound-uniform-ternary}}
\indexspace
\bigletter{norm\sphinxhyphen{}bound\sphinxhyphen{}adding\_R}
\item\relax\sphinxstyleindexentry{norm\sphinxhyphen{}bound\sphinxhyphen{}adding\_R}\sphinxstyleindexextra{Thesis}\sphinxstyleindexpageref{Thesis:\detokenize{norm-bound-adding_R}}
\indexspace
\bigletter{property\sphinxhyphen{}error\sphinxhyphen{}function}
\item\relax\sphinxstyleindexentry{property\sphinxhyphen{}error\sphinxhyphen{}function}\sphinxstyleindexextra{Thesis}\sphinxstyleindexpageref{Thesis:\detokenize{property-error-function}}
\indexspace
\bigletter{relinearization\sphinxhyphen{}error}
\item\relax\sphinxstyleindexentry{relinearization\sphinxhyphen{}error}\sphinxstyleindexextra{Thesis}\sphinxstyleindexpageref{Thesis:\detokenize{relinearization-error}}
\indexspace
\bigletter{sampling\sphinxhyphen{}bound}
\item\relax\sphinxstyleindexentry{sampling\sphinxhyphen{}bound}\sphinxstyleindexextra{Thesis}\sphinxstyleindexpageref{Thesis:\detokenize{sampling-bound}}
\indexspace
\bigletter{uniform\sphinxhyphen{}times\sphinxhyphen{}ternary}
\item\relax\sphinxstyleindexentry{uniform\sphinxhyphen{}times\sphinxhyphen{}ternary}\sphinxstyleindexextra{Thesis}\sphinxstyleindexpageref{Thesis:\detokenize{uniform-times-ternary}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}