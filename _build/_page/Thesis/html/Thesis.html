
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>A survey on modern fully homomorphic encryption &#8212; Thesis (M.Sc.)</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" href="_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/proof.css" />
    <link rel="stylesheet" type="text/css" href="_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint single-page" id="site-navigation">
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
    </div>
    <div class="header-article__right">
<div class="menu-dropdown menu-dropdown-launch-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Launch interactive content">
      <i class="fas fa-rocket"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://mybinder.org/v2/gh/robinkoestler/A-survey-on-modern-fully-homomorphic-encryption/main?urlpath=tree/Thesis.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Launch on Binder"
>
  

<span class="headerbtn__icon-container">
  
    <img src="_static/images/logo_binder.svg">
  </span>
<span class="headerbtn__text-container">Binder</span>
</a>

      </li>
      
      <li>
        
<button onclick="initThebeSBT()"
  class="headerbtn headerbtn-launch-thebe"
  data-toggle="tooltip"
data-placement="left"
title="Launch Thebe"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-play"></i>
  </span>
<span class="headerbtn__text-container">Live Code</span>
</button>

      </li>
      
    </ul>
  </div>
</div>

<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>

<div class="menu-dropdown menu-dropdown-repository-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Source repositories">
      <i class="fab fa-github"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://github.com/robinkoestler/A-survey-on-modern-fully-homomorphic-encryption"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Source repository"
>
  

<span class="headerbtn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="headerbtn__text-container">repository</span>
</a>

      </li>
      
      <li>
        <a href="https://github.com/robinkoestler/A-survey-on-modern-fully-homomorphic-encryption/issues/new?title=Issue%20on%20page%20%2FThesis.html&body=Your%20issue%20content%20here."
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Open an issue"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="headerbtn__text-container">open issue</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<div class="menu-dropdown menu-dropdown-download-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Download this page">
      <i class="fas fa-download"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="_sources/Thesis.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Download source file"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="headerbtn__text-container">.ipynb</span>
</a>

      </li>
      
      <li>
        
<button onclick="printPdf(this)"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="left"
title="Print to PDF"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="headerbtn__text-container">.pdf</span>
</button>

      </li>
      
    </ul>
  </div>
</div>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <ul class="visible nav section-nav flex-column">
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#">
   A survey on modern fully homomorphic encryption
  </a>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#introduction">
   Introduction
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#fully-homomorphic-encryption">
     Fully homomorphic encryption
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#summary-of-the-thesis">
     Summary of the thesis
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#notation">
     Notation
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#implementation-details">
     Implementation details
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#ring-learning-with-errors-rlwe">
   Ring learning with errors (RLWE)
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#the-ring-r">
     The ring
     <span class="math notranslate nohighlight">
      \(R\)
     </span>
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#the-modular-variant-of-the-ring-r">
     The modular variant of the ring
     <span class="math notranslate nohighlight">
      \(R\)
     </span>
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#size-and-norm-of-ring-elements">
     Size and norm of ring elements
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#background-on-probability-theory">
     Background on probability theory
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#occurring-distributions">
       Occurring distributions
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#the-error-function-mathrm-erf">
       The error function
       <span class="math notranslate nohighlight">
        \(\mathrm{erf}\)
       </span>
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#bounds-for-the-normal-distribution">
       Bounds for the normal distribution
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#bound-for-adding-two-r-elements">
       Bound for adding two
       <span class="math notranslate nohighlight">
        \(R\)
       </span>
       -elements
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#bound-for-multiplying-two-r-elements">
       Bound for multiplying two
       <span class="math notranslate nohighlight">
        \(R\)
       </span>
       -elements
      </a>
      <ul class="nav section-nav flex-column">
       <li class="toc-h4 nav-item toc-entry">
        <a class="reference internal nav-link" href="#the-case-uniform-times-ternary">
         The case “uniform” times “ternary”
        </a>
       </li>
       <li class="toc-h4 nav-item toc-entry">
        <a class="reference internal nav-link" href="#the-case-gaussian-times-ternary">
         The case “Gaussian” times “ternary”
        </a>
       </li>
       <li class="toc-h4 nav-item toc-entry">
        <a class="reference internal nav-link" href="#conclusion-on-the-expansion-factor">
         Conclusion on the expansion factor
        </a>
       </li>
      </ul>
     </li>
    </ul>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#security">
     Security
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#the-decision-rlwe-problem">
       The Decision-RLWE problem
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#background-on-lattices">
       Background on lattices
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#remarks-on-the-security-framework-for-fhe">
       Remarks on the security framework for FHE
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#the-bfv-scheme">
   The BFV scheme
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#asymmetric-key-generation">
     Asymmetric key generation
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#description-of-the-key-generation">
       Description of the key generation
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#encryption">
     Encryption
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#notion-of-bfv-ciphertexts">
       Notion of BFV ciphertexts
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#error-after-bfv-encryption">
       Error after BFV encryption
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#decryption">
     Decryption
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#a-criterion-for-correct-decryption">
       A criterion for correct decryption
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#adding-ciphertexts">
     Adding ciphertexts
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#number-of-possible-additions">
       Number of possible additions
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#parameter-impact">
       Parameter impact
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#multiplying-ciphertexts">
     Multiplying ciphertexts
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#overview">
       Overview
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#motivation">
       Motivation
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#relinearization-keys">
       Relinearization Keys
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#core-of-multiplying">
       Core of multiplying
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#error-analysis">
       Error analysis
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#preparations-for-bootstrapping">
   Preparations for bootstrapping
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#rlwe-ciphertexts">
     RLWE ciphertexts
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id38">
       Motivation
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#operations-on-rlwe-ciphertexts">
       Operations on RLWE ciphertexts
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id41">
     RLWE’ ciphertexts
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id42">
       Operations on RLWE’ ciphertexts
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#rgsw-ciphertexts">
     RGSW ciphertexts
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#operations-on-rgsw-ciphertexts">
       Operations on RGSW ciphertexts
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#the-star-multiplication">
       The star multiplication
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#the-extended-star-multiplication">
       The extended star multiplication
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#automorphisms-of-r">
     Automorphisms of
     <span class="math notranslate nohighlight">
      \(R\)
     </span>
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#key-switching">
       Key switching
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#evaluating-automorphism">
       Evaluating automorphism
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#rescaling">
     Rescaling
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#bootstrapping">
   Bootstrapping
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#the-texttt-scaled-mod-procedure">
     The
     <span class="math notranslate nohighlight">
      \(\texttt{scaled-mod}\)
     </span>
     procedure
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#step-1-extraction-of-lwe-ciphertexts">
     Step 1: Extraction of LWE ciphertexts
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#step-2-blind-rotation">
     Step 2: Blind rotation
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#rotation-function">
       Rotation function
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#blind-rotation-keys">
       Blind rotation keys
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#blind-rotation-algorithm">
       Blind rotation algorithm
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#error-discussion">
       Error discussion
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#sparseness-after-blind-rotation">
       Sparseness after blind rotation
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#step-3-repacking">
     Step 3: Repacking
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#simple-merging-from-sparseness">
       Simple merging from sparseness
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#merging-via-automorphisms">
       Merging via automorphisms
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#analysis-of-texttt-scaled-mod">
     Analysis of
     <span class="math notranslate nohighlight">
      \(\texttt{scaled-mod}\)
     </span>
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id50">
       Error analysis
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#computational-complexity">
       Computational complexity
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#adapting-texttt-scaled-mod-to-bfv-encoding">
     Adapting
     <span class="math notranslate nohighlight">
      \(\texttt{scaled-mod}\)
     </span>
     to BFV encoding
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#removing-the-big-error">
       Removing the big error
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#restoring-m-after-texttt-scaled-mod">
       Restoring
       <span class="math notranslate nohighlight">
        \(m\)
       </span>
       after
       <span class="math notranslate nohighlight">
        \(\texttt{scaled-mod}\)
       </span>
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#parameters-for-bootstrapping">
     Parameters for bootstrapping
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#message-length-n">
       Message length
       <span class="math notranslate nohighlight">
        \(N\)
       </span>
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#plaintext-modulus-t">
       Plaintext modulus
       <span class="math notranslate nohighlight">
        \(T\)
       </span>
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#ciphertext-modulus-q">
       Ciphertext modulus
       <span class="math notranslate nohighlight">
        \(Q\)
       </span>
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#auxiliary-modulus-p">
       Auxiliary modulus
       <span class="math notranslate nohighlight">
        \(p\)
       </span>
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#decomposition-parameter-b">
       Decomposition parameter
       <span class="math notranslate nohighlight">
        \(B\)
       </span>
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#wrapper-for-parameters">
       Wrapper for parameters
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#testing-texttt-bootstrapping">
     Testing
     <span class="math notranslate nohighlight">
      \(\texttt{bootstrapping}\)
     </span>
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#correctness">
       Correctness
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#runtime-observations">
       Runtime observations
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#application-homomorphic-comparisons">
     Application: Homomorphic Comparisons
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#bibliography">
   Bibliography
  </a>
 </li>
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>A survey on modern fully homomorphic encryption</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#">
   A survey on modern fully homomorphic encryption
  </a>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#introduction">
   Introduction
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#fully-homomorphic-encryption">
     Fully homomorphic encryption
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#summary-of-the-thesis">
     Summary of the thesis
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#notation">
     Notation
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#implementation-details">
     Implementation details
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#ring-learning-with-errors-rlwe">
   Ring learning with errors (RLWE)
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#the-ring-r">
     The ring
     <span class="math notranslate nohighlight">
      \(R\)
     </span>
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#the-modular-variant-of-the-ring-r">
     The modular variant of the ring
     <span class="math notranslate nohighlight">
      \(R\)
     </span>
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#size-and-norm-of-ring-elements">
     Size and norm of ring elements
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#background-on-probability-theory">
     Background on probability theory
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#occurring-distributions">
       Occurring distributions
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#the-error-function-mathrm-erf">
       The error function
       <span class="math notranslate nohighlight">
        \(\mathrm{erf}\)
       </span>
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#bounds-for-the-normal-distribution">
       Bounds for the normal distribution
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#bound-for-adding-two-r-elements">
       Bound for adding two
       <span class="math notranslate nohighlight">
        \(R\)
       </span>
       -elements
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#bound-for-multiplying-two-r-elements">
       Bound for multiplying two
       <span class="math notranslate nohighlight">
        \(R\)
       </span>
       -elements
      </a>
      <ul class="nav section-nav flex-column">
       <li class="toc-h4 nav-item toc-entry">
        <a class="reference internal nav-link" href="#the-case-uniform-times-ternary">
         The case “uniform” times “ternary”
        </a>
       </li>
       <li class="toc-h4 nav-item toc-entry">
        <a class="reference internal nav-link" href="#the-case-gaussian-times-ternary">
         The case “Gaussian” times “ternary”
        </a>
       </li>
       <li class="toc-h4 nav-item toc-entry">
        <a class="reference internal nav-link" href="#conclusion-on-the-expansion-factor">
         Conclusion on the expansion factor
        </a>
       </li>
      </ul>
     </li>
    </ul>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#security">
     Security
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#the-decision-rlwe-problem">
       The Decision-RLWE problem
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#background-on-lattices">
       Background on lattices
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#remarks-on-the-security-framework-for-fhe">
       Remarks on the security framework for FHE
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#the-bfv-scheme">
   The BFV scheme
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#asymmetric-key-generation">
     Asymmetric key generation
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#description-of-the-key-generation">
       Description of the key generation
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#encryption">
     Encryption
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#notion-of-bfv-ciphertexts">
       Notion of BFV ciphertexts
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#error-after-bfv-encryption">
       Error after BFV encryption
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#decryption">
     Decryption
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#a-criterion-for-correct-decryption">
       A criterion for correct decryption
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#adding-ciphertexts">
     Adding ciphertexts
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#number-of-possible-additions">
       Number of possible additions
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#parameter-impact">
       Parameter impact
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#multiplying-ciphertexts">
     Multiplying ciphertexts
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#overview">
       Overview
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#motivation">
       Motivation
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#relinearization-keys">
       Relinearization Keys
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#core-of-multiplying">
       Core of multiplying
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#error-analysis">
       Error analysis
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#preparations-for-bootstrapping">
   Preparations for bootstrapping
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#rlwe-ciphertexts">
     RLWE ciphertexts
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id38">
       Motivation
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#operations-on-rlwe-ciphertexts">
       Operations on RLWE ciphertexts
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id41">
     RLWE’ ciphertexts
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id42">
       Operations on RLWE’ ciphertexts
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#rgsw-ciphertexts">
     RGSW ciphertexts
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#operations-on-rgsw-ciphertexts">
       Operations on RGSW ciphertexts
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#the-star-multiplication">
       The star multiplication
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#the-extended-star-multiplication">
       The extended star multiplication
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#automorphisms-of-r">
     Automorphisms of
     <span class="math notranslate nohighlight">
      \(R\)
     </span>
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#key-switching">
       Key switching
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#evaluating-automorphism">
       Evaluating automorphism
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#rescaling">
     Rescaling
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#bootstrapping">
   Bootstrapping
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#the-texttt-scaled-mod-procedure">
     The
     <span class="math notranslate nohighlight">
      \(\texttt{scaled-mod}\)
     </span>
     procedure
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#step-1-extraction-of-lwe-ciphertexts">
     Step 1: Extraction of LWE ciphertexts
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#step-2-blind-rotation">
     Step 2: Blind rotation
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#rotation-function">
       Rotation function
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#blind-rotation-keys">
       Blind rotation keys
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#blind-rotation-algorithm">
       Blind rotation algorithm
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#error-discussion">
       Error discussion
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#sparseness-after-blind-rotation">
       Sparseness after blind rotation
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#step-3-repacking">
     Step 3: Repacking
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#simple-merging-from-sparseness">
       Simple merging from sparseness
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#merging-via-automorphisms">
       Merging via automorphisms
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#analysis-of-texttt-scaled-mod">
     Analysis of
     <span class="math notranslate nohighlight">
      \(\texttt{scaled-mod}\)
     </span>
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id50">
       Error analysis
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#computational-complexity">
       Computational complexity
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#adapting-texttt-scaled-mod-to-bfv-encoding">
     Adapting
     <span class="math notranslate nohighlight">
      \(\texttt{scaled-mod}\)
     </span>
     to BFV encoding
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#removing-the-big-error">
       Removing the big error
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#restoring-m-after-texttt-scaled-mod">
       Restoring
       <span class="math notranslate nohighlight">
        \(m\)
       </span>
       after
       <span class="math notranslate nohighlight">
        \(\texttt{scaled-mod}\)
       </span>
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#parameters-for-bootstrapping">
     Parameters for bootstrapping
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#message-length-n">
       Message length
       <span class="math notranslate nohighlight">
        \(N\)
       </span>
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#plaintext-modulus-t">
       Plaintext modulus
       <span class="math notranslate nohighlight">
        \(T\)
       </span>
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#ciphertext-modulus-q">
       Ciphertext modulus
       <span class="math notranslate nohighlight">
        \(Q\)
       </span>
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#auxiliary-modulus-p">
       Auxiliary modulus
       <span class="math notranslate nohighlight">
        \(p\)
       </span>
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#decomposition-parameter-b">
       Decomposition parameter
       <span class="math notranslate nohighlight">
        \(B\)
       </span>
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#wrapper-for-parameters">
       Wrapper for parameters
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#testing-texttt-bootstrapping">
     Testing
     <span class="math notranslate nohighlight">
      \(\texttt{bootstrapping}\)
     </span>
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#correctness">
       Correctness
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#runtime-observations">
       Runtime observations
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#application-homomorphic-comparisons">
     Application: Homomorphic Comparisons
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#bibliography">
   Bibliography
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <section class="tex2jax_ignore mathjax_ignore" id="a-survey-on-modern-fully-homomorphic-encryption">
<h1>A survey on modern fully homomorphic encryption<a class="headerlink" href="#a-survey-on-modern-fully-homomorphic-encryption" title="Permalink to this headline">#</a></h1>
<div class="math notranslate nohighlight">
\[\newcommand{\norm}[1]{\left\lvert\left\lvert #1 \right\rvert\right\rvert_\infty}
\newcommand{\abs}[1]{\left\lvert #1 \right\rvert}
\newcommand{\round}[1]{\left\lfloor #1 \right\rceil}
\newcommand{\Z}{\mathbb Z}
\renewcommand{\P}{\mathbb P}
\newcommand{\R}{\mathbb R}
\newcommand{\Q}{\mathbb Q}
\newcommand{\RLWE}{\mathrm{RLWE}}
\newcommand{\RLWEx}{\mathrm{RLWE'}}
\newcommand{\RGSW}{\mathrm{RGSW}}\]</div>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="introduction">
<span id="id1"></span><h1>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">#</a></h1>
<section id="fully-homomorphic-encryption">
<h2>Fully homomorphic encryption<a class="headerlink" href="#fully-homomorphic-encryption" title="Permalink to this headline">#</a></h2>
<p>Fully homomorphic encryption (FHE) has been a major field of research in the area of cryptography in recent years.
In a simple notion, its objective can be described as performing operations on data, which itself is securely hidden in an encryption (ciphertext).
For this reason, FHE features a broad range of applications, e.g. secure cloud computing.</p>
<p>The two homomorphic operations, which are mainly considered, are additions and multiplications.
This is sufficient since technically every deterministic algorithm can be expressed by NAND gates.
A NAND gate for two bits <span class="math notranslate nohighlight">\(b_1,b_2 \in \{0,1\}\)</span> is defined as <span class="math notranslate nohighlight">\(\mathrm{NAND}(b_1,b_2) = 1 - b_1b_2 \in \{0,1\}\)</span> and thus only requires one addition and one multiplication modulo 2.</p>
<p>In general, the modern FHE approach relies on encryptions, which are based upon errors.
These errors gradually increase during homomorphic operations and there is a bound in error size to which extent a correct decryption is still possible.
Therefore we require a procedure of reducing an accumulated error to its initial size (comparable to a “fresh” encryption error), and in doing so, arbitrarily many homomorphic operations (FHE) become achievable.
Gentry, who published the first FHE scheme in <span id="id2">[<a class="reference internal" href="#id74" title="Craig Gentry. A fully homomorphic encryption scheme. PhD thesis, Stanford University, 2009. crypto.stanford.edu/craig.">Gentry, 2009</a>]</span>, named this procedure bootstrapping.</p>
<p>For more (historical) information about FHE see e.g. Section 6.1. in <span id="id3">[<a class="reference internal" href="#id62" title="Chris Peikert. A decade of lattice cryptography. Cryptology ePrint Archive, Paper 2015/939, 2015. https://eprint.iacr.org/2015/939. URL: https://eprint.iacr.org/2015/939.">Peikert, 2015</a>]</span>.</p>
</section>
<section id="summary-of-the-thesis">
<h2>Summary of the thesis<a class="headerlink" href="#summary-of-the-thesis" title="Permalink to this headline">#</a></h2>
<p>The thesis is organized as follows:</p>
<ul class="simple">
<li><p>In the rest of chapter 1, the <a class="reference internal" href="#introduction"><span class="std std-ref">Introduction</span></a>, we provide notation and implementation details.</p></li>
<li><p>In Chapter 2, <a class="reference internal" href="#ring-learning-with-errors"><span class="std std-ref">Ring learning with errors (RLWE)</span></a>, we explore the framework of the state-of-the-art notion of (RLWE) ciphertexts.
In doing so, we first investigate the properties of the ring <span class="math notranslate nohighlight">\(R\)</span> and its modular arithmetic variants, which serve as plaintext/ciphertext spaces.
We proceed to define a measure, i.e. <span class="math notranslate nohighlight">\(\norm \cdot\)</span>, to keep track of the “size” of ring elements, e.g. the errors required for encryptions.
We also thoroughly analyse the probabilistic nature of <span class="math notranslate nohighlight">\(\norm \cdot\)</span>-bounds during adding/multiplying ring elements, as this later helps us to properly understand error growth in various contexts.
Lastly, we give a decent overview of security terms and definitions connected to modern ring learning with errors cryptosystems.</p></li>
<li><p>In Chapter 3, <a class="reference internal" href="#the-bfv-scheme"><span class="std std-ref">The BFV scheme</span></a>, we examine the underlying encoding scheme (published in <span id="id4">[<a class="reference internal" href="#id67" title="Junfeng Fan and Frederik Vercauteren. Somewhat practical fully homomorphic encryption. Cryptology ePrint Archive, Paper 2012/144, 2012. https://eprint.iacr.org/2012/144. URL: https://eprint.iacr.org/2012/144.">Fan and Vercauteren, 2012</a>]</span>), which provides algorithms for (secret/public) key-generation, encryption, decryption, addition and multiplication of ciphertexts.
We especially focus on the error growth during the homomorphic operations, since these results heavily influence the overall running time, if one thinks of bootstrapping as an expensive intermission between performing additions/multiplications.
For that matter, we derive a bound for correct decryption and analyse the performance (depending on the choice of parameters) computationally.</p></li>
<li><p>In Chapter 4, <a class="reference internal" href="#preparations-for-bootstrapping"><span class="std std-ref">Preparations for bootstrapping</span></a>, we establish methods to limit the error growth during multiplication, which is mandatory for our bootstrapping algorithm to be functional.
To achieve this, we introduce alterations/extensions of the fundamental RLWE ciphertexts and analyse the corresponding algorithms.
Furthermore, we investigate the two common auxiliary operations automorphism evaluation and rescaling.</p></li>
<li><p>In Chapter 5, <a class="reference internal" href="#bootstrapping"><span class="std std-ref">Bootstrapping</span></a>, we finally present the core algorithm (published in <span id="id5">[<a class="reference internal" href="#id69" title="Andrey Kim, Maxim Deryabin, Jieun Eom, Rakyong Choi, Yongwoo Lee, Whan Ghang, and Donghoon Yoo. General bootstrapping approach for rlwe-based homomorphic encryption. Cryptology ePrint Archive, Paper 2021/691, 2021. https://eprint.iacr.org/2021/691. URL: https://eprint.iacr.org/2021/691.">Kim <em>et al.</em>, 2021</a>]</span>), which itself primarily contains the auxiliary part <span class="math notranslate nohighlight">\(\texttt{scaled-mod}\)</span>, whose target is the realization of a non-trivial multiplication with a large constant.
Splitting up the latter algorithm into three parts and also splitting up the problem into a large magnitude of subproblems will reveal, why bootstrapping is a computationally costly procedure after all.
We conclude the description of the bootstrapping procedure by adapting it to the employed scheme of encoding, i.e. BFV.
During the entire chapter, we will particularly emphasize a detailed error discussion, the (optimal) parameter selection, and the runtime analysis.
As a proof of concept, we computationally review the bootstrapping scheme by verifying the correctness, inspecting the runtime, and rechecking the parameter selection.
At last, we look into a simple application of fully homomorphic encryption, i.e. how to realize a more complex homomorphic operation, namely integer comparison e.g. used for the evaluation of if-statements.</p></li>
</ul>
</section>
<section id="notation">
<h2>Notation<a class="headerlink" href="#notation" title="Permalink to this headline">#</a></h2>
<ul class="simple">
<li><p>With <span class="math notranslate nohighlight">\(\round \cdot\)</span> (respectively <span class="math notranslate nohighlight">\(\lceil \cdot \rceil\)</span> and <span class="math notranslate nohighlight">\(\lfloor \cdot \rfloor\)</span>) we denote the rounding function to the nearest integer (respectively up/down), which will be extended to polynomials coefficient-wise and to vectors entry-wise.</p></li>
<li><p>Since most of our variables will be of polynomial nature, to avoid confusion we will denote vectors as <span class="math notranslate nohighlight">\(\vec v\)</span>.
For vectors, we will write the scalar product as <span class="math notranslate nohighlight">\(\langle \cdot, \cdot \rangle\)</span>.</p></li>
<li><p>Algorithms will be indicated in <span class="math notranslate nohighlight">\(\texttt{algorithm}\)</span> textstyle.
The symbol ‘ will correspond to a <span class="math notranslate nohighlight">\(\texttt{x}\)</span> inside algorithms, e.g. <span class="math notranslate nohighlight">\(\mathrm{RLWE'}\)</span> becomes <span class="math notranslate nohighlight">\(\texttt{rlwe-x}\)</span>.</p></li>
<li><p>The abbreviation i.i.d. in the context of random variables stands for “identically and independently distributed”.</p></li>
</ul>
</section>
<section id="implementation-details">
<h2>Implementation details<a class="headerlink" href="#implementation-details" title="Permalink to this headline">#</a></h2>
<p>The implementation of the bootstrapping scheme relies on the separate Python file “polynomial_arithmetic.py”, which performs polynomial arithmetic and other useful operations on polynomials in <a class="reference internal" href="#the-ring-r"><span class="std std-ref">The ring R</span></a>.
The framework of the Python file originates in <span id="id6">[<a class="reference internal" href="#id72" title="Saroja Erabelli. A python library for fully homomorphic encryption. https://github.com/sarojaerabelli/py-fhe, 2020.">Erabelli, 2020</a>]</span>, which has been partly modified and extended.
The main motivation using it has been the lack of a (simple) Python package, which handles the arithmetic of arbitrary long integers as coefficients of polynomials in the above ring.
The Python file includes extensive descriptions of its algorithms.</p>
<p>The main contribution was the implementation of a faster multiplication algorithm, namely the Karatsuba algorithm, which contrary to the state-of-the-art multiplication techniques is simpler to implement from scratch and most importantly directly applicable to any ciphertext modulus <span class="math notranslate nohighlight">\(Q\)</span> and ring degree <span class="math notranslate nohighlight">\(N\)</span> (these parameters will be examined in <a class="reference internal" href="#the-modular-variant-of-the-ring-r"><span class="std std-ref">The modular variant of the ring R</span></a>).
In the original file, i.e. in <span id="id7">[<a class="reference internal" href="#id72" title="Saroja Erabelli. A python library for fully homomorphic encryption. https://github.com/sarojaerabelli/py-fhe, 2020.">Erabelli, 2020</a>]</span>, the modern Fast Fourier Transform (FFT) multiplication algorithm is included, which is considerably faster compared to Karatsuba, but not applicable to powers of two as bootstrapping parameters (e.g. <span class="math notranslate nohighlight">\(Q\)</span>).
Since powers of two greatly simplify the mathematical analysis of the scheme and furthermore implementing techniques and algorithm speed are not the main concerns of this thesis, we have chosen to omit FFT implementation.</p>
<p>In general, multiplying efficiently is extremely important, since the bootstrapping procedure bases upon multiplications of polynomials.
Apart from handling polynomials in the ring as a class object, we also import auxiliary functions, which generate polynomials, whose coefficients have certain properties, e.g. being drawn from a specific distribution (see <a class="reference internal" href="#background-on-probability-theory"><span class="std std-ref">Background on probability theory</span></a>).</p>
<p>Further inspiration for implementing the somewhat homomorphic BFV scheme in Python (see <a class="reference internal" href="#the-bfv-scheme"><span class="std std-ref">The BFV scheme</span></a>) has been drawn from <span id="id8">[<a class="reference internal" href="#id73" title="Mădălina Bolboceanu, Miruna Roșca, and Radu Țițiu. Homomorphic encryption: a toy implementation in python. https://bit-ml.github.io/blog/post/homomorphic-encryption-toy-implementation-in-python/, 2020.">Bolboceanu <em>et al.</em>, 2020</a>]</span>.
The full implementation, including an online jupyter book version of the thesis featuring executable code cells, can be found at <a class="reference external" href="https://github.com/robinkoestler/A-survey-on-modern-fully-homomorphic-encryption">https://github.com/robinkoestler/A-survey-on-modern-fully-homomorphic-encryption</a>.</p>
<p>The bootstrapping implementation, which is split up among many auxiliary procedures throughout the document, will be analyzed in a step-by-step fashion.</p>
<p>Below we import all necessary external Python packages and the class to handle polynomial arithmetic as <span class="math notranslate nohighlight">\(\texttt{Poly}\)</span>.
The variable <span class="math notranslate nohighlight">\(\texttt{speed}\)</span> linearly controls the running time and it may be augmented to obtain more precise computational results in the case of e.g. probabilistic bounds.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">polynomial_arithmetic</span><span class="o">,</span> <span class="nn">random</span>
<span class="kn">from</span> <span class="nn">polynomial_arithmetic</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">timeit</span> <span class="kn">import</span> <span class="n">default_timer</span> <span class="k">as</span> <span class="n">timer</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">timedelta</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">log</span><span class="p">,</span> <span class="n">floor</span><span class="p">,</span> <span class="n">ceil</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">gcd</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">erf</span>
<span class="n">Poly</span> <span class="o">=</span> <span class="n">polynomial_arithmetic</span><span class="o">.</span><span class="n">Polynomial</span> <span class="c1"># the class of handling polynomial arithmetic in R</span>
<span class="n">speed</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># precision factor for computations: Scales the running time.</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="ring-learning-with-errors-rlwe">
<span id="ring-learning-with-errors"></span><h1>Ring learning with errors (RLWE)<a class="headerlink" href="#ring-learning-with-errors-rlwe" title="Permalink to this headline">#</a></h1>
<section id="the-ring-r">
<span id="id9"></span><h2>The ring <span class="math notranslate nohighlight">\(R\)</span><a class="headerlink" href="#the-ring-r" title="Permalink to this headline">#</a></h2>
<p>Our cryptographic scheme will work with polynomials, which are elements of the ring <span class="math notranslate nohighlight">\(R := \Z[x]/\langle x^N +1 \rangle\)</span> with a power of two <span class="math notranslate nohighlight">\(N &gt; 1\)</span>.
We will often refer to the coefficients <span class="math notranslate nohighlight">\(c_0,\dots,c_{N-1} \in \Z\)</span> of an element <span class="math notranslate nohighlight">\(r(x) \in R\)</span> by using the standard <span class="math notranslate nohighlight">\(r(x) = \sum_{i=0}^{N-1} c_i x^i\)</span> representation.</p>
<p>There are many reasons for the choice of <span class="math notranslate nohighlight">\(R\)</span>:</p>
<ul class="simple">
<li><p>First and foremost, in the described scheme we are working within discrete structures (messages, ciphertexts, etc. built on elements of <span class="math notranslate nohighlight">\(\Z\)</span>).
Thus we have the advantage of the simplicity of representing everything via integers, whereas in approximate cryptographic schemes (like CKKS, where <span class="math notranslate nohighlight">\(\R\)</span> or <span class="math notranslate nohighlight">\(\mathbb C\)</span> are used, see <span id="id10">[<a class="reference internal" href="#id66" title="Jung Hee Cheon, Andrey Kim, Miran Kim, and Yongsoo Song. Homomorphic encryption for arithmetic of approximate numbers. In Tsuyoshi Takagi and Thomas Peyrin, editors, Advances in Cryptology – ASIACRYPT 2017, 409–437. Cham, 2017. Springer International Publishing.">Cheon <em>et al.</em>, 2017</a>]</span>) one has to worry about rounding errors during computations, which affect the message precision and so on.</p></li>
<li><p>We are generally using polynomial rings to assure that the basic ring operations (addition and multiplication) can be efficiently calculated by computers without too much effort concerning implementing techniques of the latter.</p></li>
<li><p>After multiplying two ring elements, we are left to reduce the result modulo <span class="math notranslate nohighlight">\(x^N + 1\)</span>, which is as simple as a sign change and adding two polynomials in <span class="math notranslate nohighlight">\(R\)</span>, because <span class="math notranslate nohighlight">\(x^N = -1\)</span> in <span class="math notranslate nohighlight">\(R\)</span>.
Compared to the regular polynomial division for arbitrary polynomial quotient rings, this is computationally close to optimal.</p></li>
<li><p>At last, we have the property of having no nonzero zero divisors in <span class="math notranslate nohighlight">\(R\)</span>, which avoids possible degeneration by performing ring operations:</p></li>
</ul>
<div class="proof theorem admonition" id="R_integral">
<p class="admonition-title"><span class="caption-number">Theorem 1 </span></p>
<section class="theorem-content" id="proof-content">
<p><span class="math notranslate nohighlight">\(R\)</span> is an integral domain.</p>
</section>
</div><div class="proof admonition" id="proof">
<p>Proof. <span class="math notranslate nohighlight">\(x^N+1\)</span> is the <span class="math notranslate nohighlight">\(2N\)</span>-th cyclotomic polynomial.
All cyclotomic polynomials are irreducible over <span class="math notranslate nohighlight">\(\Q[x]\)</span> and monic, thus they are irreducible over <span class="math notranslate nohighlight">\(\Z[x]\)</span>, too.
Because <span class="math notranslate nohighlight">\(\Z\)</span> and <span class="math notranslate nohighlight">\(\Z[x]\)</span> are both unique factorization domains, <span class="math notranslate nohighlight">\(x^N+1 \in \Z[x]\)</span> is a prime element equivalently to being irreducible over <span class="math notranslate nohighlight">\(\Z[x]\)</span>.
It follows that the ideal <span class="math notranslate nohighlight">\(I = \langle x^N +1 \rangle\)</span> is a prime ideal and therefore <span class="math notranslate nohighlight">\(R = \Z[x]/I\)</span> is an integral domain.</p>
</div>
</section>
<section id="the-modular-variant-of-the-ring-r">
<span id="id11"></span><h2>The modular variant of the ring <span class="math notranslate nohighlight">\(R\)</span><a class="headerlink" href="#the-modular-variant-of-the-ring-r" title="Permalink to this headline">#</a></h2>
<p>The above ring <span class="math notranslate nohighlight">\(R\)</span> cannot possibly degenerate nonzero elements to zero during ring operations, but nevertheless, it contains infinitely many elements - a property we want to avoid while using a similar structure for message/ciphertext spaces.
The introduction of a power of two modulus <span class="math notranslate nohighlight">\(M &gt; 1\)</span> to define the finite quotient ring <span class="math notranslate nohighlight">\(R_M := R/MR\)</span> resolves this issue and has the following impacts:</p>
<ul class="simple">
<li><p>Because of the finiteness, we are now able to choose elements of <span class="math notranslate nohighlight">\(R_M\)</span> e.g. uniformly at random.
This will later be necessary to define the “Decision RLWE” problem, upon which the security of our scheme is based.</p></li>
<li><p>To uniquely represent the coefficients of a polynomial in <span class="math notranslate nohighlight">\(R_M\)</span>, we will use the set of integers inside <span class="math notranslate nohighlight">\((-M/2,M/2]\)</span>.
Naturally, this is advantageous for two reasons.</p>
<ul>
<li><p>Firstly, it allows a coefficient to be sampled e.g. from a discrete normal distribution around zero.</p></li>
<li><p>Secondly, compared to e.g. <span class="math notranslate nohighlight">\([0,M-1]\)</span> it halves the maximum absolute value a polynomial coefficient can reach and therefore is an optimal choice regarding the complexity of algorithms operating on integers.</p></li>
</ul>
</li>
<li><p>By using different power of two moduli as <span class="math notranslate nohighlight">\(M\)</span>, we can adjust our plaintext/ciphertext/bootstrapping space size to our necessities.
Switching between these will be easily done by just embedding (from small to large modulus) respectively by a modular reduction of the coefficients (and vice versa).</p></li>
</ul>
<p>To illustrate the use of modular variants of <span class="math notranslate nohighlight">\(R\)</span>, let us consider a small message space, e.g. <span class="math notranslate nohighlight">\(R_8\)</span>, and a larger (ciphertext) space, e.g. <span class="math notranslate nohighlight">\(R_{32}\)</span>, without a further specified <span class="math notranslate nohighlight">\(N\)</span>.
Technically, we could just trivially embed an example message <span class="math notranslate nohighlight">\(2x+1 \in R_8\)</span> into the larger ring as <span class="math notranslate nohighlight">\(2x+1 \in R_{32}\)</span>.
But since we furthermore need to introduce additive errors, which make our scheme secure and also alter ring elements slightly, we can use a different, more sophisticated embedding into <span class="math notranslate nohighlight">\(R_{32}\)</span> than just enlarging the space in general.
For this example consider the ring-dependent expansion factor <span class="math notranslate nohighlight">\(\kappa := 32/8 = 4\)</span> and the switching of rings procedure:</p>
<div class="math notranslate nohighlight">
\[\underbrace{2x+1}_{\in R_8} \overset{\cdot \kappa}{\dashrightarrow} \underbrace{8x+4}_{\in R_{32}} \overset{+ e }{\dashrightarrow} \underbrace{9x+3}_{\in R_{32}} \overset{: \kappa}{\dashrightarrow} \underbrace{2.25 x + 0.75}_{\in\Q[x]/\langle x^N+1 \rangle} \overset{\round \cdot}{\dashrightarrow} \underbrace{2x+1}_{\in R_8}\]</div>
<p>with an error <span class="math notranslate nohighlight">\(e := x-1\)</span>.
We observe that instead of irrevokably changing the message by adding <span class="math notranslate nohighlight">\(e\)</span> to <span class="math notranslate nohighlight">\(2x+1\)</span> in <span class="math notranslate nohighlight">\(R_8\)</span>, we made use of the larger ring <span class="math notranslate nohighlight">\(R_{32}\)</span> in such a way, that it preserves the message when adding <span class="math notranslate nohighlight">\(e\)</span> in <span class="math notranslate nohighlight">\(R_{32}\)</span> and switching back to <span class="math notranslate nohighlight">\(R_8\)</span> afterwards.
This later becomes a crucial idea in the bootstrapping procedure, where errors are “large”.
The above procedure also highlights that power of two moduli <span class="math notranslate nohighlight">\(M\)</span> generally result in integer <span class="math notranslate nohighlight">\(\kappa\)</span>’s, which keeps the upscaling by <span class="math notranslate nohighlight">\(\kappa\)</span> clean from rounding errors.</p>
<p>To sum it up, we gain security and sizing control by adding modular arithmetic to <span class="math notranslate nohighlight">\(R\)</span>.
However, it should be remarked that <span class="math notranslate nohighlight">\(R_M\)</span> for powers of two <span class="math notranslate nohighlight">\(M&gt;2\)</span> and <span class="math notranslate nohighlight">\(N\)</span> is no longer an integer domain.
Hence it is important to keep track of where and when we can reduce a <span class="math notranslate nohighlight">\(R\)</span>-element modulo <span class="math notranslate nohighlight">\(M\)</span>, after performing operations favorably in <span class="math notranslate nohighlight">\(R\)</span> itself.</p>
</section>
<section id="size-and-norm-of-ring-elements">
<h2>Size and norm of ring elements<a class="headerlink" href="#size-and-norm-of-ring-elements" title="Permalink to this headline">#</a></h2>
<p>The above example of switching (modular) rings points out that it is indeed important to distinguish between “small” and “large” ring elements, referring to the “size” of the coefficients.
This size can be measured by the infinity norm adapted to the rings as follows <span class="math notranslate nohighlight">\(\norm{y} := \max \{|y_i| : i \in \{0,\dots,N-1\}\}\)</span>, where <span class="math notranslate nohighlight">\(y_i\)</span> are the coefficients of <span class="math notranslate nohighlight">\(y \in R\)</span>.
Note that, if especially <span class="math notranslate nohighlight">\(y \in R_M\)</span>, this definition already expects the centered reductions <span class="math notranslate nohighlight">\(y_i\)</span> modulo <span class="math notranslate nohighlight">\(M\)</span>.</p>
<p>Additionally, let us remark that in contrary to <span class="math notranslate nohighlight">\(R\)</span>, <span class="math notranslate nohighlight">\(\norm \cdot\)</span> for <span class="math notranslate nohighlight">\(R_M\)</span> is not a norm in the classical sense, because it is not compatible with modular arithmetic, e.g.:</p>
<div class="math notranslate nohighlight">
\[M = \abs{M/2} \cdot \norm{x+2} \neq \norm{(M/2)(x+2)} = \norm{(M/2)x} = M/2.\]</div>
<p>Nevertheless, in <span class="math notranslate nohighlight">\(R\)</span> the norm properties are satisfied, and thus we will mainly work with <span class="math notranslate nohighlight">\(R\)</span> instead of the modular variant, for which we will only reduce at certain times during our computations.
Moreover, later our error within ciphertexts must not surpass a certain bound <span class="math notranslate nohighlight">\(&lt; M/2\)</span> for correct decryptions, so <span class="math notranslate nohighlight">\(\norm \cdot\)</span> will be used to measure the error size.</p>
</section>
<section id="background-on-probability-theory">
<span id="id12"></span><h2>Background on probability theory<a class="headerlink" href="#background-on-probability-theory" title="Permalink to this headline">#</a></h2>
<section id="occurring-distributions">
<h3>Occurring distributions<a class="headerlink" href="#occurring-distributions" title="Permalink to this headline">#</a></h3>
<p>Let us denote the sampling of <span class="math notranslate nohighlight">\(y\)</span> from a probability distribution <span class="math notranslate nohighlight">\(\mathcal D\)</span> by <span class="math notranslate nohighlight">\(y \sim \mathcal D\)</span>.
In the same fashion, we say we sample a ring element <span class="math notranslate nohighlight">\(y \in R\)</span> from a distribution <span class="math notranslate nohighlight">\(\mathcal D\)</span>, if we independently and identically sample the related coefficients <span class="math notranslate nohighlight">\(y_0, \dots, y_{N-1}\)</span> of <span class="math notranslate nohighlight">\(x\)</span> each from <span class="math notranslate nohighlight">\(\mathcal D\)</span>.</p>
<p>We will use the following distributions for <span class="math notranslate nohighlight">\(y \in \Z\)</span>:</p>
<ul class="simple">
<li><p>Discrete uniform distribution <span class="math notranslate nohighlight">\(\mathcal U(a,b)\)</span>: For integers <span class="math notranslate nohighlight">\(a \le b\)</span> and <span class="math notranslate nohighlight">\(i \in \Z \cap [a,b]\)</span> fixed, we have <span class="math notranslate nohighlight">\(\mathbb P(y=i) := 1/(b-a+1)\)</span>.
Most of the time, we will use <span class="math notranslate nohighlight">\(\mathcal U(R_M) := \mathcal U(-M/2,M/2)\)</span>.
Notice that technically <span class="math notranslate nohighlight">\(-M/2\)</span> is not in the (representative) set <span class="math notranslate nohighlight">\(\Z_{M}\)</span>, but for sampling we will use it anyway since otherwise <span class="math notranslate nohighlight">\(\mathcal U(R_M)\)</span> would have mean one instead of zero.
The overall effect of this on the uniformity of the distribution is quite negligible while using a (typically) large <span class="math notranslate nohighlight">\(M\)</span>.</p></li>
<li><p>Discrete centered normal distribution <span class="math notranslate nohighlight">\(\mathcal {N}_d(0,\sigma^2)\)</span>:
For a (real) standard deviation parameter <span class="math notranslate nohighlight">\(\sigma \ge 0\)</span> and <span class="math notranslate nohighlight">\(i \in \Z\)</span> fixed, we assign <span class="math notranslate nohighlight">\(\mathbb P(y = i) := \int_{i-1/2}^{i+1/2} f_{\mathcal N(0,\sigma^2)}(z) dz\)</span>, where <span class="math notranslate nohighlight">\(f_{\mathcal N(0,\sigma^2)}\)</span> is the probability density function of the (continuous) normal distribution <span class="math notranslate nohighlight">\(\mathcal N(0,\sigma^2)\)</span>.
In other words,  while sampling discretely we simply round the values obtained from the continuous distribution to the nearest integer.
Notice furthermore that <span class="math notranslate nohighlight">\(\mathcal N_d(0,\sigma^2)\)</span>, although we denote it in the same way, only has mean zero, but it does not have variance <span class="math notranslate nohighlight">\(\sigma^2\)</span> (see <a class="reference internal" href="#discrete-variance">Lemma 1</a>).</p></li>
<li><p>Ternary distribution <span class="math notranslate nohighlight">\(\mathrm{Ter}_\rho\)</span>: For a parameter <span class="math notranslate nohighlight">\(\rho \in (0,1)\)</span> define the ternary distribution by <span class="math notranslate nohighlight">\(\mathbb P(y = -1) = \mathbb P(y = 1) = (1-\rho)/2\)</span> and <span class="math notranslate nohighlight">\(\mathbb P(y = 0) = \rho\)</span>.
In our implementation, we set <span class="math notranslate nohighlight">\(\rho\)</span> to <span class="math notranslate nohighlight">\(1/3\)</span>, thus <span class="math notranslate nohighlight">\(\mathrm{Ter}_{1/3} = \mathcal U(-1,1)\)</span>.
Another notable choice: A large <span class="math notranslate nohighlight">\(\rho\)</span> leads to samples of sparse ring elements, which have computational advantages.</p></li>
</ul>
<p>Efficient bootstrapping relies on a detailed error analysis, whose errors are typically generated from the discrete normal distribution.
Hence we will need to apply theorems from probability theory to estimate the size of an error (with high probability).
Since errors will also be added and multiplied throughout the bootstrapping scheme, we will proceed to analyse the error growth depending on different operations and distributions.</p>
</section>
<section id="the-error-function-mathrm-erf">
<h3>The error function <span class="math notranslate nohighlight">\(\mathrm{erf}\)</span><a class="headerlink" href="#the-error-function-mathrm-erf" title="Permalink to this headline">#</a></h3>
<div class="proof definition admonition" id="error-function">
<p class="admonition-title"><span class="caption-number">Definition 1 </span> (The error function)</p>
<section class="definition-content" id="proof-content">
<p>For <span class="math notranslate nohighlight">\(x \in \R\)</span>, the error function <span class="math notranslate nohighlight">\(\mathrm{erf}(x)\)</span> is given by:</p>
<div class="math notranslate nohighlight">
\[\mathrm{erf}(x) := \frac{2}{\sqrt{\pi}} \int_0^x e^{-t^2}dt\]</div>
</section>
</div><p>The error function will be useful to calculate the probability that <span class="math notranslate nohighlight">\(\norm y\)</span> for <span class="math notranslate nohighlight">\(y\in R\)</span> has a certain bound.</p>
<div class="proof property admonition" id="property-error-function">
<p class="admonition-title"><span class="caption-number">Property 1 </span> (Properties of <span class="math notranslate nohighlight">\(\mathrm{erf}\)</span>)</p>
<section class="property-content" id="proof-content">
<p>Let <span class="math notranslate nohighlight">\(F(x)\)</span> be the cumulative distribution function of the normal distribution <span class="math notranslate nohighlight">\(\mathcal N(0, \sigma^2)\)</span>. Then for a corresponding random variable <span class="math notranslate nohighlight">\(X\)</span> we have:</p>
<div class="math notranslate nohighlight">
\[\P(\abs X \le x) \overset{\text{if } x &gt; 0}{=} \mathrm{erf}(x/\sqrt{2\sigma^2}) = 2F(x) -1 = F(x) - F(-x)\]</div>
</section>
</div></section>
<section id="bounds-for-the-normal-distribution">
<h3>Bounds for the normal distribution<a class="headerlink" href="#bounds-for-the-normal-distribution" title="Permalink to this headline">#</a></h3>
<p>Suppose we sample <span class="math notranslate nohighlight">\(y \in R\)</span> from <span class="math notranslate nohighlight">\(\mathcal N_d(0,\sigma^2)\)</span> and want to derive a bound on <span class="math notranslate nohighlight">\(\norm y\)</span> for further computations.
Naturally, only a probabilistic bound can be achieved here.
Thus we consider the scenario: Determine the small probability <span class="math notranslate nohighlight">\(p_{norm}(k)\)</span> for which <span class="math notranslate nohighlight">\(\norm y \le k\cdot \sigma\)</span> holds for various <span class="math notranslate nohighlight">\(k \in \mathbb N\)</span>.</p>
<p>For a single coefficient <span class="math notranslate nohighlight">\(y_i \in \Z\)</span> of <span class="math notranslate nohighlight">\(y\)</span>, we have by definition:</p>
<div class="math notranslate nohighlight">
\[
p := \P(\abs{y_i} \le k \cdot \sigma) = \mathrm{erf}\left( \frac{\lfloor k\sigma \rfloor + 1/2}{\sqrt{2}\sigma}\right)
\]</div>
<p>Because the <span class="math notranslate nohighlight">\(y_i\)</span> are i.i.d. samples, we have that</p>
<div class="math notranslate nohighlight" id="equation-bernoulli-estimation">
<span class="eqno">(1)<a class="headerlink" href="#equation-bernoulli-estimation" title="Permalink to this equation">#</a></span>\[    p_{norm}(k) = \P(\norm y \le k \cdot \sigma) = p^N \ge 1 - N (1-p)\]</div>
<p>using the maximum inside <span class="math notranslate nohighlight">\(\norm \cdot\)</span> and Bernoulli’s inequality.</p>
<div class="proof theorem admonition" id="sampling-bound">
<p class="admonition-title"><span class="caption-number">Theorem 2 </span> (Norm bounds for standard Gaussian sampling in <span class="math notranslate nohighlight">\(R\)</span>)</p>
<section class="theorem-content" id="proof-content">
<p>For an <span class="math notranslate nohighlight">\(R\)</span>-element <span class="math notranslate nohighlight">\(y \sim \mathcal N_d(0,\sigma^2)\)</span> with <span class="math notranslate nohighlight">\(\sigma \ge 1\)</span>, we can assume the bound <span class="math notranslate nohighlight">\(\norm y \le k\sigma\)</span> with probability <span class="math notranslate nohighlight">\(\ge \mathrm{erf}\left( (k-1)/\sqrt{2} \right)^N\)</span>.</p>
</section>
</div><div class="proof admonition" id="proof">
<p>Proof. Following the above discussion, all left to show is the bound of <span class="math notranslate nohighlight">\(\mathrm{erf}\)</span>. This follows because <span class="math notranslate nohighlight">\(\mathrm{erf}\)</span> is strictly increasing and thus estimating <span class="math notranslate nohighlight">\((\lfloor k \sigma \rfloor + 1/2)/\sigma \ge (k-1)\)</span> with <span class="math notranslate nohighlight">\(\sigma \ge 1\)</span> yields the result.</p>
</div>
<p>We now want to determine pairs <span class="math notranslate nohighlight">\((k,p_{norm}(k))\)</span> computationally by using the Bernoulli estimation given in <a class="reference internal" href="#equation-bernoulli-estimation">(1)</a>, because of precision issues during exponentiation.
For simplicity, we also set <span class="math notranslate nohighlight">\(\sigma = 1\)</span>, since it has a negligible effect on the result anyway.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">N</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**</span><span class="mi">4</span>
<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">9</span><span class="p">):</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">erf</span><span class="p">((</span><span class="n">k</span><span class="o">+</span><span class="mf">0.5</span><span class="p">)</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;k = </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> leads to 1-</span><span class="si">{</span><span class="n">N</span><span class="si">}</span><span class="s2">*(1-p) = </span><span class="si">{</span><span class="mi">1</span><span class="o">-</span><span class="n">N</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">p</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>k = 3 leads to 1-10000*(1-p) = -3.6525815807108017
k = 4 leads to 1-10000*(1-p) = 0.9320465375052258
k = 5 leads to 1-10000*(1-p) = 0.9996202087504393
k = 6 leads to 1-10000*(1-p) = 0.999999196800271
k = 7 leads to 1-10000*(1-p) = 0.9999999993616218
k = 8 leads to 1-10000*(1-p) = 1.0
</pre></div>
</div>
</div>
</div>
<p>Computational conclusion: Later we will set the parameter <span class="math notranslate nohighlight">\(N\)</span> to around <span class="math notranslate nohighlight">\(10^4\)</span>.
Hence, with e.g. using <span class="math notranslate nohighlight">\(k=10\)</span>, our computations let us surmise that <span class="math notranslate nohighlight">\(\norm{y} &gt; 10\sigma\)</span> only happens with probability <span class="math notranslate nohighlight">\(\approx 10^{-18}\)</span>.
Other authors regularly assume a lower <span class="math notranslate nohighlight">\(k\)</span>, e.g. <span class="math notranslate nohighlight">\(k=6\)</span>, implying a probability of bound-exceeding around <span class="math notranslate nohighlight">\(10^{-6}\)</span> per sample.
This is also reasonable, since the norm-wise equilibrating effects of adding/multiplying elements of <span class="math notranslate nohighlight">\(R\)</span> respectively <span class="math notranslate nohighlight">\(R_M\)</span>, which we will soon discuss in detail, will take care of the outliers anyway.</p>
</section>
<section id="bound-for-adding-two-r-elements">
<h3>Bound for adding two <span class="math notranslate nohighlight">\(R\)</span>-elements<a class="headerlink" href="#bound-for-adding-two-r-elements" title="Permalink to this headline">#</a></h3>
<p>Let <span class="math notranslate nohighlight">\(x_1,\dots,x_m \in \R\)</span> be independently sampled from <span class="math notranslate nohighlight">\(\mathcal N(0,\sigma^2)\)</span>.
It is widely known that <span class="math notranslate nohighlight">\(\sum_{i=1}^m x_i\)</span> has then the distribution <span class="math notranslate nohighlight">\(\mathcal N(0,m\sigma^2)\)</span>.
That is, because the sum of variants equals the variance of the sum, in the case of independently random variables (Bienaymé’s identity).
To bound <span class="math notranslate nohighlight">\(\norm{y+z}\)</span> for <span class="math notranslate nohighlight">\(y,z \in R\)</span> and <span class="math notranslate nohighlight">\(y,z \sim \mathcal N_d(0,\sigma^2)\)</span>, we therefore have to determine the variance of the distribution <span class="math notranslate nohighlight">\(\mathcal N_d(0,\sigma^2)\)</span>.</p>
<div class="proof lemma admonition" id="discrete-variance">
<p class="admonition-title"><span class="caption-number">Lemma 1 </span> (Variance of rounded centered normal distributions)</p>
<section class="lemma-content" id="proof-content">
<p>For <span class="math notranslate nohighlight">\(\sigma \ge 1\)</span> and a random variable <span class="math notranslate nohighlight">\(X\sim \mathcal N_d(0,\sigma^2)\)</span>, we have:</p>
<div class="math notranslate nohighlight">
\[\mathrm{Var}(X) \le \sigma^2 + \frac{1}{12}.\]</div>
</section>
</div><div class="proof admonition" id="proof">
<p>Proof. We will use the result from Equation 3.2. in <span id="id13">[<a class="reference internal" href="#id59" title="A. R. Tricker. Effects of rounding on the moments of a probability distribution. Journal of the Royal Statistical Society. Series D (The Statistician), 33(4):381–390, 1984. URL: http://www.jstor.org/stable/2987741 (visited on 2022-09-21).">Tricker, 1984</a>]</span>, which treats our case for <span class="math notranslate nohighlight">\(a=0\)</span>.
For a more detailed derivation of a proof of this equation, we refer to <span id="id14">[<a class="reference internal" href="#id60" title="J. An. Sample variance of rounded variables. 2021. URL: https://arxiv.org/abs/2102.08483, doi:10.48550/ARXIV.2102.08483.">An, 2021</a>]</span>.
Following these papers, we have:</p>
<div class="math notranslate nohighlight">
\[\mathrm{Var}(X) = \sigma^2 + \frac{1}{12} + 4 \sum_{k=1}^\infty (-1)^k e^{-2k^2\pi^2\sigma^2} \cdot (\sigma^2 + (2\pi k)^{-2}).\]</div>
<p>If we denote by <span class="math notranslate nohighlight">\(a_k\)</span> the sequence in the above series, notice that <span class="math notranslate nohighlight">\(\abs{a_k}\)</span> is strictly decreasing for <span class="math notranslate nohighlight">\(\sigma \ge 1\)</span>.
Because <span class="math notranslate nohighlight">\(a_k\)</span> is alternating in sign, starting with <span class="math notranslate nohighlight">\(-1\)</span>, we verify our bound <span class="math notranslate nohighlight">\(\sigma^2 + 1/12\)</span> by just ignoring the series in general, since the value of the series will be negative:</p>
<div class="math notranslate nohighlight">
\[\sum_{k=1}^\infty a_k = a_1 + \sum_{k=2}^\infty a_k \le a_1 + a_2 &lt; 0.\]</div>
</div>
<p>In practice, the above result could even hold for <span class="math notranslate nohighlight">\(\sigma \ge 0.3\)</span>, which the computation below points out.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">cdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span> <span class="c1"># cumulative density function for N(0, sigma^2)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">erf</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">sigma</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
<span class="n">sigma</span> <span class="o">=</span> <span class="mf">0.3</span> <span class="c1"># test with 0.1, 0.3, 1</span>
<span class="n">var_values</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span> <span class="p">(</span><span class="n">cdf</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mf">0.5</span><span class="p">,</span><span class="n">sigma</span><span class="p">)</span> <span class="o">-</span> <span class="n">cdf</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span><span class="n">sigma</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">1000</span><span class="p">,</span><span class="mi">1000</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;With sigma = </span><span class="si">{</span><span class="n">sigma</span><span class="si">}</span><span class="s2">, the bound of 1/12 is instead approximately 1/</span><span class="si">{</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">var_values</span><span class="p">)</span> <span class="o">-</span> <span class="n">sigma</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>With sigma = 0.3, the bound of 1/12 is instead approximately 1/179.13363773216952
</pre></div>
</div>
</div>
</div>
<p>Putting everything together, we end up with:</p>
<div class="proof theorem admonition" id="norm-bound-adding_R">
<p class="admonition-title"><span class="caption-number">Theorem 3 </span> (Norm bound for adding <span class="math notranslate nohighlight">\(R\)</span>-elements)</p>
<section class="theorem-content" id="proof-content">
<p>Let <span class="math notranslate nohighlight">\(x_1,\dots,x_m \in R\)</span> be independently sampled from <span class="math notranslate nohighlight">\(\mathcal N_d(0,\sigma^2)\)</span> and <span class="math notranslate nohighlight">\(y = x_1+\dots+x_m\)</span>. Then we can assume the bound <span class="math notranslate nohighlight">\(\norm y \le k\sigma \sqrt{m}\)</span> with an approximate probability of</p>
<div class="math notranslate nohighlight">
\[\mathrm{erf}\left( \frac{k\sigma}{\sqrt{2\cdot(\sigma^2+1/12)}} \right)^N \approx \mathrm{erf}(k/\sqrt{2})^N\]</div>
<p>for <span class="math notranslate nohighlight">\(k \in \mathbb N\)</span> and large <span class="math notranslate nohighlight">\(m\)</span>.</p>
</section>
</div><div class="proof admonition" id="proof">
<p>Proof. We prove the theorem in the same fashion as <a class="reference internal" href="#sampling-bound">Theorem 2</a>, by treating each coefficient <span class="math notranslate nohighlight">\(c\)</span> of <span class="math notranslate nohighlight">\(y \in R\)</span> individually and later using <a class="reference internal" href="#equation-bernoulli-estimation">(1)</a> to analogously generalize for the ring element <span class="math notranslate nohighlight">\(y\)</span>.
So let <span class="math notranslate nohighlight">\(c\)</span> be the sum of <span class="math notranslate nohighlight">\(z_1,\dots,z_m \in \Z\)</span> independently sampled from <span class="math notranslate nohighlight">\(\mathcal N_d(0,\sigma^2)\)</span>.
By Bienaymé’s identity and the independence of the <span class="math notranslate nohighlight">\(z_i\)</span>, the variance of <span class="math notranslate nohighlight">\(c\)</span> can be bound by <span class="math notranslate nohighlight">\(m\sigma^2 +m/12\)</span> using <a class="reference internal" href="#discrete-variance">Lemma 1</a>.</p>
<p>It is now reasonable to assume that <span class="math notranslate nohighlight">\(c \sim \mathcal N(0,m\sigma^2 +m/12)\)</span> in an approximate way, since the <span class="math notranslate nohighlight">\(z_i\)</span> themselves come from a slightly altered normal distribution.
This argument is supported by the central limit theorem, which yields the exact same distribution <span class="math notranslate nohighlight">\(\mathcal N(0,m\sigma^2 +m/12)\)</span> as an approximation for large <span class="math notranslate nohighlight">\(m\)</span>, if one takes the sequence <span class="math notranslate nohighlight">\((z_i) \sim \mathcal N_d(0,\sigma^2)\)</span> as an input.</p>
<p>We compute using <a class="reference internal" href="#property-error-function">Property 1</a>:</p>
<div class="math notranslate nohighlight">
\[\P(\abs c &gt; k\sqrt{m}\sigma) \approx \mathrm{erf}\left( \frac{k\sigma\sqrt{m}}{\sqrt{2\cdot(m\sigma^2+m/12)}} \right).\]</div>
<p>where <span class="math notranslate nohighlight">\(\sqrt{m}\)</span> cancels out.
Furthermore, the term “<span class="math notranslate nohighlight">\(+1/12\)</span>” coming from <a class="reference internal" href="#discrete-variance">Lemma 1</a> is more of theoretical interest, since it only has a marginal influence on the probability bound.
If we choose to omit it, also <span class="math notranslate nohighlight">\(\sigma\)</span> cancels out, which leaves us with the second approximation.</p>
</div>
<p>Let us give a quick demonstration of the bound given in the theorem.
Taking <span class="math notranslate nohighlight">\(N=1\)</span> for simplicity, <span class="math notranslate nohighlight">\(m=3\)</span> for adding three <span class="math notranslate nohighlight">\(R\)</span>-elements, <span class="math notranslate nohighlight">\(\sigma = 1\)</span> to have a rounding effect and <span class="math notranslate nohighlight">\(k=3\)</span> for not having to do too many iterations:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">m</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">iterations</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5000</span><span class="o">*</span><span class="n">speed</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span>
<span class="c1"># below: without &quot;+1/12&quot; the approximation sometimes exceeds the ratio</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">erf</span><span class="p">((</span><span class="n">k</span><span class="o">*</span><span class="n">sigma</span><span class="p">)</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">sigma</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="o">/</span><span class="mi">12</span><span class="p">)))</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">iterations</span><span class="p">):</span>
    <span class="n">y</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">generate_gaussian_distribution</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">sigma</span><span class="p">)</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">)])</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">k</span> <span class="o">*</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">*</span> <span class="n">sigma</span><span class="p">:</span>
        <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">counter</span><span class="si">}</span><span class="s2"> out of </span><span class="si">{</span><span class="n">iterations</span><span class="si">}</span><span class="s2"> y&#39;s satisfying the bound (= ratio of </span><span class="si">{</span><span class="n">counter</span><span class="o">/</span><span class="n">iterations</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Probability approximation given in theorem = </span><span class="si">{</span><span class="mi">1</span><span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">p</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>4992 out of 5000 y&#39;s satisfying the bound (= ratio of 0.9984)
Probability approximation given in theorem = 0.9960522481430966
</pre></div>
</div>
</div>
</div>
</section>
<section id="bound-for-multiplying-two-r-elements">
<span id="bound-for-multiplying-two-ring-elements"></span><h3>Bound for multiplying two <span class="math notranslate nohighlight">\(R\)</span>-elements<a class="headerlink" href="#bound-for-multiplying-two-r-elements" title="Permalink to this headline">#</a></h3>
<p>Similarly to adding <span class="math notranslate nohighlight">\(R\)</span>-elements <span class="math notranslate nohighlight">\(y,z\)</span>, we want now to derive a bound on <span class="math notranslate nohighlight">\(\norm{y \cdot z}\)</span> depending on <span class="math notranslate nohighlight">\(\norm y\)</span> and <span class="math notranslate nohighlight">\(\norm z\)</span>.
The worst-case can be estimated as <span class="math notranslate nohighlight">\(\norm{y \cdot z} \le N \cdot \norm{y} \norm{z}\)</span> and this bound is tight (e.g. for <span class="math notranslate nohighlight">\(y = z := \sum_{i=0}^{N-1} x^i\)</span>).</p>
<section id="the-case-uniform-times-ternary">
<h4>The case “uniform” times “ternary”<a class="headerlink" href="#the-case-uniform-times-ternary" title="Permalink to this headline">#</a></h4>
<p>The objective of this section is now to improve this bound for the average case of multiplying an <span class="math notranslate nohighlight">\(R\)</span>-element <span class="math notranslate nohighlight">\(y \sim \mathcal U(R_Q)\)</span> times an <span class="math notranslate nohighlight">\(R\)</span>-element <span class="math notranslate nohighlight">\(z \sim \mathrm{Ter}_\rho\)</span>.
Recall the formula for calculating the coefficients of the product <span class="math notranslate nohighlight">\(yz\)</span> in the ring <span class="math notranslate nohighlight">\(R\)</span>:</p>
<div class="math notranslate nohighlight">
\[
(yz)_i := \sum_{j=0}^i y_iz_{i-j} + \sum_{j=i+1}^{N-1} -y_i z_{i+N-j}
\]</div>
<div class="proof lemma admonition" id="uniform-times-ternary">
<p class="admonition-title"><span class="caption-number">Lemma 2 </span></p>
<section class="lemma-content" id="proof-content">
<p>Let <span class="math notranslate nohighlight">\(Y \sim \mathcal U (-Q/2,Q/2)\)</span> and <span class="math notranslate nohighlight">\(Z \sim \mathrm{Ter}_\rho\)</span> be independent integer random variables for <span class="math notranslate nohighlight">\(\rho \in (0,1)\)</span>. Then <span class="math notranslate nohighlight">\(YZ\)</span> and <span class="math notranslate nohighlight">\(-YZ\)</span> have mean zero and variance <span class="math notranslate nohighlight">\((1-\rho) \cdot \mathrm{Var}(Y)\)</span>.</p>
</section>
</div><div class="proof admonition" id="proof">
<p>Proof. Because of the independency, we have <span class="math notranslate nohighlight">\(\mathbb E[YZ] = \mathbb E[Y]  \mathbb E[Z] = 0\)</span>.
The variance of <span class="math notranslate nohighlight">\(Z\)</span> is <span class="math notranslate nohighlight">\(1-\rho\)</span>, and then again due to the independency <span class="math notranslate nohighlight">\(\mathrm{Var}(YZ) = (1-\rho)\mathrm{Var}(Y)\)</span>.
Since also <span class="math notranslate nohighlight">\(Z \sim -Z\)</span> holds, the claim follows.</p>
</div>
<p>We can now again use the Central Limit Theorem to approximate the distribution of our multiplied coefficient <span class="math notranslate nohighlight">\((yz)_i\)</span>.
So we have:</p>
<div class="math notranslate nohighlight" id="equation-central-limit-approx">
<span class="eqno">(2)<a class="headerlink" href="#equation-central-limit-approx" title="Permalink to this equation">#</a></span>\[\P\left( \abs{(yz)_i} \le \sqrt{N \cdot \mathrm{Var}(y_iz_i)} \cdot v \right) \approx \Phi(v) - \Phi(-v) = \mathrm{erf}(v/\sqrt{2})\]</div>
<p>where <span class="math notranslate nohighlight">\(\Phi\)</span> is the cumulative density function of <span class="math notranslate nohighlight">\(\mathcal N(0,1)\)</span>.</p>
<p>In the literature, often the bound <span class="math notranslate nohighlight">\(\norm{yz} \le C \sqrt{N} \norm y \le C \sqrt{N} (Q/2)\)</span> is found for our case of <span class="math notranslate nohighlight">\(y\)</span> and <span class="math notranslate nohighlight">\(z\)</span>.
Heuristic experiments for choices of <span class="math notranslate nohighlight">\(C\)</span> underline that usually <span class="math notranslate nohighlight">\(C\)</span> ranges in <span class="math notranslate nohighlight">\([1,2]\)</span>.
Such experiments have been conducted in e.g. Section 6.1. in <span id="id15">[<a class="reference internal" href="#id61" title="Shai Halevi, Yuriy Polyakov, and Victor Shoup. An improved rns variant of the bfv homomorphic encryption scheme. Cryptology ePrint Archive, Paper 2018/117, 2018. https://eprint.iacr.org/2018/117. URL: https://eprint.iacr.org/2018/117, doi:10.1007/978-3-030-12612-4_5.">Halevi <em>et al.</em>, 2018</a>]</span>.
We may now formulate a theorem, where we estimate the probability that the bound is satisfied for <span class="math notranslate nohighlight">\(C\)</span> using the above.</p>
<div class="proof theorem admonition" id="multiplication-bound-uniform-ternary">
<p class="admonition-title"><span class="caption-number">Theorem 4 </span> (Norm bound for multiplying uniform times ternary in <span class="math notranslate nohighlight">\(R\)</span>)</p>
<section class="theorem-content" id="proof-content">
<p>For <span class="math notranslate nohighlight">\(R\)</span>-elements <span class="math notranslate nohighlight">\(y \sim \mathcal U(R_Q)\)</span> and <span class="math notranslate nohighlight">\(z \sim \mathrm{Ter}_{\rho}\)</span>, we have <span class="math notranslate nohighlight">\(\norm{yz} \le C\sqrt{N}\norm{y}\norm{z}\)</span> with probability approximately:</p>
<div class="math notranslate nohighlight">
\[\mathrm{erf}\left(\frac{C\sqrt{6}\norm y}{\sqrt{1-\rho}\cdot Q}\right)^N \overset{\rho = 1/3}{\approx} \mathrm{erf}(3C)^N.\]</div>
</section>
</div><div class="proof admonition" id="proof">
<p>Proof. Using the central limit theorem as in <a class="reference internal" href="#equation-central-limit-approx">(2)</a> and <a class="reference internal" href="#uniform-times-ternary">Lemma 2</a> we have:</p>
<div class="math notranslate nohighlight">
\[\P(\abs{(yz)_i} \le C\sqrt{N}\norm y) \approx \mathrm{erf} \left( \frac{C\norm y}{\sqrt{2\cdot \mathrm{Var}(y_iz_i)}}\right) = \mathrm{erf} \left( \frac{C\norm y}{\sqrt{2(1-\rho)\mathrm{Var}(y_i)}}\right).\]</div>
<p>For the uniform distribution we have <span class="math notranslate nohighlight">\(\mathrm{Var}(y_i) = ((Q+1)^2-1)/12\)</span>.
Now <span class="math notranslate nohighlight">\(\sqrt{\mathrm{Var}(y_i)} \approx Q/\sqrt{12}\)</span> is very accurate for large <span class="math notranslate nohighlight">\(Q\)</span>.</p>
<p>Finally, we estimate <span class="math notranslate nohighlight">\(\P(\norm{yz} \le C\sqrt{N}\norm y) \approx \P(\abs{(yz)_i} \le C\sqrt N \norm y)^N\)</span> and the claim follows.
Only an approximation is accurate in this case since <span class="math notranslate nohighlight">\((yz)_i\)</span> and <span class="math notranslate nohighlight">\((yz)_j\)</span> for <span class="math notranslate nohighlight">\(i\neq j\)</span> are not statistically independent anymore.
The reason is that:</p>
<div class="math notranslate nohighlight">
\[\P(y_iz_i =  y_i z_j) = \P(z_i = z_j) = \rho^2 + (1/2) \cdot (1-\rho)^2 \overset{\rho = 1/3}{=} 1/3.\]</div>
<p>In total, one summand inside <span class="math notranslate nohighlight">\((yz)_i\)</span> and <span class="math notranslate nohighlight">\((yz)_j\)</span> is equal with probability <span class="math notranslate nohighlight">\(1/3\)</span>, and <span class="math notranslate nohighlight">\(k\)</span> summands are equal with probability <span class="math notranslate nohighlight">\((1/3)^k\)</span> (for <span class="math notranslate nohighlight">\(\rho = 1/3\)</span>).
Nevertheless, we assume independency of the family <span class="math notranslate nohighlight">\(((yz)_i)_{i \in \{0,\dots,N-1\}}\)</span> anyway, since this effect becomes negligible for large <span class="math notranslate nohighlight">\(N\)</span> (even though we have <span class="math notranslate nohighlight">\(N-1\)</span> choices for <span class="math notranslate nohighlight">\(j\)</span> in <span class="math notranslate nohighlight">\((yz)_j\)</span> to compare with a fixed <span class="math notranslate nohighlight">\((yz)_i\)</span>).</p>
</div>
<p>The above probability is largely dependent on the size of <span class="math notranslate nohighlight">\(\norm y\)</span> and <span class="math notranslate nohighlight">\(C\)</span>.
Since <span class="math notranslate nohighlight">\(y\)</span> contains uniformly sampled coefficients, <span class="math notranslate nohighlight">\(\norm y\)</span> is regularly about the size of <span class="math notranslate nohighlight">\(Q/2\)</span>.
For example:</p>
<div class="math notranslate nohighlight">
\[
\P\left(\norm y \ge \frac{Q}{2}-\frac{Q}{2}\frac{1}{N}\right) = 1 - \P\left(\abs {y_0} &lt; \frac{Q}{2}-\frac{Q}{2}\frac{1}{N}\right)^N = 1 - \left(\frac{Q-Q/N}{Q}\right)^N \approx 1 - e^{-1} \ge 0.63
\]</div>
<p>A demonstration of the value in <a class="reference internal" href="#multiplication-bound-uniform-ternary">Theorem 4</a> in practice (notice that for <span class="math notranslate nohighlight">\(C=2\)</span> the bound gets exceeded with probability around <span class="math notranslate nohighlight">\(0.002\)</span>):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Q</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">counter</span><span class="p">,</span> <span class="n">iterations</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="o">*</span><span class="n">speed</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">iterations</span><span class="p">):</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">generate_uniform_distribution</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="o">-</span><span class="n">Q</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">Q</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">generate_ternary_distribution</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="c1"># rho = 1/3</span>
    <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">C</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="o">*</span><span class="n">y</span><span class="o">.</span><span class="n">norm</span><span class="p">():</span>
        <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">counter</span><span class="si">}</span><span class="s2"> out of </span><span class="si">{</span><span class="n">iterations</span><span class="si">}</span><span class="s2"> satisfied bound (ratio </span><span class="si">{</span><span class="n">counter</span><span class="o">/</span><span class="n">iterations</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
<span class="n">norm_average</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">generate_uniform_distribution</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="o">-</span><span class="n">Q</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">Q</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">iterations</span><span class="p">)])</span> <span class="o">//</span> <span class="n">iterations</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Probability in theorem </span><span class="si">{</span><span class="n">erf</span><span class="p">(</span><span class="n">norm_average</span><span class="o">*</span><span class="n">C</span><span class="o">*</span><span class="mi">3</span><span class="o">/</span><span class="n">Q</span><span class="p">)</span><span class="o">**</span><span class="n">N</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>998 out of 1000 satisfied bound (ratio 0.998)
Probability in theorem 0.9981059300560312
</pre></div>
</div>
</div>
</div>
</section>
<section id="the-case-gaussian-times-ternary">
<h4>The case “Gaussian” times “ternary”<a class="headerlink" href="#the-case-gaussian-times-ternary" title="Permalink to this headline">#</a></h4>
<p>Essentially, we can transform our analysis from the previous section to this case.
So, let <span class="math notranslate nohighlight">\(R\)</span>-elements <span class="math notranslate nohighlight">\(y,z\)</span> be sampled as <span class="math notranslate nohighlight">\(y \sim \mathcal N_d(0,\sigma^2)\)</span>, <span class="math notranslate nohighlight">\(z \sim \mathrm{Ter}_\rho\)</span> for <span class="math notranslate nohighlight">\(\sigma \ge 1\)</span>.
Now, using the argument in <a class="reference internal" href="#uniform-times-ternary">Lemma 2</a> and the value of <a class="reference internal" href="#discrete-variance">Lemma 1</a>, we have for integer random variables <span class="math notranslate nohighlight">\(Y \sim \mathcal N_d(0,\sigma^2)\)</span> and <span class="math notranslate nohighlight">\(Z \sim \mathrm{Ter}_\rho\)</span>:</p>
<div class="math notranslate nohighlight">
\[
\mathrm{Var}(YZ) = (\sigma^2 + 1/12)(1-\rho)
\]</div>
<div class="proof theorem admonition" id="multiplication-bound-gaussian-ternary">
<p class="admonition-title"><span class="caption-number">Theorem 5 </span> (Norm bound for multiplying Gaussian times ternary in <span class="math notranslate nohighlight">\(R\)</span>)</p>
<section class="theorem-content" id="proof-content">
<p>For <span class="math notranslate nohighlight">\(R\)</span>-elements <span class="math notranslate nohighlight">\(y \sim \mathcal N_d(0,\sigma^2)\)</span> and <span class="math notranslate nohighlight">\(z \sim \mathrm{Ter}_{\rho}\)</span>, we have <span class="math notranslate nohighlight">\(\norm{yz} \le C\sqrt{N}\norm{y}\)</span> with probability approximately:</p>
<div class="math notranslate nohighlight">
\[\mathrm{erf} \left( \frac{C\norm y}{\sqrt{2(1-\rho)(\sigma^2+1/12)}}\right)^N \overset{\rho = 1/3}{\approx} \mathrm{erf}(\sqrt{3}C)^N.\]</div>
</section>
</div><div class="proof admonition" id="proof">
<p>Proof. The proof works as the proof of <a class="reference internal" href="#multiplication-bound-uniform-ternary">Theorem 4</a>.
Using the central limit theorem as in <a class="reference internal" href="#equation-central-limit-approx">(2)</a> and <a class="reference internal" href="#uniform-times-ternary">Lemma 2</a> once again, we have:</p>
<div class="math notranslate nohighlight">
\[\P(\abs{(yz)_i} \le C\sqrt{N}\norm y) \approx \mathrm{erf} \left( \frac{C\norm y }{\sqrt{2\cdot \mathrm{Var}(y_iz_i)}}\right) = \mathrm{erf} \left( \frac{C\norm y}{\sqrt{2(1-\rho)(\sigma^2+1/12)}}\right).\]</div>
<p>Now the exact value inside <span class="math notranslate nohighlight">\(\mathrm{erf}(\cdot)\)</span> is largely dependent on <span class="math notranslate nohighlight">\(\norm y\)</span> and thus on <span class="math notranslate nohighlight">\(N\)</span> itself.
For a detailed analysis of <span class="math notranslate nohighlight">\(\norm y\)</span>, it is important to consider <a class="reference internal" href="#sampling-bound">Theorem 2</a> for a fixed <span class="math notranslate nohighlight">\(N\)</span> to obtain a better probability estimation, but for simplicity, it is reasonable to assume that <span class="math notranslate nohighlight">\(\norm y \ge 2\sigma\)</span>, which regularly already holds for quite small <span class="math notranslate nohighlight">\(N\)</span>.
Furthermore, we have used <a class="reference internal" href="#discrete-variance">Lemma 1</a> for the variance estimation, whose square root is roughly <span class="math notranslate nohighlight">\(\sigma\)</span>.</p>
</div>
<p>Remark: If <span class="math notranslate nohighlight">\(N \ge 2^{10}\)</span>, then <span class="math notranslate nohighlight">\(\norm y \ge 3\sigma\)</span> with high probability.
In this case, the factor inside <span class="math notranslate nohighlight">\(\mathrm{erf}(\cdot)\)</span> is already close to the one in <a class="reference internal" href="#multiplication-bound-uniform-ternary">Theorem 4</a>.</p>
<p>Once more we want to illustrate our result by checking computationally if the bound in the theorem is indeed satisfied.
To not get caught up in precision errors regarding <span class="math notranslate nohighlight">\(\norm y\)</span>, we only will check on samples with a given norm, e.g. <span class="math notranslate nohighlight">\(3\sigma\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">N</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">counter</span><span class="p">,</span> <span class="n">iterations</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5000</span><span class="o">*</span><span class="n">speed</span>
<span class="n">y_norm</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">sigma</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">iterations</span><span class="p">):</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">generate_gaussian_distribution</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">y</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="o">!=</span> <span class="n">y_norm</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">generate_gaussian_distribution</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">generate_ternary_distribution</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">C</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="o">*</span><span class="n">y_norm</span><span class="p">:</span>
        <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">counter</span><span class="si">}</span><span class="s2"> out of </span><span class="si">{</span><span class="n">iterations</span><span class="si">}</span><span class="s2"> satisfied bound (ratio </span><span class="si">{</span><span class="n">counter</span><span class="o">/</span><span class="n">iterations</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
<span class="n">probability</span> <span class="o">=</span> <span class="n">erf</span><span class="p">(</span> <span class="p">(</span><span class="n">C</span><span class="o">*</span><span class="n">y_norm</span><span class="p">)</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">((</span><span class="mi">4</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">sigma</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">12</span><span class="p">)))</span> <span class="p">)</span><span class="o">**</span><span class="n">N</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Probability in theorem </span><span class="si">{</span><span class="n">probability</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>4868 out of 5000 satisfied bound (ratio 0.9736)
Probability in theorem 0.9838201795058529
</pre></div>
</div>
</div>
</div>
</section>
<section id="conclusion-on-the-expansion-factor">
<span id="conclusion-on-delta-r"></span><h4>Conclusion on the expansion factor<a class="headerlink" href="#conclusion-on-the-expansion-factor" title="Permalink to this headline">#</a></h4>
<p>Our results on the multiplicative norm-bound in the ring <span class="math notranslate nohighlight">\(R\)</span> with the general estimation</p>
<div class="math notranslate nohighlight">
\[\norm{ab} \le \delta_R \norm a \norm b\]</div>
<p>let us conjecture that <span class="math notranslate nohighlight">\(\delta_R\)</span> is approximately <span class="math notranslate nohighlight">\(\sqrt{N}\)</span> (and not <span class="math notranslate nohighlight">\(N\)</span>) in special cases.
The two above theorems regarding <span class="math notranslate nohighlight">\(\delta_R \approx \sqrt{N}\)</span> mainly hold, because <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span>’s coefficients were i.i.d. samples with mean zero (as e.g. in <a class="reference internal" href="#uniform-times-ternary">Lemma 2</a>), which is decisive for the application of the central limit theorem.
We will commonly use the distributions <span class="math notranslate nohighlight">\(\mathrm{Ter}_{1/3}, \mathcal U(R_Q)\)</span> and <span class="math notranslate nohighlight">\(\mathcal N_d(0,\sigma^2)\)</span> (all with mean zero) for generating elements within our cryptographic constructions.
Almost all variables used later, except for predetermined messages, will thus satisfy the <span class="math notranslate nohighlight">\(\delta_R := \sqrt{N}\)</span> constraint.
Therefore we treat the rare case as <span class="math notranslate nohighlight">\(\delta_R' := N\)</span> and use <span class="math notranslate nohighlight">\(\delta_R\)</span> respectively <span class="math notranslate nohighlight">\(\delta_R'\)</span> for our error analysis.</p>
</section>
</section>
</section>
<section id="security">
<span id="id16"></span><h2>Security<a class="headerlink" href="#security" title="Permalink to this headline">#</a></h2>
<section id="the-decision-rlwe-problem">
<h3>The Decision-RLWE problem<a class="headerlink" href="#the-decision-rlwe-problem" title="Permalink to this headline">#</a></h3>
<p>In this section, we provide the details regarding the security of encryption schemes, whose ciphertexts are based upon <span class="math notranslate nohighlight">\(R\)</span> and its “Learning with errors” problem (<span class="math notranslate nohighlight">\(R\)</span>-LWE).
An extensive overview of the whole topic is given in <span id="id17">[<a class="reference internal" href="#id62" title="Chris Peikert. A decade of lattice cryptography. Cryptology ePrint Archive, Paper 2015/939, 2015. https://eprint.iacr.org/2015/939. URL: https://eprint.iacr.org/2015/939.">Peikert, 2015</a>]</span>, especially Section 4.4, to which we refer as a source for the following definitions.</p>
<p>As a first step, we define the RLWE distribution according to Definition 4.4.1. in <span id="id18">[<a class="reference internal" href="#id62" title="Chris Peikert. A decade of lattice cryptography. Cryptology ePrint Archive, Paper 2015/939, 2015. https://eprint.iacr.org/2015/939. URL: https://eprint.iacr.org/2015/939.">Peikert, 2015</a>]</span>, which already contains the necessary structure for later defining RLWE ciphertexts.</p>
<div class="proof definition admonition" id="RLWE-distribution">
<p class="admonition-title"><span class="caption-number">Definition 2 </span> (RLWE distribution)</p>
<section class="definition-content" id="proof-content">
<p>For a fixed (secret key) <span class="math notranslate nohighlight">\(s \in R_Q\)</span> and a preselected error distribution <span class="math notranslate nohighlight">\(\chi\)</span>, we say that <span class="math notranslate nohighlight">\((a,b) \in R_Q^2\)</span> is sampled from the RLWE distribution <span class="math notranslate nohighlight">\(A_{s,\chi}\)</span>, if:</p>
<div class="math notranslate nohighlight">
\[(a,b) := (a, -a\cdot s + e), \qquad a \sim \mathcal U(R_Q), e \sim \chi.\]</div>
</section>
</div><p>Following up, we assign a problem to the RLWE distribution, which a cryptographic adversary technically has to solve for “learning” information about the distribution (i.e. <span class="math notranslate nohighlight">\(s\)</span>) despite dealing “with errors” <span class="math notranslate nohighlight">\(e\)</span>.</p>
<div class="proof definition admonition" id="decision-RLWE">
<p class="admonition-title"><span class="caption-number">Definition 3 </span> (Decision-RLWE problem)</p>
<section class="definition-content" id="proof-content">
<p>Determine (with an non-negligible advantage) for <span class="math notranslate nohighlight">\(n\)</span> given i.i.d. samples <span class="math notranslate nohighlight">\((a_i,b_i) \in R_Q^2\)</span>, whether they are either sampled from <span class="math notranslate nohighlight">\(A_{s,\chi}\)</span> (with <span class="math notranslate nohighlight">\(s \sim \mathcal U(R_Q)\)</span>) or from <span class="math notranslate nohighlight">\(U(R_Q)^2\)</span>.</p>
</section>
</div><p>Naturally, here we are only allowed to work with a quite small number (typically polynomial in the ring degree <span class="math notranslate nohighlight">\(N\)</span>) of samples, to prevent the problem from becoming too easy.</p>
<p>Generally speaking, the security reductions, which reduce the Decision-RLWE problem to a well-known problem over lattices, are cumbersome to formulate precisely and difficult to prove.
Thus, these kinds of security discussions are extensive topics on their own, and the variety among the security principles would be too ambitious to break down.
Therefore, later in <a class="reference internal" href="#remarks-on-security"><span class="std std-ref">Remarks on the security framework for FHE</span></a>, we will only collect some selected remarks about RLWE-distributed ciphertext security, which are particularly important for constructing an efficient fully homomorphic encryption scheme.
But first, let us formulate the security reduction, which requires a quick <a class="reference internal" href="#background-on-lattices"><span class="std std-ref">Background on lattices</span></a>.</p>
<div class="proof property admonition" id="RLWE-security">
<p class="admonition-title"><span class="caption-number">Property 2 </span> (Security reduction from Decision-RLWE to <span class="math notranslate nohighlight">\(\mathrm{SVP}_\gamma\)</span>)</p>
<section class="property-content" id="proof-content">
<p>As mentioned in Theorem 4.4.3. of <span id="id19">[<a class="reference internal" href="#id62" title="Chris Peikert. A decade of lattice cryptography. Cryptology ePrint Archive, Paper 2015/939, 2015. https://eprint.iacr.org/2015/939. URL: https://eprint.iacr.org/2015/939.">Peikert, 2015</a>]</span>, the Decision-RLWE problem with proper parameters is at least as hard as quantumly solving the <span class="math notranslate nohighlight">\(\gamma\)</span>-Approximate Shortest Vector Problem (<span class="math notranslate nohighlight">\(\mathrm{SVP}_\gamma\)</span>) over ideal lattices.</p>
</section>
</div></section>
<section id="background-on-lattices">
<span id="id20"></span><h3>Background on lattices<a class="headerlink" href="#background-on-lattices" title="Permalink to this headline">#</a></h3>
<p>Given a “lattice basis” <span class="math notranslate nohighlight">\(B = \{\vec{b_1},\dots,\vec{b_n}\}\)</span> of linearly independent vectors <span class="math notranslate nohighlight">\(\vec{b_i} \in \R^n\)</span>, define the corresponding (full-rank) lattice as:</p>
<div class="math notranslate nohighlight">
\[\mathcal L := \mathcal L(B) := \left\{\sum_{i=1}^n z_i\vec{b_i} \mid z_i \in \Z \right\}.\]</div>
<p>Let moreover <span class="math notranslate nohighlight">\(\lambda_1 := \min_{0 \neq \vec v \in \mathcal L} \lvert\lvert \vec v \rvert\rvert\)</span> denote the length of the shortest non-zero vector in <span class="math notranslate nohighlight">\(\mathcal L\)</span> with respect to a norm (usually the euclidean norm in <span class="math notranslate nohighlight">\(\R^n\)</span>).</p>
<p>Ideal lattices now have the additional property of corresponding to ideals <span class="math notranslate nohighlight">\(I\)</span> of the ring <span class="math notranslate nohighlight">\(R\)</span>.
In this connection, it is very important, which embedding from generators (polynomials) of <span class="math notranslate nohighlight">\(I\)</span> to generators (integer vectors) of <span class="math notranslate nohighlight">\(\mathcal L \subset \Z^N\)</span> is chosen.
For example, one can choose the straightforward coefficient embedding and set</p>
<div class="math notranslate nohighlight">
\[\mathcal L(I) = \left\langle(g_0,\dots,g_{N-1}) \mid g = \sum_{i=0}^{N-1} g_i x^i \in I \right\rangle \subset \Z^N.\]</div>
<p>It is clear from the description that <span class="math notranslate nohighlight">\(\mathcal L(I) \subset \Z^N\)</span> is isomorphic to <span class="math notranslate nohighlight">\(I \subset R\)</span> as an additive group.
This fact illustrates the close relationship between the ring <span class="math notranslate nohighlight">\(R\)</span> and ideal lattices and puts the above security reduction from RLWE to lattice problems into context.
Nevertheless, there is a lot more to state about more sophisticated embeddings (see Section 4.3.3. of <span id="id21">[<a class="reference internal" href="#id62" title="Chris Peikert. A decade of lattice cryptography. Cryptology ePrint Archive, Paper 2015/939, 2015. https://eprint.iacr.org/2015/939. URL: https://eprint.iacr.org/2015/939.">Peikert, 2015</a>]</span>), which feature more favorable qualities and play a crucial role in the proof of the security reduction of RLWE.</p>
<p>The following definition refers directly to Definition 2.2.2 in <span id="id22">[<a class="reference internal" href="#id62" title="Chris Peikert. A decade of lattice cryptography. Cryptology ePrint Archive, Paper 2015/939, 2015. https://eprint.iacr.org/2015/939. URL: https://eprint.iacr.org/2015/939.">Peikert, 2015</a>]</span>.</p>
<div class="proof definition admonition" id="approximate-shortest-vector-problem">
<p class="admonition-title"><span class="caption-number">Definition 4 </span> (Approximate Shortest Vector Problem <span class="math notranslate nohighlight">\(\mathrm{SVP}_\gamma\)</span>)</p>
<section class="definition-content" id="proof-content">
<p>Given a (full-rank) lattice basis <span class="math notranslate nohighlight">\(B\)</span> of an <span class="math notranslate nohighlight">\(n\)</span>-dimensional lattice <span class="math notranslate nohighlight">\(\mathcal L(B)\)</span>, find a <span class="math notranslate nohighlight">\(0 \neq \vec v \in \mathcal L\)</span> with <span class="math notranslate nohighlight">\(\norm {\vec v} \le \gamma(n) \cdot \lambda_1\)</span>.</p>
</section>
</div><p>Notice that, if <span class="math notranslate nohighlight">\(\gamma = 1\)</span>, we obtain the special case of the (absolute) Shortest Vector Problem (SVP).</p>
<div class="admonition-conjectured-quantum-np-hardness-of-mathrm-svp-gamma admonition">
<p class="admonition-title">Conjectured (quantum) NP-hardness of <span class="math notranslate nohighlight">\(\mathrm{SVP}_\gamma\)</span></p>
<p>In <a class="reference internal" href="#RLWE-security">Property 2</a>, <span class="math notranslate nohighlight">\(\gamma(n)\)</span> is a polynomial function in <span class="math notranslate nohighlight">\(n\)</span>.
As pointed out in Section 4.3.4 of <span id="id23">[<a class="reference internal" href="#id62" title="Chris Peikert. A decade of lattice cryptography. Cryptology ePrint Archive, Paper 2015/939, 2015. https://eprint.iacr.org/2015/939. URL: https://eprint.iacr.org/2015/939.">Peikert, 2015</a>]</span>, such a <span class="math notranslate nohighlight">\(\gamma\)</span> still results in an exponential (in <span class="math notranslate nohighlight">\(n\)</span>) running time for the best known (quantum) algorithms to solve <span class="math notranslate nohighlight">\(\mathrm{SVP}_\gamma\)</span> on ideal lattices.</p>
</div>
</section>
<section id="remarks-on-the-security-framework-for-fhe">
<span id="remarks-on-security"></span><h3>Remarks on the security framework for FHE<a class="headerlink" href="#remarks-on-the-security-framework-for-fhe" title="Permalink to this headline">#</a></h3>
<p>The following remarks tackle the requirements of <a class="reference internal" href="#decision-RLWE">Definition 3</a>, which need to be partly altered to serve as an efficient framework for FHE:</p>
<ol class="simple">
<li><p>The error distribution (in our case this will be <span class="math notranslate nohighlight">\(\mathcal N_d(0,\sigma^2)\)</span>) must be chosen carefully.
Informally speaking, a larger standard deviation <span class="math notranslate nohighlight">\(\sigma\)</span> corresponds to a smaller <span class="math notranslate nohighlight">\(\gamma\)</span>, which then makes <span class="math notranslate nohighlight">\(\mathrm{SVP}_\gamma\)</span> harder.
In contrast to that, we are also interested in keeping the error size (thus <span class="math notranslate nohighlight">\(\sigma\)</span>) very small, to perform more homomorphic operations in a row without needing to perform a costly bootstrapping operation in between.</p></li>
<li><p>It is important to note, that in <span id="id24">[<a class="reference internal" href="#id63" title="Adeline Langlois and Damien Stehlé. Hardness of decision (r)lwe for any modulus. IACR Cryptol. ePrint Arch., 2012:91, 2012.">Langlois and Stehlé, 2012</a>]</span> it has been proven that the security of Decision-RLWE does not rely on specific number of theoretical properties of the modulus <span class="math notranslate nohighlight">\(Q\)</span> and hence we conveniently can set <span class="math notranslate nohighlight">\(Q\)</span> to be a large power of two.</p></li>
<li><p>Additionally, it is obstructive for our bootstrapping method to use a secret key <span class="math notranslate nohighlight">\(s\)</span> sampled from <span class="math notranslate nohighlight">\(\mathcal U(R_Q)\)</span>.
It can be shown that we even may assume <span class="math notranslate nohighlight">\(s \sim \chi\)</span> without changing the above theorem (see Section 4.4.1 in <span id="id25">[<a class="reference internal" href="#id62" title="Chris Peikert. A decade of lattice cryptography. Cryptology ePrint Archive, Paper 2015/939, 2015. https://eprint.iacr.org/2015/939. URL: https://eprint.iacr.org/2015/939.">Peikert, 2015</a>]</span>).
Still, for practical purposes, where we need to realize a distinction of cases (the cases being the values a <span class="math notranslate nohighlight">\(s\)</span>-coefficient can take), the ternary distribution comes into play.
This choice is a compromise since there is a lack of security proofs for a ternary secret key <span class="math notranslate nohighlight">\(s \sim \mathrm{Ter}_\rho\)</span> and moreover sparse ternary keys (with <span class="math notranslate nohighlight">\(\rho\)</span> close to <span class="math notranslate nohighlight">\(0\)</span>) are subject of security concerns.
More information can be found in Chapter 1 of <span id="id26">[<a class="reference internal" href="#id64" title="Yongwoo Lee, Daniele Micciancio, Andrey Kim, Rakyong Choi, Maxim Deryabin, Jieun Eom, and Donghoon Yoo. Efficient fhew bootstrapping with small evaluation keys, and applications to threshold homomorphic encryption. Cryptology ePrint Archive, Paper 2022/198, 2022. https://eprint.iacr.org/2022/198. URL: https://eprint.iacr.org/2022/198.">Lee <em>et al.</em>, 2022</a>]</span>.
To mention one last argument in favor of using them, ternary secret keys are part of the Homomorphic Encryption Standardization document <span id="id27">[<a class="reference internal" href="#id65" title="Martin Albrecht, Melissa Chase, Hao Chen, Jintai Ding, Shafi Goldwasser, Sergey Gorbunov, Shai Halevi, Jeffrey Hoffstein, Kim Laine, Kristin Lauter, Satya Lokam, Daniele Micciancio, Dustin Moody, Travis Morrison, Amit Sahai, and Vinod Vaikuntanathan. Homomorphic encryption security standard. Technical Report, HomomorphicEncryption.org, Toronto, Canada, November 2018.">Albrecht <em>et al.</em>, 2018</a>]</span>.</p></li>
</ol>
</section>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="the-bfv-scheme">
<span id="id28"></span><h1>The BFV scheme<a class="headerlink" href="#the-bfv-scheme" title="Permalink to this headline">#</a></h1>
<p>Before working on a bootstrapping algorithm for achieving fully homomorphic encryption, we need to set the framework of our scheme.
This will be done by considering a somewhat homomorphic encryption scheme, which enables us to encrypt, decrypt, and already perform a limited amount of additions and multiplications on a ciphertext.
Notice that for a ciphertext structure as in <a class="reference internal" href="#RLWE-distribution">Definition 2</a> we outlined a proof of security earlier.
Taking that as a foundation, all is left to specify where and how to hide a message within a ciphertext, which will be the salient feature of BFV ciphertexts.
The BFV (abbreviation of the names of the authors) scheme was initially published in <span id="id29">[<a class="reference internal" href="#id67" title="Junfeng Fan and Frederik Vercauteren. Somewhat practical fully homomorphic encryption. Cryptology ePrint Archive, Paper 2012/144, 2012. https://eprint.iacr.org/2012/144. URL: https://eprint.iacr.org/2012/144.">Fan and Vercauteren, 2012</a>]</span>, which will be our main reference throughout this chapter.</p>
<section id="asymmetric-key-generation">
<h2>Asymmetric key generation<a class="headerlink" href="#asymmetric-key-generation" title="Permalink to this headline">#</a></h2>
<p>To start defining our scheme, we solely could contemplate ciphertexts, which only make use of a secret key for encrypting messages.
However, extending the idea to an asymmetric encrypting scheme by introducing a public key can be achieved in a straightforward way.
That is due to the fact that a public key, which is in fact generated from the secret key, simply has a structure identical to any other ciphertext, i.e. a structure as in <a class="reference internal" href="#RLWE-distribution">Definition 2</a>.
It follows that the security reductions for any ciphertext (<a class="reference internal" href="#RLWE-security">Property 2</a>) also apply to the public key, whose exposure to any party is therefore unproblematic and of great avail.</p>
<section id="description-of-the-key-generation">
<h3>Description of the key generation<a class="headerlink" href="#description-of-the-key-generation" title="Permalink to this headline">#</a></h3>
<p>BFV’s <span class="math notranslate nohighlight">\(\texttt{keygen}\)</span> algorithm takes as an input a ring degree <span class="math notranslate nohighlight">\(N\)</span>, a ciphertext modulus <span class="math notranslate nohighlight">\(Q\)</span>, and a standard deviation <span class="math notranslate nohighlight">\(\sigma \ge 0\)</span>.
It outputs a public key <span class="math notranslate nohighlight">\(\mathrm{pk} \in R_Q^2\)</span> and a secret key <span class="math notranslate nohighlight">\(\mathrm{sk} \in R_Q\)</span>. It sets:</p>
<div class="math notranslate nohighlight">
\[\mathrm{sk} := s \sim \mathrm{Ter}_{1/3}, \qquad
\mathrm{pk} := (\mathrm{pk}_0, \mathrm{pk}_1) := (\mathrm{pk}_0,-\mathrm{pk}_0\cdot s-e)\]</div>
<p>with <span class="math notranslate nohighlight">\(\mathrm{pk}_0 \sim \mathcal U(R_Q)\)</span> and an error <span class="math notranslate nohighlight">\(e \sim \mathcal N_d(0,\sigma^2)\)</span>.</p>
<p>Notice that we can control our error distribution with the parameter standard deviation <span class="math notranslate nohighlight">\(\sigma \ge 0\)</span>.
As pointed out in <a class="reference internal" href="#remarks-on-security"><span class="std std-ref">Remarks on the security framework for FHE</span></a>, it is very important to choose the parameters carefully for preserving security hardness results.
Nevertheless, as we will later see, <span class="math notranslate nohighlight">\(\sigma\)</span> does not affect the number of possible homomorphic operations greatly.
Hence we conveniently set <span class="math notranslate nohighlight">\(\sigma = 1\)</span> while testing our implementations.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">keygen</span><span class="p">(</span><span class="n">key_size</span><span class="p">,</span> <span class="n">ciphertext_modulus</span><span class="p">,</span> <span class="n">standard_deviation</span><span class="p">):</span>
    <span class="n">N</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">STD</span> <span class="o">=</span> <span class="n">key_size</span><span class="p">,</span> <span class="n">ciphertext_modulus</span><span class="p">,</span> <span class="n">standard_deviation</span>
    <span class="n">sk</span> <span class="o">=</span> <span class="n">generate_ternary_distribution</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">pk_0</span> <span class="o">=</span> <span class="n">generate_uniform_distribution</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Q</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">generate_gaussian_distribution</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">STD</span><span class="p">)</span>
    <span class="n">pk_1</span> <span class="o">=</span> <span class="n">pk_0</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">.</span><span class="n">scalar_multiply</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">sk</span><span class="p">,</span> <span class="p">[</span><span class="n">pk_0</span><span class="p">,</span> <span class="n">pk_1</span><span class="p">]]</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="encryption">
<h2>Encryption<a class="headerlink" href="#encryption" title="Permalink to this headline">#</a></h2>
<section id="notion-of-bfv-ciphertexts">
<h3>Notion of BFV ciphertexts<a class="headerlink" href="#notion-of-bfv-ciphertexts" title="Permalink to this headline">#</a></h3>
<p>For encryption we take a previously into the polynomial <span class="math notranslate nohighlight">\(M \in R_T\)</span> encoded message, with the coefficients lying in <span class="math notranslate nohighlight">\(\mathbb{Z}_T\)</span>, where <span class="math notranslate nohighlight">\(T\)</span> is the plaintext modulus.
Encryption now essentially uses the public key to transform <span class="math notranslate nohighlight">\(M\)</span> into a ciphertext <span class="math notranslate nohighlight">\(\mathrm{ct} \in R_Q^2\)</span> defined as:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\mathrm{ct} := (\mathrm{ct}_0, \mathrm{ct}_1) := (z\cdot \mathrm{pk}_0+e_0,z\cdot \mathrm{pk}_1 + e_1 + \lfloor Q/T \rceil M) \in R_Q^2
\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(e_0, e_1, z \sim \mathcal N_d(0, \sigma^2)\)</span>.
To highlight the technique of encryption, we commonly will denote <span class="math notranslate nohighlight">\(\mathrm{ct}\)</span> as <span class="math notranslate nohighlight">\(\mathrm{BFV}_{Q,s}(M)\)</span>.</p>
<p>Notice that the BFV ciphertext as well fits the structure of a RLWE ciphertext as in <a class="reference internal" href="#RLWE-distribution">Definition 2</a>.
That is because <span class="math notranslate nohighlight">\(\mathrm{ct}_0\)</span> still looks uniformly at random, since multiplying with <span class="math notranslate nohighlight">\(z\)</span> and adding <span class="math notranslate nohighlight">\(e_0\)</span> does not change this in a meaningful way.
Furthermore, the second component containing the hidden secret key as <span class="math notranslate nohighlight">\(- \mathrm{pk}_0 \cdot s\)</span> and the error term <span class="math notranslate nohighlight">\(-z \cdot e + e_1 - e_0\cdot s\)</span> (which is slightly altered compared to an error generated from <span class="math notranslate nohighlight">\(\mathcal N_d(0,\sigma^2)\)</span>) can be shown to greatly resemble the structure of a RLWE ciphertext.
More details on the security of <span class="math notranslate nohighlight">\(\mathrm{ct}\)</span> are given in Section 8.2 of <span id="id30">[<a class="reference internal" href="#id68" title="Vadim Lyubashevsky, Chris Peikert, and Oded Regev. A toolkit for ring-lwe cryptography. Cryptology ePrint Archive, Paper 2013/293, 2013. https://eprint.iacr.org/2013/293. URL: https://eprint.iacr.org/2013/293.">Lyubashevsky <em>et al.</em>, 2013</a>]</span>.</p>
<p>The scaling of the message <span class="math notranslate nohighlight">\(M\)</span> by the large factor <span class="math notranslate nohighlight">\(\round{Q/T}\)</span> is also crucial since we need to distinguish it from the error during decrypting.</p>
<p>Remarks:</p>
<ul class="simple">
<li><p>For constructing something “cryptographically secure”, we want to blow up a (rather small) plaintext space <span class="math notranslate nohighlight">\(R_T\)</span> to a large ciphertext space <span class="math notranslate nohighlight">\(R_Q\)</span>, hence we ought to choose <span class="math notranslate nohighlight">\(Q\)</span> much larger than <span class="math notranslate nohighlight">\(T\)</span>.
This is also indispensable for realizing even the simplest operations on ciphertexts, not to mention decrypting.</p></li>
<li><p>For our purposes, we will only use powers of two for <span class="math notranslate nohighlight">\(T\)</span> and <span class="math notranslate nohighlight">\(Q\)</span>, such that the rounding of <span class="math notranslate nohighlight">\(Q/T\)</span> is technically obsolete, but nevertheless it should be mentioned as the scheme can be varied to arbitrary <span class="math notranslate nohighlight">\(T, Q\)</span> and the above is the usual BFV encryption formula.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">encrypt</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">plaintext_modulus</span><span class="p">,</span> <span class="n">ciphertext_modulus</span><span class="p">,</span> <span class="n">standard_deviation</span><span class="p">,</span> <span class="n">public_key</span><span class="p">):</span> 
    <span class="n">M</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">STD</span><span class="p">,</span> <span class="n">pk</span> <span class="o">=</span> <span class="n">message</span><span class="p">,</span> <span class="n">plaintext_modulus</span><span class="p">,</span> <span class="n">ciphertext_modulus</span><span class="p">,</span> <span class="n">standard_deviation</span><span class="p">,</span> <span class="n">public_key</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="s1">&#39;ring_degree&#39;</span><span class="p">)</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">generate_gaussian_distribution</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">STD</span><span class="p">)</span> 
    <span class="n">e_0</span> <span class="o">=</span> <span class="n">generate_gaussian_distribution</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">STD</span><span class="p">)</span>
    <span class="n">e_1</span> <span class="o">=</span> <span class="n">generate_gaussian_distribution</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">STD</span><span class="p">)</span>  
    <span class="n">ct_0</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">pk</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">e_0</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>
    <span class="n">ct_1</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">pk</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">scalar_multiply</span><span class="p">(</span><span class="n">Q</span> <span class="o">//</span> <span class="n">T</span><span class="p">))</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">e_1</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">ct_0</span><span class="p">,</span> <span class="n">ct_1</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>A short demonstration of encrypting:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">N</span> <span class="o">=</span> <span class="n">print_and_return</span><span class="p">(</span><span class="s2">&quot;Polynomial ring degree N&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="n">T</span> <span class="o">=</span> <span class="n">print_and_return</span><span class="p">(</span><span class="s2">&quot;Plaintext modulus T&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="n">Q</span> <span class="o">=</span> <span class="n">print_and_return</span><span class="p">(</span><span class="s2">&quot;Ciphertext modulus Q&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">20</span><span class="p">)</span>
<span class="n">STD</span> <span class="o">=</span> <span class="n">print_and_return</span><span class="p">(</span><span class="s2">&quot;Standard deviation STD&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">M</span> <span class="o">=</span> <span class="n">print_and_return</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Message: M&quot;</span><span class="p">,</span> <span class="n">generate_uniform_distribution</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="n">SK</span><span class="p">,</span> <span class="n">PK</span> <span class="o">=</span> <span class="n">keygen</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">STD</span><span class="p">)</span>
<span class="n">encryption</span> <span class="o">=</span> <span class="n">encrypt</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">STD</span><span class="p">,</span> <span class="n">PK</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Encryption components are&quot;</span><span class="p">,</span> <span class="n">encryption</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">and&quot;</span><span class="p">,</span> <span class="n">encryption</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Polynomial ring degree N = 4
Plaintext modulus T = 4
Ciphertext modulus Q = 1048576
Standard deviation STD = 1

Message: M = 2x^3 + 3x^2 + 2x + 1
Encryption components are 198847x^3 + 355252x^2 + 263392x + 390421 
and 64981x^3 + 942839x^2 + 432426x + 389173
</pre></div>
</div>
</div>
</div>
</section>
<section id="error-after-bfv-encryption">
<h3>Error after BFV encryption<a class="headerlink" href="#error-after-bfv-encryption" title="Permalink to this headline">#</a></h3>
<div class="proof lemma admonition" id="error-after-BFV-encryption">
<p class="admonition-title"><span class="caption-number">Lemma 3 </span> (Error after BFV-Encryption)</p>
<section class="lemma-content" id="proof-content">
<p>The error size within a BFV-ciphertext after BFV-encryption using <span class="math notranslate nohighlight">\(\sigma = 1\)</span> can be estimated as <span class="math notranslate nohighlight">\(C\sqrt{N}\)</span>. It holds that <span class="math notranslate nohighlight">\(C \approx 100\)</span> with high probability.</p>
</section>
</div><div class="proof admonition" id="proof">
<p>Proof. The error after BFV encryption is precisely <span class="math notranslate nohighlight">\(-z \cdot e + e_1 + e_0 \cdot s\)</span> with <span class="math notranslate nohighlight">\(z,e,e_0,e_1 \sim \mathcal N_d(0,1)\)</span> and <span class="math notranslate nohighlight">\(s \sim \mathrm{Ter}_{1/3}\)</span>.
Now, many details for determining the norm of multiplied ring elements generated from certain distributions can be examined.
But as the theoretical and computational conclusions in <a class="reference internal" href="#conclusion-on-delta-r"><span class="std std-ref">Conclusion on the expansion factor</span></a> suggest, we may use the reasonable estimation:</p>
<div class="math notranslate nohighlight">
\[\norm{x_1x_2} \le \sqrt{N}\norm{x_1}\norm{x_2}\]</div>
<p>for <span class="math notranslate nohighlight">\(x_1,x_2 \sim \mathcal N_d(0,1)\)</span>.</p>
<p>Coming back to the analysis, for a <span class="math notranslate nohighlight">\(\mathcal N_d(0,1)\)</span> element <span class="math notranslate nohighlight">\(x\)</span>, we have <span class="math notranslate nohighlight">\(\norm x \le 7\)</span> with overwhelming probability (see <a class="reference internal" href="#sampling-bound">Theorem 2</a>).
In total, we may estimate the error after BFV encryption as:</p>
<div class="math notranslate nohighlight">
\[\le 2 \cdot \sqrt{N} \cdot 7^2 + 7 \approx C \sqrt{N}.\]</div>
</div>
<p>In practice, <span class="math notranslate nohighlight">\(C\)</span> is indeed much smaller as the following computation points out.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">N</span><span class="p">,</span> <span class="n">iterations</span><span class="p">,</span> <span class="n">max_norm</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1000</span><span class="o">*</span><span class="n">speed</span><span class="p">,</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">iterations</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="n">generate_gaussian_distribution</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)]</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">generate_ternary_distribution</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">max_norm</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">s</span><span class="p">))</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">mod_small</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span><span class="p">(),</span> <span class="n">max_norm</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Maximum C after </span><span class="si">{</span><span class="n">iterations</span><span class="si">}</span><span class="s2"> iterations was </span><span class="si">{</span><span class="n">max_norm</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Maximum C after 1000 iterations was 7.75
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="decryption">
<h2>Decryption<a class="headerlink" href="#decryption" title="Permalink to this headline">#</a></h2>
<p>The decryption algorithm takes a BFV ciphertext <span class="math notranslate nohighlight">\(\mathrm{BFV}_{Q,\mathrm{sk}}(M) = \mathrm{ct} \in R_Q\)</span> and the secret key <span class="math notranslate nohighlight">\(\mathrm{sk}\)</span> as an input and it outputs the hidden message polynomial <span class="math notranslate nohighlight">\(M \in R_T\)</span>.
To begin with, it eliminates the random component inside a ciphertext by computing:</p>
<div class="math notranslate nohighlight">
\[
T\cdot (\mathrm{ct}_0 \cdot \mathrm{sk} + \mathrm{ct}_1)
\]</div>
<p>It is crucial to perform this computation entirely in <span class="math notranslate nohighlight">\(R\)</span>, that means without modular arithmetic:
If we instead use the ring <span class="math notranslate nohighlight">\(R_Q\)</span>, we would wind up with the term <span class="math notranslate nohighlight">\(T \lfloor Q/T \rceil M \in R_Q\)</span> within <span class="math notranslate nohighlight">\(\mathrm{ct}_1\)</span>, which then would degenerate any message.</p>
<p>To proceed, we integer-divide the coefficients of <span class="math notranslate nohighlight">\(T \cdot (\mathrm{ct}_0 \cdot \mathrm{sk} + \mathrm{ct}_1)\)</span> by <span class="math notranslate nohighlight">\(Q\)</span> (done by rounding the result-coefficients).
At last, we reduce the result by <span class="math notranslate nohighlight">\(T\)</span> to regain <span class="math notranslate nohighlight">\(M \in R_T\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">decrypt</span><span class="p">(</span><span class="n">ciphertext</span><span class="p">,</span> <span class="n">plaintext_modulus</span><span class="p">,</span> <span class="n">ciphertext_modulus</span><span class="p">,</span> <span class="n">secret_key</span><span class="p">):</span>
    <span class="n">ct</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">sk</span> <span class="o">=</span> <span class="n">ciphertext</span><span class="p">,</span> <span class="n">ciphertext_modulus</span><span class="p">,</span> <span class="n">plaintext_modulus</span><span class="p">,</span> <span class="n">secret_key</span>
    <span class="k">return</span> <span class="n">ct</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ct</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">q</span><span class="p">)</span><span class="o">.</span><span class="n">scalar_multiply</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">rounded_integer_divide</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We will give a demonstration of the decryption algorithm, which is a continuation of the above encryption example.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">N</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">2</span>
<span class="n">decryption</span> <span class="o">=</span> <span class="n">print_and_return</span><span class="p">(</span><span class="s2">&quot;Decryption of Message&quot;</span><span class="p">,</span> <span class="n">decrypt</span><span class="p">(</span><span class="n">encryption</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">SK</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Message </span><span class="si">{</span><span class="n">M</span><span class="si">}</span><span class="s2"> decrypted correctly? </span><span class="si">{</span><span class="n">M</span><span class="o">.</span><span class="n">is_equal_to</span><span class="p">(</span><span class="n">decryption</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">decryption_error</span> <span class="o">=</span> <span class="n">encryption</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">SK</span><span class="p">)</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">encryption</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">Q</span><span class="p">)</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">scalar_multiply</span><span class="p">(</span><span class="n">Q</span><span class="o">//</span><span class="n">T</span><span class="p">),</span> <span class="n">Q</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error size inside ciphertext: </span><span class="si">{</span><span class="n">decryption_error</span><span class="o">.</span><span class="n">mod_small</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Decryption of Message = 2x^3 + 3x^2 + 2x + 1
Message 2x^3 + 3x^2 + 2x + 1 decrypted correctly? True
Error size inside ciphertext: 2
</pre></div>
</div>
</div>
</div>
<section id="a-criterion-for-correct-decryption">
<h3>A criterion for correct decryption<a class="headerlink" href="#a-criterion-for-correct-decryption" title="Permalink to this headline">#</a></h3>
<p>It is of uttermost importance for a cryptographic scheme to be serviceable to formulate a criterion, which answers the question, of under which circumstances we still can decrypt correctly.
Moreover, this criterion will be our main limitation in terms of how frequently we need to interpose a (costly) bootstrapping procedure later (to reduce the error size).</p>
<p>Recall that a BFV-encrypted ciphertext unfolded looks like the following:</p>
<div class="math notranslate nohighlight">
\[ \mathrm{ct} = (z\cdot \mathrm{pk}_0 +e_0, -z \cdot \mathrm{pk}_0 \cdot \mathrm{sk} - z\cdot e +e_1 + \lfloor Q/T \rfloor M)\]</div>
<p>If we compute <span class="math notranslate nohighlight">\(T \cdot (\mathrm{ct}_0 \cdot \mathrm{sk} + \mathrm{ct}_1)\)</span>, we will be left with:</p>
<div class="math notranslate nohighlight">
\[ T (e_0\cdot \mathrm{sk}+e_1-z\cdot e) + T\cdot \lfloor Q/T \rceil M\]</div>
<p>This already properly illustrates, what we have to keep track of, if we still correctly want to decrypt any ciphertext that may have been manipulated.
The first term within brackets is called the decryption error.
Recall that at this point we still have to integer-divide by <span class="math notranslate nohighlight">\(Q\)</span>.
In order to obtain a correct decryption, we want the first summand to vanish, such that we are left with <span class="math notranslate nohighlight">\(M\)</span> only.
To make sure that this is indeed the case, we, on the one hand, have to set <span class="math notranslate nohighlight">\(Q\)</span> suitably larger than <span class="math notranslate nohighlight">\(T\)</span>, to gain a scaling factor <span class="math notranslate nohighlight">\(T/Q\)</span> as small as possible.
On the other hand, if the intrinsic error is of encryption kind, the polynomials <span class="math notranslate nohighlight">\(e_0, e_1, e, z, \mathrm{sk}\)</span> are required to have a small infinity norm, too, such that their composition does not exceed a certain size (see <a class="reference internal" href="#error-after-BFV-encryption">Lemma 3</a>).
Nevertheless, if the decryption error is composed differently because of previous ciphertext manipulations, we have no scope left to control the decryption query this way.</p>
<p>We summarize these observations by the following lemma, which even holds for an arbitrary error (accumulated during homomorphic operations), generalizing the above beyond encryption errors.</p>
<div class="proof lemma admonition" id="correct-BFV-decryption">
<p class="admonition-title"><span class="caption-number">Lemma 4 </span> (Correct BFV decryption)</p>
<section class="lemma-content" id="proof-content">
<p>A <span class="math notranslate nohighlight">\(\mathrm{BFV}_{Q,s}(M)\)</span> ciphertext with an intrinsic error <span class="math notranslate nohighlight">\(e\)</span> decrypts correctly, if <span class="math notranslate nohighlight">\(\norm e &lt; Q/(2T)\)</span>.</p>
</section>
</div><div class="proof admonition" id="proof">
<p>Proof. We follow the proof of Lemma 1 in <span id="id31">[<a class="reference internal" href="#id67" title="Junfeng Fan and Frederik Vercauteren. Somewhat practical fully homomorphic encryption. Cryptology ePrint Archive, Paper 2012/144, 2012. https://eprint.iacr.org/2012/144. URL: https://eprint.iacr.org/2012/144.">Fan and Vercauteren, 2012</a>]</span>.
The decryption algorithm works correctly if and only if the rounding as its final step does.
We enter the rounding step with <span class="math notranslate nohighlight">\(M + (T/Q)e\)</span>, which is treated as a polynomial with rational coefficients.
For <span class="math notranslate nohighlight">\((T/Q)e\)</span> to vanish during rounding, it is required that <span class="math notranslate nohighlight">\(\norm{(T/Q)e} &lt; 1/2\)</span>, which directly translates into the claim.</p>
</div>
<p>In the rest of the notebook, we want to implement homomorphic operations (addition and multiplication) on the BFV scheme and furthermore derive a bootstrapping algorithm to replace a big error with a small and fresh one.
For this process it is not particularly necessary to deal with the lengthy public-key ciphertexts, thus we introduce a simpler notion of a BFV ciphertext by:</p>
<div class="math notranslate nohighlight">
\[ \mathrm{BFV}_{Q,s}(M) := (a, -a\cdot\mathrm{sk}+e+\lfloor Q/T\rceil M)\]</div>
<p>where neither <span class="math notranslate nohighlight">\(a \in R_Q\)</span> is further specified nor the (initial) error <span class="math notranslate nohighlight">\(e \in R_Q\)</span>.</p>
</section>
</section>
<section id="adding-ciphertexts">
<h2>Adding ciphertexts<a class="headerlink" href="#adding-ciphertexts" title="Permalink to this headline">#</a></h2>
<p>Adding, in contrast to multiplying ciphertexts, is easier, computationally cheaper, and induces a smaller error by far.
It plainly can be done by adding the ciphertext components together (subtraction is done analogously).
Starting with two BFV ciphertexts:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathrm{ct}_0 := (a_0,b_0) := (a_0, -a_0\cdot \mathrm{sk} + e_0 + \lfloor Q/T\rceil M_0)\\
\mathrm{ct}_1 := (a_1,b_1) := (a_1, -a_1\cdot \mathrm{sk} + e_1 + \lfloor Q/T\rceil M_1)\end{split}\]</div>
<p>we define the sum of them as <span class="math notranslate nohighlight">\(\mathrm{sum} := (a_0+a_1,b_0+b_1)\)</span>.
The linearity of adding and the structure of BFV ciphertexts make sure that <span class="math notranslate nohighlight">\(\mathrm{sum}\)</span> gets decrypted correctly to <span class="math notranslate nohighlight">\(M_0+M_1\)</span> as follows:</p>
<div class="math notranslate nohighlight">
\[\mathrm{sum}_0 \cdot \mathrm{sk} + \mathrm{sum}_1 = \frac{Q}{T}(M_0+M_1) + (e_0 + e_1) \in R_Q\]</div>
<p>Note that the above actually only holds for powers of two <span class="math notranslate nohighlight">\(T &lt; Q\)</span>, since we would otherwise have to deal with another summand building upon the (nonzero) remainder of <span class="math notranslate nohighlight">\(Q\)</span> divided by <span class="math notranslate nohighlight">\(T\)</span> (see chapter 4 in <span id="id32">[<a class="reference internal" href="#id67" title="Junfeng Fan and Frederik Vercauteren. Somewhat practical fully homomorphic encryption. Cryptology ePrint Archive, Paper 2012/144, 2012. https://eprint.iacr.org/2012/144. URL: https://eprint.iacr.org/2012/144.">Fan and Vercauteren, 2012</a>]</span>).</p>
<p>We may now still decrypt correctly, given the new error <span class="math notranslate nohighlight">\(e_{\mathrm{sum}} = e_0+e_1\)</span> still satisfies the bound given in <a class="reference internal" href="#correct-BFV-decryption">Lemma 4</a>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">ciphertext1</span><span class="p">,</span> <span class="n">ciphertext2</span><span class="p">,</span> <span class="n">ciphertext_modulus</span><span class="p">):</span>
    <span class="n">ct1</span><span class="p">,</span> <span class="n">ct2</span><span class="p">,</span> <span class="n">Q</span> <span class="o">=</span> <span class="n">ciphertext1</span><span class="p">,</span> <span class="n">ciphertext2</span><span class="p">,</span> <span class="n">ciphertext_modulus</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">ct1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ct2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Q</span><span class="p">),</span> <span class="n">ct1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ct2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">Q</span><span class="p">)]</span>

<span class="k">def</span> <span class="nf">subtract</span><span class="p">(</span><span class="n">ciphertext1</span><span class="p">,</span> <span class="n">ciphertext2</span><span class="p">,</span> <span class="n">ciphertext_modulus</span><span class="p">):</span>
    <span class="n">ct1</span><span class="p">,</span> <span class="n">ct2</span><span class="p">,</span> <span class="n">Q</span> <span class="o">=</span> <span class="n">ciphertext1</span><span class="p">,</span> <span class="n">ciphertext2</span><span class="p">,</span> <span class="n">ciphertext_modulus</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">ct1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">ct2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Q</span><span class="p">),</span> <span class="n">ct1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">ct2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">Q</span><span class="p">)]</span>
</pre></div>
</div>
</div>
</div>
<p>As a demonstration, we test adding by computing <span class="math notranslate nohighlight">\(1+1=2 \in R_T\)</span> in ciphertext space:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">One_Encryption</span> <span class="o">=</span> <span class="n">encrypt</span><span class="p">(</span><span class="n">generate_constant_poly</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">T</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">STD</span><span class="p">,</span> <span class="n">PK</span><span class="p">)</span>
<span class="n">Two_Encryption</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="n">One_Encryption</span><span class="p">,</span> <span class="n">One_Encryption</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>
<span class="n">Two_Decryption</span> <span class="o">=</span> <span class="n">print_and_return</span><span class="p">(</span><span class="s2">&quot;Decryption of 2&quot;</span><span class="p">,</span> <span class="n">decrypt</span><span class="p">(</span><span class="n">Two_Encryption</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">SK</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Added 1+1 correctly? </span><span class="si">{</span><span class="n">Two_Decryption</span><span class="o">.</span><span class="n">is_equal_to</span><span class="p">(</span><span class="n">generate_constant_poly</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Decryption of 2 = 2
Added 1+1 correctly? True
</pre></div>
</div>
</div>
</div>
<section id="number-of-possible-additions">
<h3>Number of possible additions<a class="headerlink" href="#number-of-possible-additions" title="Permalink to this headline">#</a></h3>
<p>As an example, we will now answer the question of how many additions of freshly encrypted ciphertexts are possible, depending on the chosen parameters.
To successfully perform <span class="math notranslate nohighlight">\(k\)</span> additions, the total error size afterwards must not exceed <span class="math notranslate nohighlight">\(Q/(2T)\)</span>.
Using the triangle inequality and the error bound in <a class="reference internal" href="#error-after-BFV-encryption">Lemma 3</a> for a certain <span class="math notranslate nohighlight">\(C\)</span>, we have to ensure that:</p>
<div class="math notranslate nohighlight" id="equation-number-of-additions">
<span class="eqno">(3)<a class="headerlink" href="#equation-number-of-additions" title="Permalink to this equation">#</a></span>\[k &lt; \frac{Q}{2T\cdot C \sqrt{N}}\]</div>
<p>The procedure <span class="math notranslate nohighlight">\(\texttt{how-many-additions}\)</span> below enables us to run various experiments on adding ciphertexts.
It simulates the process of adding (freshly encrypted) ciphertexts and it outputs the maximum of possible (correct) additions, minimized over a number of iterations.
In doing so and compared to averaging the number of possible additions, it reflects the worst-case scenario, which is pivotal to consider while constructing a FHE scheme.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">how_many_additions</span><span class="p">(</span><span class="n">key_size</span><span class="p">,</span> <span class="n">plaintext_modulus</span><span class="p">,</span> <span class="n">ciphertext_modulus</span><span class="p">,</span> <span class="n">standard_deviation</span><span class="p">,</span> <span class="n">runs</span><span class="p">):</span>
    <span class="n">N</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">STD</span> <span class="o">=</span> <span class="n">key_size</span><span class="p">,</span> <span class="n">plaintext_modulus</span><span class="p">,</span> <span class="n">ciphertext_modulus</span><span class="p">,</span> <span class="n">standard_deviation</span>
    <span class="n">min_correct_additions</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">1000</span>
    <span class="n">SK</span><span class="p">,</span> <span class="n">PK</span> <span class="o">=</span> <span class="n">keygen</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">STD</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">runs</span><span class="p">):</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">random_message</span> <span class="o">=</span> <span class="n">generate_uniform_distribution</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">encrypted_message</span> <span class="o">=</span> <span class="n">encrypt</span><span class="p">(</span><span class="n">random_message</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">STD</span><span class="p">,</span> <span class="n">PK</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">min_correct_additions</span> <span class="o">&gt;</span> <span class="n">counter</span><span class="p">:</span>
            <span class="n">new_random_message</span> <span class="o">=</span> <span class="n">generate_uniform_distribution</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">encrypted_new_message</span> <span class="o">=</span> <span class="n">encrypt</span><span class="p">(</span><span class="n">new_random_message</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">STD</span><span class="p">,</span> <span class="n">PK</span><span class="p">)</span>
            <span class="n">random_message</span> <span class="o">=</span> <span class="n">decrypt</span><span class="p">(</span><span class="n">encrypted_message</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">SK</span><span class="p">)</span>
            <span class="n">sum_of_messages</span> <span class="o">=</span> <span class="n">random_message</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">new_random_message</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
            <span class="n">encrypted_message</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="n">encrypted_message</span><span class="p">,</span> <span class="n">encrypted_new_message</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">decrypt</span><span class="p">(</span><span class="n">encrypted_message</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">SK</span><span class="p">)</span><span class="o">.</span><span class="n">is_equal_to</span><span class="p">(</span><span class="n">sum_of_messages</span><span class="p">)</span> <span class="o">!=</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">min_correct_additions</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">min_correct_additions</span><span class="p">,</span> <span class="n">counter</span><span class="p">)</span>
                <span class="k">break</span>
            <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">min_correct_additions</span>
</pre></div>
</div>
</div>
</div>
<p>Taking <span class="math notranslate nohighlight">\(T=2, N=16, C=8, \sigma = 1\)</span> and <span class="math notranslate nohighlight">\(Q=2^8\)</span>, according to <a class="reference internal" href="#equation-number-of-additions">(3)</a>, we must be able to perform at least 4 additions, which the following computation underlines.
Remark: The computationally determined value of <span class="math notranslate nohighlight">\(C \approx 8\)</span> (from the section of <a class="reference internal" href="#error-after-BFV-encryption">Lemma 3</a>) should not be used at all for practical purposes, since the bound is only of probabilistic nature (see ibid.)
However, <span class="math notranslate nohighlight">\(C \approx 8\)</span> yields a close estimate:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">how_many_additions</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">500</span><span class="o">*</span><span class="n">speed</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>5
</pre></div>
</div>
</div>
</div>
</section>
<section id="parameter-impact">
<h3>Parameter impact<a class="headerlink" href="#parameter-impact" title="Permalink to this headline">#</a></h3>
<p>Finally, we want to affirm <a class="reference internal" href="#equation-number-of-additions">(3)</a> computationally by depicting a diagram, which illustrates the change of the scheme’s parameters and their impact on the (minimum) number of possible additions.
Because we generally work with powers of two for <span class="math notranslate nohighlight">\(N, T\)</span>, and <span class="math notranslate nohighlight">\(Q\)</span>, we will observe the behaviour of <span class="math notranslate nohighlight">\(\texttt{how-many-additions}\)</span> under doubling each of the parameters and present everything on an exponential/logarithmic scale.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">N</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">STD</span><span class="p">,</span> <span class="n">runs</span><span class="p">,</span> <span class="n">doublings</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">9</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="o">*</span><span class="n">speed</span><span class="p">,</span> <span class="mi">3</span>
<span class="n">doubling_N</span> <span class="o">=</span> <span class="p">[</span><span class="n">how_many_additions</span><span class="p">((</span><span class="mi">2</span><span class="o">**</span><span class="n">i</span><span class="p">)</span><span class="o">*</span><span class="n">N</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">STD</span><span class="p">,</span> <span class="n">runs</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">doublings</span><span class="p">)]</span>
<span class="n">doubling_T</span> <span class="o">=</span> <span class="p">[</span><span class="n">how_many_additions</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">i</span><span class="p">)</span><span class="o">*</span><span class="n">T</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">STD</span><span class="p">,</span> <span class="n">runs</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">doublings</span><span class="p">)]</span>
<span class="n">doubling_Q</span> <span class="o">=</span> <span class="p">[</span><span class="n">how_many_additions</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">i</span><span class="p">)</span><span class="o">*</span><span class="n">Q</span><span class="p">,</span> <span class="n">STD</span><span class="p">,</span> <span class="n">runs</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">doublings</span><span class="p">)]</span>
<span class="n">doubling_STD</span> <span class="o">=</span> <span class="p">[</span><span class="n">how_many_additions</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">i</span><span class="p">)</span><span class="o">*</span><span class="n">STD</span><span class="p">,</span> <span class="n">runs</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">doublings</span><span class="p">)]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">dpi</span><span class="o">=</span><span class="mi">150</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">doubling_N</span><span class="p">,</span> <span class="s1">&#39;--o&#39;</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;Doubling key size N&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">doubling_T</span><span class="p">,</span> <span class="s1">&#39;--o&#39;</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;Doubling plaintext modulus T&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">doubling_Q</span><span class="p">,</span> <span class="s1">&#39;--o&#39;</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;Doubling ciphertext modulus Q&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">doubling_STD</span><span class="p">,</span> <span class="s1">&#39;--o&#39;</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;Doubling standard deviation&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">yscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="n">base</span> <span class="o">=</span> <span class="mi">2</span><span class="p">);</span> <span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">doublings</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Minimum of correct additions after </span><span class="si">{</span><span class="n">runs</span><span class="si">}</span><span class="s2"> iterations</span><span class="se">\n</span><span class="s2"> (Logarithmic scale)&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Times of value doubling</span><span class="se">\n</span><span class="s2"> (Exponential Scale)&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/Thesis_60_0.png" src="_images/Thesis_60_0.png" />
</div>
</div>
<p>To summarize the above, we indeed computationally verify <a class="reference internal" href="#equation-number-of-additions">(3)</a> containing the factors <span class="math notranslate nohighlight">\(Q, T^{-1}\)</span> and <span class="math notranslate nohighlight">\(1/\sqrt{N}\)</span> as they each correspond to a dotted line.
Furthermore, the diagram shows that doubling the standard deviation <span class="math notranslate nohighlight">\(\sigma\)</span> is even worse than doubling <span class="math notranslate nohighlight">\(T\)</span> in terms of correct additions.</p>
</section>
</section>
<section id="multiplying-ciphertexts">
<h2>Multiplying ciphertexts<a class="headerlink" href="#multiplying-ciphertexts" title="Permalink to this headline">#</a></h2>
<section id="overview">
<h3>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">#</a></h3>
<p>Multiplying RLWE ciphertexts in a clever way is not only a crucial part of designing a homomorphic encryption scheme but it also can be seen as a whole concept in general, which can be extended to several special cases.
Some of these will later be considered during <a class="reference internal" href="#preparations-for-bootstrapping"><span class="std std-ref">Preparations for bootstrapping</span></a>, which underlines the relevance of multiplication for the entire FHE scheme.
For example, the bootstrapping procedure itself can be broken down to scaling up a message hidden in a RLWE ciphertext by a (large) factor.</p>
<p>The state-of-the-art FHE schemes would be significantly faster and more efficient if the inherent multiplication algorithms would be in any way comparable to addition procedures.
Apart from a more advanced description compared with addition, the main thing, which causes multiplication algorithms to be “expensive”, is the error resulting from it.
In the presented scheme, it seems inevitable that the error (during multiplication) will get multiplied by a certain factor, in contrast to addition, where we only added two errors.
Although we will explain some approaches to diminishing the size of this factor and thus the size of the error afterwards in general, scaling up the error size during multiplication procedures still cannot be entirely avoided.</p>
</section>
<section id="motivation">
<h3>Motivation<a class="headerlink" href="#motivation" title="Permalink to this headline">#</a></h3>
<p>Although we will use multiplication for the more general notion of RLWE ciphertexts later as well, we will first stick to the BFV case.
For simplicity, and according to our implementation with powers of two <span class="math notranslate nohighlight">\(T&lt;Q\)</span>, we will drop the rounding of <span class="math notranslate nohighlight">\(\round{Q/T}\)</span> from now on.
Taking two BFV ciphertexts of their form <span class="math notranslate nohighlight">\((a_i,-a_i\cdot s + e_i + (Q/T) M_i)\)</span> for messages <span class="math notranslate nohighlight">\(M_0,M_1\)</span>, we immediately observe that it is mandatory for a BFV multiplication algorithm to multiply the second components <span class="math notranslate nohighlight">\(-a_i\cdot s + e_i + (Q/T) M_i\)</span>, yielding a term including <span class="math notranslate nohighlight">\(M_0M_1\)</span>.
Because the additive structure is not compatible with multiplication in a linear way, we can already presume that we will obtain several summands, which are dispensable and, in the error case, even obstructive for further operations on ciphertexts.</p>
<p>In total, if we denote the BFV ciphertexts as <span class="math notranslate nohighlight">\((a_0,b_0)\)</span> and <span class="math notranslate nohighlight">\((a_1,b_1)\)</span>, the multiplication <span class="math notranslate nohighlight">\(b_0b_1\)</span> yields the following nine summands, which we will need to somehow regroup into three (a secret key component, an error and one containing the hidden <span class="math notranslate nohighlight">\(M_0M_1\)</span>) of a regular BFV ciphertext:</p>
<div class="math notranslate nohighlight" id="equation-b-0b-1">
<span class="eqno">(4)<a class="headerlink" href="#equation-b-0b-1" title="Permalink to this equation">#</a></span>\[\begin{split}\begin{split}
b_0b_1 &amp;= \underbrace{a_0a_1 \mathrm{sk}^2}_{\text{Precomputation of }\mathrm{sk}^2 \text{ is necessary}} \\
&amp;- \underbrace{(a_0e_1+a_1e_0)\mathrm{sk} - (a_0M_1+a_1M_0)( Q/T)\mathrm{sk}}_{\text{Gives rise to first component of the product}} \\
&amp;+ \underbrace{e_0e_1 + ( Q/T) (e_0M_1 +e_1M_0)}_{\text{Inevitable and large error term}} \\
&amp;+ \underbrace{(Q/T)^2 M_0M_1}_{\text{Wrongly scaled message product}}
\end{split}\end{split}\]</div>
<p>We will now describe these four aspects in detail.</p>
</section>
<section id="relinearization-keys">
<h3>Relinearization Keys<a class="headerlink" href="#relinearization-keys" title="Permalink to this headline">#</a></h3>
<p>We start with the problem of eliminating <span class="math notranslate nohighlight">\(a_0a_1\mathrm{sk}^2\)</span>.
For that we need an outsourced precomputation, i.e. an encryption of <span class="math notranslate nohighlight">\(\mathrm{sk}^2\)</span>, which clearly needs to be done by a party with knowledge of <span class="math notranslate nohighlight">\(\mathrm{sk}\)</span>.
Since encrypting always comes together with an (additive) error (see <a class="reference internal" href="#error-after-BFV-encryption">Lemma 3</a>) and we need to multiply the encryption of <span class="math notranslate nohighlight">\(\mathrm{sk}^2\)</span> afterwards with <span class="math notranslate nohighlight">\(a_0a_1\)</span>, we cannot let this error grow too much.
To clarify the latter, recall that multiplying with <span class="math notranslate nohighlight">\(a_0a_1\)</span> (or any other public ring element) works via multiplying both components of a BFV/RLWE ciphertext by <span class="math notranslate nohighlight">\(a_0a_1\)</span>, which also multiplies the intrinsic error with <span class="math notranslate nohighlight">\(a_0a_1\)</span>.</p>
<p>This sparks the idea of encrypting <span class="math notranslate nohighlight">\(\mathrm{sk}^2\)</span> via a larger auxiliary modulus <span class="math notranslate nohighlight">\(P\cdot Q\)</span> (for a large <span class="math notranslate nohighlight">\(P\)</span>), in order to scale down the error afterwards by dividing by <span class="math notranslate nohighlight">\(P\)</span> again.
Later, we will investigate this key concept further by introducing a general “rescaling” procedure.
Needless to say, we then need to encrypt <span class="math notranslate nohighlight">\(P\cdot \mathrm{sk}^2\)</span> instead of <span class="math notranslate nohighlight">\(\mathrm{sk}^2\)</span>, since the message, <span class="math notranslate nohighlight">\(P\cdot \mathrm{sk}^2\)</span>, will get divided by <span class="math notranslate nohighlight">\(P\)</span>, too.</p>
<p>The following algorithm computes the “relinearization keys”, named by the principle of making the multiplied ciphertext <span class="math notranslate nohighlight">\(b_0b_1\)</span> linear in <span class="math notranslate nohighlight">\(\mathrm{sk}\)</span> again.</p>
<p>The relinearization keys are set to:</p>
<div class="math notranslate nohighlight">
\[
\mathrm{rlk} := (\mathrm{rlk}_0, \mathrm{rlk}_1) := (\mathrm{rlk}_0, - \mathrm{rlk}_0 \cdot \mathrm{sk} + e_{\text{rlk}} + P\cdot\mathrm{sk}^2 ) \in R_{PQ}^2 
\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathrm{rlk}_0 \sim \mathcal U(R_{PQ})\)</span> and <span class="math notranslate nohighlight">\(e_{\text{rlk}} \sim \mathcal N_d(0, \sigma^2)\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">relinearization_key</span><span class="p">(</span><span class="n">ciphertext_modulus</span><span class="p">,</span> <span class="n">auxiliary_modulus</span><span class="p">,</span> <span class="n">standard_deviation</span><span class="p">,</span> <span class="n">secret_key</span><span class="p">):</span>
    <span class="n">Q</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">STD</span><span class="p">,</span> <span class="n">SK</span> <span class="o">=</span> <span class="n">ciphertext_modulus</span><span class="p">,</span> <span class="n">auxiliary_modulus</span><span class="p">,</span> <span class="n">standard_deviation</span><span class="p">,</span> <span class="n">secret_key</span>
    <span class="n">PQ</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">P</span><span class="o">*</span><span class="n">Q</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">SK</span><span class="p">,</span> <span class="s1">&#39;ring_degree&#39;</span><span class="p">)</span>
    <span class="n">rlk_0</span> <span class="o">=</span> <span class="n">generate_uniform_distribution</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PQ</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">e_rlk</span> <span class="o">=</span> <span class="n">generate_gaussian_distribution</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">STD</span><span class="p">)</span>
    <span class="n">rlk_1</span> <span class="o">=</span> <span class="n">SK</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">SK</span><span class="p">)</span><span class="o">.</span><span class="n">scalar_multiply</span><span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">rlk_0</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">SK</span><span class="p">)</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">e_rlk</span><span class="p">),</span> <span class="n">PQ</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">rlk_0</span><span class="p">,</span> <span class="n">rlk_1</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>It is important to note, that the parameter <span class="math notranslate nohighlight">\(\sigma\)</span> for the error distribution of <span class="math notranslate nohighlight">\(e_{\text{rlk}}\)</span> should greatly differ from the analogous parameter used during (regular) encryption.
In <span id="id33">[<a class="reference internal" href="#id67" title="Junfeng Fan and Frederik Vercauteren. Somewhat practical fully homomorphic encryption. Cryptology ePrint Archive, Paper 2012/144, 2012. https://eprint.iacr.org/2012/144. URL: https://eprint.iacr.org/2012/144.">Fan and Vercauteren, 2012</a>]</span>, Section 6.1, a precise analysis of this subject is given.
Again, because security issues are not the main concern of our implementations and large variances are obstructive to performances of homomorphic operations, we will overlook this fact by continuing to use <span class="math notranslate nohighlight">\(\sigma = 1\)</span> in both cases.</p>
<p>The following lemma (see Section 4 of <span id="id34">[<a class="reference internal" href="#id67" title="Junfeng Fan and Frederik Vercauteren. Somewhat practical fully homomorphic encryption. Cryptology ePrint Archive, Paper 2012/144, 2012. https://eprint.iacr.org/2012/144. URL: https://eprint.iacr.org/2012/144.">Fan and Vercauteren, 2012</a>]</span>) assesses the error after completing the relinerazation process, i.e. the error belonging to an encryption of <span class="math notranslate nohighlight">\(a_0a_1\mathrm{sk}^2\)</span>.</p>
<div class="proof lemma admonition" id="relinearization-error">
<p class="admonition-title"><span class="caption-number">Lemma 5 </span> (Relinearization error)</p>
<section class="lemma-content" id="proof-content">
<p>Assuming <span class="math notranslate nohighlight">\(\norm{e_{\text{rlk}}} \le D\)</span>, the error <span class="math notranslate nohighlight">\(e_{\text{rel}}\)</span> inside an encryption of <span class="math notranslate nohighlight">\(a_0a_1\mathrm{sk}^2\)</span> satisfies:</p>
<div class="math notranslate nohighlight">
\[\norm{e_{\text{rel}}} \le \frac{Q\cdot D \cdot N}{P} + \frac{N+1}{2}.\]</div>
</section>
</div><div class="proof admonition" id="proof">
<p>Proof. Set</p>
<div class="math notranslate nohighlight">
\[(r_0,r_1) := \left( \round{\frac{a_0a_1 \mathrm{rlk}_0}{P}}, \round{\frac{a_0a_1 \mathrm{rlk}_1}{P}} \right) \in R_Q^2.\]</div>
<p>Then <span class="math notranslate nohighlight">\(\norm{e_{\text{rel}}} = \norm{r_0 \mathrm{sk} + r_1 - a_0a_1\mathrm{sk}^2}\)</span>.
It follows that</p>
<div class="math notranslate nohighlight">
\[\norm{e_{\text{rel}}} = \norm{r_0 \mathrm{sk} + \round{\frac{a_0a_1(e_{\text{rlk}} - \mathrm{rlk}_0 \mathrm{sk})}{P}}}.\]</div>
<p>Now, we have <span class="math notranslate nohighlight">\(\norm{\round{a_0a_1e_{\text{rlk}}/P}} \le QDN/P\)</span>, because <span class="math notranslate nohighlight">\(a_0a_1 \in R_Q\)</span> and <span class="math notranslate nohighlight">\(N\)</span> is the worst-case expansion factor resulting from multiplying in <span class="math notranslate nohighlight">\(R\)</span>.
We are left to estimate a term in the shape of <span class="math notranslate nohighlight">\(\round c \mathrm{sk} - \round{c \cdot \mathrm{sk}} + 1/2\)</span>, with <span class="math notranslate nohighlight">\(c = a_0a_1\mathrm{rlk}_0/P \in \Q[x]/\langle x^N + 1\rangle\)</span>.
Because <span class="math notranslate nohighlight">\(\norm{\mathrm{sk}} = 1\)</span>, the “different rounding” for each coefficient is off by at most <span class="math notranslate nohighlight">\(1/2\)</span>, thus in total the infinity norm is bounded by <span class="math notranslate nohighlight">\(N/2 + 1/2\)</span>.
The claim follows.</p>
</div>
<p>In the above lemma, <span class="math notranslate nohighlight">\(P\)</span> should be selected such that <span class="math notranslate nohighlight">\(QDN/P &lt; 1\)</span>, i.e. keeping <span class="math notranslate nohighlight">\(e_{\text{rel}}\)</span> as small as possible while taking into account that the computational complexity increases with a larger <span class="math notranslate nohighlight">\(P\)</span>.
As shown in the proof, the summand <span class="math notranslate nohighlight">\((N+1)/2\)</span> is an estimator for a very unlikely worst case.
Equilibrating effects of summing rounded integers and <span class="math notranslate nohighlight">\(\mathrm{sk} \sim \mathrm{Ter}_{1/3}\)</span> lead to a way smaller error in the average case.</p>
</section>
<section id="core-of-multiplying">
<h3>Core of multiplying<a class="headerlink" href="#core-of-multiplying" title="Permalink to this headline">#</a></h3>
<p>After subtracting <span class="math notranslate nohighlight">\(a_0a_1\mathrm{sk}^2\)</span> from <span class="math notranslate nohighlight">\(b_0b_1\)</span> in <a class="reference internal" href="#equation-b-0b-1">(4)</a>, we proceed with eliminating the dispensable single <span class="math notranslate nohighlight">\(Q/T\)</span> inside <span class="math notranslate nohighlight">\((Q/T)^2 M_0M_1\)</span>.
Hence we need to scale the latter via integer-dividing (i.e. dividing and rounding) by <span class="math notranslate nohighlight">\(T/Q\)</span>, which can naturally only be done implicitly by operating on <span class="math notranslate nohighlight">\(b_0b_1\)</span>.
We will employ this technique as well for other terms consisting of <span class="math notranslate nohighlight">\(a_i\)</span> and <span class="math notranslate nohighlight">\(b_i\)</span>, see below.</p>
<p>Apart from the inevitable error term of multiplying in <a class="reference internal" href="#equation-b-0b-1">(4)</a>, we are now left with setting up the first component of the product ciphertext, which consists of a <span class="math notranslate nohighlight">\(R_Q\)</span>-element, which gets multiplied by <span class="math notranslate nohighlight">\(\mathrm{sk}\)</span> during decryption.
Hence this <span class="math notranslate nohighlight">\(R_Q\)</span>-element should correspond to the term linear in <span class="math notranslate nohighlight">\(\mathrm{sk}\)</span> in <a class="reference internal" href="#equation-b-0b-1">(4)</a>.
For defining the first component we consider the cross-combination of <span class="math notranslate nohighlight">\(a_i\)</span> and <span class="math notranslate nohighlight">\(b_i\)</span>:</p>
<div class="math notranslate nohighlight">
\[
a_0b_1 + a_1b_0 = -2a_1a_0\mathrm{sk} + (a_0e_1+a_1e_0) + (a_0M_1+a_1M_0) (Q/T)
\]</div>
<p>Notice that multiplying the left-hand side by <span class="math notranslate nohighlight">\(\mathrm{sk}\)</span> (occurs during decryption) yields similar, yet not entirely identical summands compared to the second line in <a class="reference internal" href="#equation-b-0b-1">(4)</a> (bar the scaling by <span class="math notranslate nohighlight">\(T/Q\)</span>).</p>
<p>All questions raised from <a class="reference internal" href="#equation-b-0b-1">(4)</a> now being answered in theory, we will introduce the common notation of <span class="math notranslate nohighlight">\(\Delta := Q/T\)</span> before describing the actual algorithm:
As a first step, we want to merge the following three ciphertexts into two:</p>
<div class="math notranslate nohighlight">
\[
c_0 := \lfloor \Delta^{-1} a_0a_1 \rceil, \qquad c_1 := \lfloor \Delta^{-1} (a_0b_1+a_1b_0) \rceil, \qquad c_2 := \lfloor \Delta^{-1} b_0b_1 \rceil
\]</div>
<p>Using the relinearization keys <span class="math notranslate nohighlight">\(\mathrm{rlk}\)</span>, we define the ciphertext of the product as:</p>
<div class="math notranslate nohighlight">
\[
c_{\text{mult}} := (c_{\text{mult},0},c_{\text{mult},1}) :=  (c_1 + \lfloor(c_0 \cdot \mathrm{rlk}_0) / P\rceil , c_2 + \lfloor (c_0 \cdot \mathrm{rlk}_1) / P \rceil)
\]</div>
<p>If we apply the main query of decryption, i.e. computing <span class="math notranslate nohighlight">\(c_{\text{mult},0}\cdot \mathrm{sk} + c_{\text{mult},1}\)</span>, we obtain the following:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{split}
c_{\text{mult},0} \cdot \mathrm{sk} + c_{\text{mult},1} &amp;= \lfloor \Delta^{-1} (a_0b_1+a_1b_0) \rceil \mathrm{sk} + \lfloor(c_0 \cdot \mathrm{rlk}_0) / P\rceil \mathrm{sk} + c_2 + \lfloor (c_0 \cdot \mathrm{rlk}_1) / P \rceil\\
    &amp;= \lfloor \Delta^{-1} (a_0(-a_1\cdot \mathrm{sk} + e_1 + \Delta M_1)+a_1(-a_0\cdot \mathrm{sk} + e_0 + \Delta M_0)) \rceil \mathrm{sk} \\
    &amp;+ \lfloor(\lfloor \Delta^{-1} a_0a_1 \rceil \cdot \mathrm{rlk}_0) / P\rceil \mathrm{sk} + \lfloor \Delta^{-1}  (a_0a_1 \mathrm{sk}^2 - (a_0e_1+a_1e_0)\mathrm{sk} - (a_0M_1+a_1M_0)\Delta)\mathrm{sk} \\
    &amp;+ e_0e_1 + \Delta (e_0M_1 +e_1M_0) + \Delta^2 M_0M_1) \rceil + \lfloor (\lfloor \Delta^{-1} a_0a_1 \rceil \cdot (- \mathrm{rlk}_0 \cdot \mathrm{sk} + e_{\text{rlk}} + P\cdot\mathrm{sk}^2 )) / P \rceil \\
    &amp;\approx \lfloor \Delta^{-1} e_0e_1 \rceil + (e_0M_1+e_1M_0) + e_{\text{rel}} + \Delta M_0 M_1
\end{split}\end{split}\]</div>
<p>Remark on the calculation:
For readability reasons all details on the modular arithmetic (e.g. difference of working in <span class="math notranslate nohighlight">\(R\)</span> or <span class="math notranslate nohighlight">\(R_Q\)</span> respectively <span class="math notranslate nohighlight">\(R_{PQ}\)</span>) have been omitted in the above.
Their presence becomes clearer in the code and their effect on the error analysis is described below.</p>
<p>In the last approximation step, all the rounding errors have been temporarily ignored to highlight the main components.
We observe three error summands plus the scaled product of <span class="math notranslate nohighlight">\(M_0M_1\)</span> - the result precisely satisfies the structure of a BFV ciphertext.
Whereas the size of <span class="math notranslate nohighlight">\(\Delta^{-1}e_0e_1\)</span> and <span class="math notranslate nohighlight">\(e_{\text{rel}}\)</span> (see <a class="reference internal" href="#relinearization-error">Lemma 5</a>) seems decent, the size of the second error term <span class="math notranslate nohighlight">\(e_0M_1+e_1M_0\)</span> remains the main concern since it relies on <span class="math notranslate nohighlight">\(M_i\)</span> (thus on <span class="math notranslate nohighlight">\(T\)</span>) and is of the multiplicative kind, too.
We will investigate the total error after a multiplication further, after stating the code.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">multiply</span><span class="p">(</span><span class="n">ciphertext1</span><span class="p">,</span> <span class="n">ciphertext2</span><span class="p">,</span> <span class="n">plaintext_modulus</span><span class="p">,</span> <span class="n">ciphertext_modulus</span><span class="p">,</span> <span class="n">auxiliary_modulus</span><span class="p">,</span> <span class="n">relinearization_keys</span><span class="p">):</span>
    <span class="n">ct1</span><span class="p">,</span> <span class="n">ct2</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">rlk</span> <span class="o">=</span> <span class="n">ciphertext1</span><span class="p">,</span> <span class="n">ciphertext2</span><span class="p">,</span> <span class="n">ciphertext_modulus</span><span class="p">,</span> <span class="n">plaintext_modulus</span><span class="p">,</span> <span class="n">auxiliary_modulus</span><span class="p">,</span> <span class="n">relinearization_keys</span>    
    <span class="n">c_0</span> <span class="o">=</span> <span class="n">ct1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">ct2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">rounded_integer_divide</span><span class="p">(</span><span class="n">Q</span><span class="o">//</span><span class="n">T</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>
    <span class="n">c_1</span> <span class="o">=</span> <span class="n">ct1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">ct2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ct1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">ct2</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">.</span><span class="n">rounded_integer_divide</span><span class="p">(</span><span class="n">Q</span><span class="o">//</span><span class="n">T</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>
    <span class="n">c_2</span> <span class="o">=</span> <span class="n">ct1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">ct2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">rounded_integer_divide</span><span class="p">(</span><span class="n">Q</span><span class="o">//</span><span class="n">T</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>
    <span class="n">c_00</span> <span class="o">=</span> <span class="n">c_0</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">rlk</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">rounded_integer_divide</span><span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
    <span class="n">c_01</span> <span class="o">=</span> <span class="n">c_0</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">rlk</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">rounded_integer_divide</span><span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">c_1</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">c_00</span><span class="p">,</span> <span class="n">Q</span><span class="p">),</span> <span class="n">c_2</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">c_01</span><span class="p">,</span> <span class="n">Q</span><span class="p">)]</span>
</pre></div>
</div>
</div>
</div>
<p>As an example, we compute <span class="math notranslate nohighlight">\(1 \cdot 1\)</span> in ciphertext space:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">N</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Q</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">20</span> 
<span class="n">rlk</span> <span class="o">=</span> <span class="n">relinearization_key</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">Q</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">STD</span><span class="p">,</span> <span class="n">SK</span><span class="p">)</span> <span class="c1"># P = Q^2 yields relinearization modulus Q^3</span>
<span class="n">Product_Encryption</span> <span class="o">=</span> <span class="n">multiply</span><span class="p">(</span><span class="n">One_Encryption</span><span class="p">,</span> <span class="n">One_Encryption</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">Q</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">rlk</span><span class="p">)</span>
<span class="n">Product_Decryption</span> <span class="o">=</span> <span class="n">print_and_return</span><span class="p">(</span><span class="s2">&quot;Product of 1*1&quot;</span><span class="p">,</span> <span class="n">decrypt</span><span class="p">(</span><span class="n">Product_Encryption</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">SK</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Multiplied 1*1 correctly?&quot;</span><span class="p">,</span> <span class="n">Product_Decryption</span><span class="o">.</span><span class="n">is_equal_to</span><span class="p">(</span><span class="n">generate_constant_poly</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="mi">1</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Product of 1*1 = 1
Multiplied 1*1 correctly? True
</pre></div>
</div>
</div>
</div>
</section>
<section id="error-analysis">
<h3>Error analysis<a class="headerlink" href="#error-analysis" title="Permalink to this headline">#</a></h3>
<p>To derive a worst-case bound for the error after one multiplication, we will follow the approach in <span id="id35">[<a class="reference internal" href="#id67" title="Junfeng Fan and Frederik Vercauteren. Somewhat practical fully homomorphic encryption. Cryptology ePrint Archive, Paper 2012/144, 2012. https://eprint.iacr.org/2012/144. URL: https://eprint.iacr.org/2012/144.">Fan and Vercauteren, 2012</a>]</span>, Section 4.</p>
<p>Firstly, we will introduce an useful notation for <span class="math notranslate nohighlight">\(\mathrm{ct}_i := (a_i,b_i)\)</span>, that is interpreting <span class="math notranslate nohighlight">\(\mathrm{ct}_i\)</span> as a polynomial as <span class="math notranslate nohighlight">\(\mathrm{ct}_i(x) := a_i x + b_i\)</span>.
Using that, we have (in <span class="math notranslate nohighlight">\(R\)</span>):</p>
<div class="math notranslate nohighlight" id="equation-multiplication-approximation">
<span class="eqno">(5)<a class="headerlink" href="#equation-multiplication-approximation" title="Permalink to this equation">#</a></span>\[\Delta^{-1}\cdot (\mathrm{ct}_0 \cdot \mathrm{ct}_1)(\mathrm{sk}) = c_0\mathrm{sk}^2 + c_1\mathrm{sk} + c_2 + e_{\text{approx}}.\]</div>
<p>The goal is to estimate the left-hand side.
The right-hand side is the approximation, whose <span class="math notranslate nohighlight">\(c_i\)</span> are part of the algorithm, and it still contains the relinearization term, which was previously analysed.</p>
<p>Notice that <span class="math notranslate nohighlight">\(e_{\text{approx}} \in \Q[x]/\langle x^N+1\rangle\)</span> in the equation and its norm can be estimated as <span class="math notranslate nohighlight">\(\approx \delta_R^2\)</span>.
The multiplication expansion factor <span class="math notranslate nohighlight">\(\delta_R := \max \{\norm{ab}/(\norm a\norm b): a,b \in R\}\)</span> will be further useful (see <a class="reference internal" href="#conclusion-on-delta-r"><span class="std std-ref">Conclusion on the expansion factor</span></a>).
Its value is at most <span class="math notranslate nohighlight">\(\delta_R' = N\)</span> and for special cases, i.e. using <span class="math notranslate nohighlight">\(a, b\)</span> sampled from e.g. <span class="math notranslate nohighlight">\(\mathrm{Ter}_{1/3}, \mathcal N_d(0,\sigma^2), \mathcal U (R_Q)\)</span>, usually around <span class="math notranslate nohighlight">\(\delta_R = \sqrt{N}\)</span>.
To verify the estimation, consider e.g. for <span class="math notranslate nohighlight">\(c_0\)</span>:</p>
<div class="math notranslate nohighlight">
\[\norm{\Delta^{-1}(a_0a_1\mathrm{sk}^2) - c_0\mathrm{sk}^2} = \norm{(\Delta^{-1}a_0a_1 - \round{\Delta^{-1}a_0a_1})\mathrm{sk}^2}\le (1/2) \delta_R \delta_R,\]</div>
<p>using <span class="math notranslate nohighlight">\(\norm{\mathrm{sk}^2} \le \delta_R\)</span> for <span class="math notranslate nohighlight">\(\mathrm{sk} \sim \mathrm{Ter}_{1/3}\)</span>.
Now, the same bound holds for the terms of <span class="math notranslate nohighlight">\(c_1\)</span> and <span class="math notranslate nohighlight">\(c_2\)</span>, yielding (approximately) <span class="math notranslate nohighlight">\(\norm{e_{\text{approx}}} \le \delta_R^2 = N\)</span>.</p>
<p>We will now write <span class="math notranslate nohighlight">\(\mathrm{ct}_i(\mathrm{sk}) \in R\)</span> as <span class="math notranslate nohighlight">\(e_i + \Delta \cdot M_i + Q \cdot f_i\)</span> with <span class="math notranslate nohighlight">\(\norm{f_i} \le \delta_R\)</span> as well.</p>
<p>Before starting to estimate the size of the left-hand side in <a class="reference internal" href="#equation-multiplication-approximation">(5)</a>, we need two estimations regarding modular reduction (denoted by e.g. <span class="math notranslate nohighlight">\([x]_T\)</span> to clarify <span class="math notranslate nohighlight">\(x \in R_T\)</span>).</p>
<div class="math notranslate nohighlight">
\[M_0M_1 = [M_0M_1]_T + T \cdot f_M, \qquad e_0e_1 = [e_0e_1]_\Delta + \Delta \cdot f_e.\]</div>
<p>Because <span class="math notranslate nohighlight">\(\norm{M_i} \le T/2\)</span>, we have <span class="math notranslate nohighlight">\(\norm{f_M} \le NT/4\)</span>, where <span class="math notranslate nohighlight">\(\delta_R'\)</span> must be used since messages are not drawn samples from distributions.
Similarly, if <span class="math notranslate nohighlight">\(\norm{e_i} \le E\)</span>, then <span class="math notranslate nohighlight">\(\norm{f_e} \le \delta_R E^2\Delta^{-1}\)</span>.
Now as a calculation shows, the left-hand side in <a class="reference internal" href="#equation-multiplication-approximation">(5)</a> equals:</p>
<div class="math notranslate nohighlight" id="equation-estimation-of-multiplication">
<span class="eqno">(6)<a class="headerlink" href="#equation-estimation-of-multiplication" title="Permalink to this equation">#</a></span>\[\begin{split}\begin{split}
&amp;\Delta[M_0M_1]_T + (M_0e_1+M_1e_0) + T(e_0f_1+e_1f_0) + f_e + \Delta^{-1}[e_0e_1]_\Delta \\
&amp;+ Q(M_0f_1+M_1f_0+f_M) + QTf_0f_1.
\end{split}\end{split}\]</div>
<p>Notice that the second line ultimately vanishes modulo <span class="math notranslate nohighlight">\(Q\)</span> and in the first line only <span class="math notranslate nohighlight">\(\Delta^{-1}[e_0e_1]_\Delta\)</span> (with norm <span class="math notranslate nohighlight">\(\le 1\)</span>) has rational coefficients.</p>
<p>We may now summarize the error analysis in a theorem, which is similar to Lemma 2 in <span id="id36">[<a class="reference internal" href="#id67" title="Junfeng Fan and Frederik Vercauteren. Somewhat practical fully homomorphic encryption. Cryptology ePrint Archive, Paper 2012/144, 2012. https://eprint.iacr.org/2012/144. URL: https://eprint.iacr.org/2012/144.">Fan and Vercauteren, 2012</a>]</span>.</p>
<div class="proof theorem admonition" id="error-after-BFV-multiplication">
<p class="admonition-title"><span class="caption-number">Theorem 6 </span> (Error after BFV multiplication)</p>
<section class="theorem-content" id="proof-content">
<p>The error size after multiplying two BFV ciphertexts <span class="math notranslate nohighlight">\((a_i,-a_i\cdot \mathrm{sk} + e_i + \Delta\cdot M_i)\)</span> with <span class="math notranslate nohighlight">\(\norm{e_i} \le E\)</span> and <span class="math notranslate nohighlight">\(\norm{\mathrm{sk}} = 1\)</span> can approximately be bounded by <span class="math notranslate nohighlight">\(2\cdot T\cdot E\cdot N\)</span>.</p>
</section>
</div><div class="proof admonition" id="proof">
<p>Proof. If we substitute <a class="reference internal" href="#equation-estimation-of-multiplication">(6)</a> in <a class="reference internal" href="#equation-multiplication-approximation">(5)</a>, reducing modulo <span class="math notranslate nohighlight">\(Q\)</span> and rounding yields:</p>
<div class="math notranslate nohighlight">
\[\Delta [M_0M_1]_T + (M_0e_1+M_1e_0) + T(e_0f_1+e_1f_0) + f_e + \round{\Delta^{-1}[e_0e_1]_\Delta - e_{\text{approx}}}
= [c_0\mathrm{sk}^2 + c_1\mathrm{sk} + c_2]_Q\]</div>
<p>The norms of the summands estimate as follows:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{split}
\norm{M_0e_1+M_1e_0} &amp;\le 2 (T/2) E \delta_R = TE\sqrt{N} \\
\norm{T(e_0f_1+e_1f_0)} &amp;\le T \cdot 2 E \delta_R^2 = 2TEN \\
\norm{f_e + \round{\Delta^{-1}[e_0e_1]_\Delta - e_{\text{approx}}}} &amp;\le \delta_R E^2 \Delta^{-1} + (1 + N) \le \sqrt{N}E + N
\end{split}\end{split}\]</div>
<p>since <span class="math notranslate nohighlight">\(E &lt; \Delta\)</span> (for correct decryption).
Clearly, <span class="math notranslate nohighlight">\(2TEN\)</span> is the dominant term.
Together with <span class="math notranslate nohighlight">\(e_{\text{rel}}\)</span> (negligible size, see <a class="reference internal" href="#relinearization-error">Lemma 5</a>), whose relinearzation procedure eliminates <span class="math notranslate nohighlight">\(c_0\mathrm{sk}^2\)</span> in the above, the claim follows.</p>
</div>
<p>Continuing the above example of multiplying <span class="math notranslate nohighlight">\(1\cdot 1\)</span> in encrypted form, we want to test computationally if the bound <span class="math notranslate nohighlight">\(2\cdot TEN\)</span>, or more generally <span class="math notranslate nohighlight">\(C\cdot TEN\)</span> with a constant <span class="math notranslate nohighlight">\(C &gt; 2\)</span>, holds with high probability.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">N</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">iterations</span><span class="p">,</span> <span class="n">counter</span><span class="p">,</span> <span class="n">Max_C</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10000</span><span class="o">*</span><span class="n">speed</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span>
<span class="n">Delta_One</span> <span class="o">=</span> <span class="n">generate_one_poly</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="o">.</span><span class="n">scalar_multiply</span><span class="p">(</span><span class="n">Q</span><span class="o">//</span><span class="n">T</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">iterations</span><span class="p">):</span>
    <span class="n">One_Enc</span> <span class="o">=</span> <span class="n">encrypt</span><span class="p">(</span><span class="n">generate_one_poly</span><span class="p">(</span><span class="n">N</span><span class="p">),</span> <span class="n">T</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">PK</span><span class="p">)</span>
    <span class="n">Product</span> <span class="o">=</span> <span class="n">multiply</span><span class="p">(</span><span class="n">One_Enc</span><span class="p">,</span> <span class="n">One_Enc</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">Q</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">rlk</span><span class="p">)</span>
    <span class="n">E</span> <span class="o">=</span> <span class="n">One_Enc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">SK</span><span class="p">)</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">One_Enc</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">Delta_One</span><span class="p">)</span><span class="o">.</span><span class="n">mod_small</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span>
    <span class="n">Product_Norm</span> <span class="o">=</span> <span class="n">Product</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">SK</span><span class="p">)</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Product</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">Delta_One</span><span class="p">)</span><span class="o">.</span><span class="n">mod_small</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">Product_Norm</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">E</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">N</span><span class="o">*</span><span class="n">T</span><span class="p">:</span>
        <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Max_C</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">Max_C</span><span class="p">,</span> <span class="n">Product_Norm</span><span class="o">/</span><span class="p">(</span><span class="n">E</span><span class="o">*</span><span class="n">N</span><span class="o">*</span><span class="n">T</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Out of </span><span class="si">{</span><span class="n">iterations</span><span class="si">}</span><span class="s2"> iterations: ratio of correct bound </span><span class="si">{</span><span class="n">counter</span><span class="o">/</span><span class="n">iterations</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Maximum C was </span><span class="si">{</span><span class="n">Max_C</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Out of 10000 iterations: ratio of correct bound 1.0
Maximum C was 2
</pre></div>
</div>
</div>
</div>
</section>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="preparations-for-bootstrapping">
<span id="id37"></span><h1>Preparations for bootstrapping<a class="headerlink" href="#preparations-for-bootstrapping" title="Permalink to this headline">#</a></h1>
<section id="rlwe-ciphertexts">
<h2>RLWE ciphertexts<a class="headerlink" href="#rlwe-ciphertexts" title="Permalink to this headline">#</a></h2>
<section id="id38">
<h3>Motivation<a class="headerlink" href="#id38" title="Permalink to this headline">#</a></h3>
<p>Bootstrapping, apart from some minor precomputations, happens entirely in ciphertext spaces like <span class="math notranslate nohighlight">\(R_Q\)</span>.
Hence, as the presented bootstrapping procedure from <span id="id39">[<a class="reference internal" href="#id69" title="Andrey Kim, Maxim Deryabin, Jieun Eom, Rakyong Choi, Yongwoo Lee, Whan Ghang, and Donghoon Yoo. General bootstrapping approach for rlwe-based homomorphic encryption. Cryptology ePrint Archive, Paper 2021/691, 2021. https://eprint.iacr.org/2021/691. URL: https://eprint.iacr.org/2021/691.">Kim <em>et al.</em>, 2021</a>]</span> is technically applicable to any RLWE-based scheme (CKKS, BFV, BGV, etc.), it is helpful to simplify the notion of a ciphertext, such that it becomes independent of various encoding techniques, e.g. BFV.</p>
<p>We universally speak of a RLWE-ciphertext, similiar to <a class="reference internal" href="#RLWE-distribution">Definition 2</a>, of a message <span class="math notranslate nohighlight">\(m\)</span> encrypted under the secret key <span class="math notranslate nohighlight">\(s\)</span> using the ciphertext modulus <span class="math notranslate nohighlight">\(Q\)</span> and denote it as:</p>
<div class="math notranslate nohighlight">
\[
\mathrm{RLWE}_{Q,s}(m) := (a, -a\cdot s+e+m) \in R_Q^2.
\]</div>
<p>We occasionally omit the indices, if <span class="math notranslate nohighlight">\(Q\)</span> respectively <span class="math notranslate nohighlight">\(s\)</span> are clear from the context.
If the corresponding error <span class="math notranslate nohighlight">\(e\)</span> is <span class="math notranslate nohighlight">\(0\)</span>, we will write <span class="math notranslate nohighlight">\(\mathrm{RLWE}_{Q,s}^0(m)\)</span> instead.
In the same fashion as in BFV encryption, <span class="math notranslate nohighlight">\(m\)</span> could be RLWE-encrypted by using a public key only.
Nevertheless, it is not necessary to consider this extension, since we will only work in ciphertext space during bootstrapping.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">rlwe_encryption</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">ciphertext_modulus</span><span class="p">,</span> <span class="n">standard_deviation</span><span class="p">,</span> <span class="n">secret_key</span><span class="p">):</span>
    <span class="n">Q</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">ciphertext_modulus</span><span class="p">,</span> <span class="n">secret_key</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="s1">&#39;ring_degree&#39;</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">generate_uniform_distribution</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Q</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">generate_gaussian_distribution</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">standard_deviation</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">scalar_multiply</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>The goal of bootstrapping now comes down to replacing a large error within <span class="math notranslate nohighlight">\(\mathrm{RLWE}_{Q,s}(m)\)</span> with a small fresh one.
By the latter, we mean an error with the same size and quality as an error coming from an initial encryption to preserve security.
Interestingly, bootstrapping can be deconstructed into the core procedure <span class="math notranslate nohighlight">\(\texttt{scaled-mod}\)</span> and the surrounding adaption to the BFV scheme.
Informally speaking, <span class="math notranslate nohighlight">\(\texttt{scaled-mod}\)</span> only consists of the operation of scaling a <span class="math notranslate nohighlight">\(\mathrm{RLWE}(m)\)</span> to <span class="math notranslate nohighlight">\(\mathrm{RLWE}(\Delta \cdot m)\)</span> for a large <span class="math notranslate nohighlight">\(\Delta\)</span> (different delta from BFV-multiplication).
Since just computing <span class="math notranslate nohighlight">\(\mathrm{RLWE}(m) \cdot \Delta\)</span> would also scale the intrinsic error <span class="math notranslate nohighlight">\(e\)</span> by <span class="math notranslate nohighlight">\(\Delta\)</span>, which itself would imply an impossible decryption, the development of techniques to limit error growth during multiplication with ciphertexts is unavoidable.
In this chapter, which is based upon <span id="id40">[<a class="reference internal" href="#id69" title="Andrey Kim, Maxim Deryabin, Jieun Eom, Rakyong Choi, Yongwoo Lee, Whan Ghang, and Donghoon Yoo. General bootstrapping approach for rlwe-based homomorphic encryption. Cryptology ePrint Archive, Paper 2021/691, 2021. https://eprint.iacr.org/2021/691. URL: https://eprint.iacr.org/2021/691.">Kim <em>et al.</em>, 2021</a>]</span>, Section 2, we will explain some of these techniques and analyse the resulting effect on the error growth.</p>
</section>
<section id="operations-on-rlwe-ciphertexts">
<h3>Operations on RLWE ciphertexts<a class="headerlink" href="#operations-on-rlwe-ciphertexts" title="Permalink to this headline">#</a></h3>
<p>To start, we have to define two auxiliary functions, which allow us to effectively deal with RLWE ciphertexts.
The most basic operation is again addition.
It can be done in the same direct way as we have realized BFV addition, namely by adding the components.
In the same fashion, this evokes nearly no issues concerning the error, which is only the sum of the previous errors and thus still comparably small.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">rlwe_add</span><span class="p">(</span><span class="n">rlwe1</span><span class="p">,</span> <span class="n">rlwe2</span><span class="p">,</span> <span class="n">modulus</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">rlwe1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">rlwe2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">modulus</span><span class="p">),</span> <span class="n">rlwe1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">rlwe2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">modulus</span><span class="p">)]</span>
</pre></div>
</div>
</div>
</div>
<p>The second operation is multiplication with a polynomial <span class="math notranslate nohighlight">\(p\)</span> in both components.
As mentioned earlier, this includes multiplication of the error and message likewise.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">rlwe_multiply_with_poly</span><span class="p">(</span><span class="n">rlwe</span><span class="p">,</span> <span class="n">poly</span><span class="p">,</span> <span class="n">modulus</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">rlwe</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">poly</span><span class="p">,</span> <span class="n">modulus</span><span class="p">),</span> <span class="n">rlwe</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">poly</span><span class="p">,</span> <span class="n">modulus</span><span class="p">)]</span>
</pre></div>
</div>
</div>
</div>
<p>Because we will need it later, note that the error <span class="math notranslate nohighlight">\(ep\)</span> after multiplying <span class="math notranslate nohighlight">\(\mathrm{RLWE}_{Q,s}(m) := (a, -as+e+m)\)</span> with <span class="math notranslate nohighlight">\(p\)</span> has size at most:</p>
<div class="math notranslate nohighlight" id="equation-rlwe-multiply-error-growth">
<span class="eqno">(7)<a class="headerlink" href="#equation-rlwe-multiply-error-growth" title="Permalink to this equation">#</a></span>\[\norm{ e\cdot p}\le \norm e \cdot \#\{p_i : p_i \neq 0\} \cdot \norm{p}.\]</div>
<p>Since the result of <span class="math notranslate nohighlight">\(\texttt{rlwe-multiply-with-poly}\)</span> is a ciphertext, which relies on correct decryption (see <a class="reference internal" href="#correct-BFV-decryption">Lemma 4</a>), <span class="math notranslate nohighlight">\(p\)</span> must be chosen carefully.
Monomials as <span class="math notranslate nohighlight">\(p\)</span> achieve the sharpest bound in this context, i.e. then <span class="math notranslate nohighlight">\(\norm{ep} = \norm{e}\)</span>, because multiplication with <span class="math notranslate nohighlight">\(p\)</span> then only shuffles the coefficients of <span class="math notranslate nohighlight">\(e\)</span> with a possible change in sign.
If we use a sum of monomials as <span class="math notranslate nohighlight">\(p\)</span>, we still receive an optimal result, since the error growth is exactly the same, as the comparison between <span class="math notranslate nohighlight">\(\texttt{rlwe-add}(\mathrm{RLWE}(m\cdot x^j),\mathrm{RLWE}(m\cdot x^k))\)</span> and <span class="math notranslate nohighlight">\(\texttt{rlwe-multiply-with-poly}(\mathrm{RLWE}(m),x^j+x^k)\)</span> shows.
For a general polynomial <span class="math notranslate nohighlight">\(p\)</span> and if <span class="math notranslate nohighlight">\(p_i\)</span> and <span class="math notranslate nohighlight">\(e_i\)</span> are i.i.d. with mean zero, we may also use the standard estimation <span class="math notranslate nohighlight">\(\norm{ep}
 \le \delta_R \norm e \norm p\)</span> (see <a class="reference internal" href="#conclusion-on-delta-r"><span class="std std-ref">Conclusion on the expansion factor</span></a>).</p>
<p>Following these observations, we will later outsource a polynomial multiplication to many individual monomial multiplications and in particular, our next objective will be the reduction of <span class="math notranslate nohighlight">\(\norm{p}\)</span> to smaller values by base-decomposing polynomials/ciphertexts.</p>
</section>
</section>
<section id="id41">
<h2>RLWE’ ciphertexts<a class="headerlink" href="#id41" title="Permalink to this headline">#</a></h2>
<p>Essentially, a RLWE’ ciphertext is a blow-up of a RLWE ciphertext used to better handle error growth during <span class="math notranslate nohighlight">\(\texttt{rlwe-multiply-with-poly}\)</span>.
Constructing a RLWE’ ciphertext will be done by RLWE-encrypting the corresponding message scalar multiplied by powers of a certain base <span class="math notranslate nohighlight">\(B &gt; 1\)</span>.</p>
<p>To specify the latter, we are scalar multiplying our message with a so-called gadget vector <span class="math notranslate nohighlight">\(g := (1,B,B^2,\dots,B^l)\)</span>, where <span class="math notranslate nohighlight">\(l \in \mathbb N\)</span> is maximal in terms of <span class="math notranslate nohighlight">\(B^l &lt; \log_B(Q)\)</span>.
The gadget vector has the property of letting any ring element <span class="math notranslate nohighlight">\(r\in R_Q\)</span> uniquely get gadget-decomposed into:</p>
<div class="math notranslate nohighlight">
\[r = \sum_{i=0}^l g_i \cdot r_i, \qquad \norm{r_i} \le B/2.\]</div>
<p>Basically, this is just the extension of base <span class="math notranslate nohighlight">\(B\)</span> decomposition from numbers to polynomials.
The RLWE’ encryption of a message <span class="math notranslate nohighlight">\(m\)</span> with respect to base <span class="math notranslate nohighlight">\(B\)</span> now is defined as:</p>
<div class="math notranslate nohighlight">
\[\mathrm{RLWE'}_{Q,s}(m) := (\mathrm{RLWE}_{Q,s}(B^i \cdot m))_{i \in \{0, \dots, l\}} \in R_Q^{l+1}\]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">rlwe_x_encryption</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">ciphertext_modulus</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">standard_deviation</span><span class="p">,</span> <span class="n">secret_key</span><span class="p">):</span>
    <span class="n">m</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">STD</span> <span class="o">=</span> <span class="n">message</span><span class="p">,</span> <span class="n">ciphertext_modulus</span><span class="p">,</span> <span class="n">secret_key</span><span class="p">,</span> <span class="n">standard_deviation</span>
    <span class="n">g</span> <span class="o">=</span> <span class="p">[</span><span class="n">B</span> <span class="o">**</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ceil</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">B</span><span class="p">)))</span> <span class="p">]</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">rlwe_encryption</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">scalar_multiply</span><span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">Q</span><span class="p">,</span> <span class="n">STD</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="p">))]</span>
</pre></div>
</div>
</div>
</div>
<p>Remark on <span class="math notranslate nohighlight">\(B\)</span>:
Because our scheme uses a power of two as <span class="math notranslate nohighlight">\(Q\)</span>, it stands to reason for simplicity to use a power of two as <span class="math notranslate nohighlight">\(B\)</span> as well.
As <span class="math notranslate nohighlight">\(B\)</span> will be a changeable bootstrapping parameter, it has a non-negligible impact on the running time, too.
As we will analyse in the next section, for a larger <span class="math notranslate nohighlight">\(B\)</span> there is a fine trade-off between the larger error it induces during RLWE’ operations and the faster running times respectively less memory it requires at the same time.</p>
<section id="id42">
<h3>Operations on RLWE’ ciphertexts<a class="headerlink" href="#id42" title="Permalink to this headline">#</a></h3>
<p>If one once again considers the error problem concerning the <span class="math notranslate nohighlight">\(\texttt{rlwe-multiply-with-poly}\)</span> algorithm, we may now solve this issue by using our decomposed information hiding inside a RLWE’ ciphertext.
Recall that multiplying with a large polynomial <span class="math notranslate nohighlight">\(r\)</span> results in too large an error for correct decryption.
Utilizing the above property that <span class="math notranslate nohighlight">\(\norm{r_i} \le B/2\)</span>, we can improve the size of the error after a multiplication by splitting up the multiplication process among the <span class="math notranslate nohighlight">\(r_i\)</span>’s.</p>
<p>We define the so-called scalar multiplication <span class="math notranslate nohighlight">\(\odot\)</span> of a RLWE’ ciphertext with a polynomial <span class="math notranslate nohighlight">\(r \in R_Q\)</span> using the above notation as:</p>
<div class="math notranslate nohighlight">
\[\texttt{rlwe-x-scalar-multiply}: r \odot \mathrm{RLWE'}_{Q,s}(m) := \sum_{i=0}^l r_i \cdot \mathrm{RLWE}_{Q,s}(B^i \cdot m)\]</div>
<p>The above uses the homomorphic procedures for RLWE ciphertexts, i.e. <span class="math notranslate nohighlight">\(\texttt{rlwe-add}\)</span> and <span class="math notranslate nohighlight">\(\texttt{rlwe-multiply-with-poly}\)</span>, to compute the right-hand side.
Hence we have:</p>
<div class="math notranslate nohighlight">
\[\sum_{i=0}^l r_i \cdot \mathrm{RLWE}_{Q,s}(B^i \cdot m) = \mathrm{RLWE}_{Q,s} \left( \sum_{i=0}^l r_i \cdot B^i \cdot m \right) = \mathrm{RLWE}_{Q,s}(r\cdot m)\]</div>
<p>So in total, <span class="math notranslate nohighlight">\(\texttt{rlwe-x-scalar-multiply}\)</span> enables us to compute <span class="math notranslate nohighlight">\(\texttt{rlwe-multiply-with-poly}(\mathrm{RLWE}(m), r)\)</span> with a smaller error, whose size we will analyse after stating the algorithm.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">rlwe_x_scalar_multiply</span><span class="p">(</span><span class="n">r_Q</span><span class="p">,</span> <span class="n">rlwe_x</span><span class="p">,</span> <span class="n">ciphertext_modulus</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
    <span class="n">l</span> <span class="o">=</span> <span class="n">ceil</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">ciphertext_modulus</span><span class="p">,</span> <span class="n">B</span><span class="p">))</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">r_Q</span><span class="o">.</span><span class="n">base_decompose</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">generate_constant_poly</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">r_Q</span><span class="p">,</span> <span class="s1">&#39;ring_degree&#39;</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">rlwe_multiply_with_poly</span><span class="p">(</span><span class="n">rlwe_x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ciphertext_modulus</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">rlwe_add</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">ciphertext_modulus</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
</div>
</div>
<div class="proof lemma admonition" id="error-after-rlwe-x-scalar-multiply">
<p class="admonition-title"><span class="caption-number">Lemma 6 </span> (Error after <span class="math notranslate nohighlight">\(\texttt{rlwe-x-scalar-multiply}\)</span>)</p>
<section class="lemma-content" id="proof-content">
<p>Scalar multiplying <span class="math notranslate nohighlight">\(\mathrm{RLWE'}_{Q,s}(m)\)</span> (with an error <span class="math notranslate nohighlight">\(e\)</span>) with <span class="math notranslate nohighlight">\(r \in R_Q\)</span>, yields an error of size at most <span class="math notranslate nohighlight">\((B/2) \cdot \log_B(Q) \cdot \norm{e} \cdot \delta_R^{(')}\)</span>.</p>
</section>
</div><div class="proof admonition" id="proof">
<p>Proof. The procedure <span class="math notranslate nohighlight">\(\texttt{rlwe-multiply-with-poly}\)</span> computes <span class="math notranslate nohighlight">\(er\)</span>.
Thus the error size afterwards is <span class="math notranslate nohighlight">\(\delta_R^{(')} \cdot \norm{e} \cdot (B/2)\)</span>, using an ring expansion factor <span class="math notranslate nohighlight">\(\delta_R^{(')}\)</span> dependent on <span class="math notranslate nohighlight">\(e\)</span> and <span class="math notranslate nohighlight">\(r\)</span> (see <a class="reference internal" href="#conclusion-on-delta-r"><span class="std std-ref">Conclusion on the expansion factor</span></a>).
The claim follows since we then perform <span class="math notranslate nohighlight">\(l \approx \log_B(Q)\)</span> additions using <span class="math notranslate nohighlight">\(\texttt{rlwe-add}\)</span>.</p>
</div>
<p>Remark: Interestingly, <span class="math notranslate nohighlight">\(B \cdot l \approx B \cdot \log_B(Q)\)</span> inside the error bound gets minimal for <span class="math notranslate nohighlight">\(B\)</span> equal to Euler’s number <span class="math notranslate nohighlight">\(\mathrm{e}\)</span>, which an easy calculation shows.
If we use a large <span class="math notranslate nohighlight">\(B\)</span>, on the one hand, the running time/memory usage will be faster/lesser by a factor <span class="math notranslate nohighlight">\(\log_B(Q)/\ln(Q) = 1/\ln(B)\)</span> than in the error-wise optimal case with Euler’s number.
On the other hand, the error size will then be larger by a factor <span class="math notranslate nohighlight">\(B\log_B(Q)/(\mathrm{e}\ln(Q)) = B/(\mathrm{e}\ln(B))\)</span>.
Since we will later investigate techniques to scale down an error more efficiently anyway, the trade-off of a larger <span class="math notranslate nohighlight">\(B\)</span> and faster computation times etc. is definitely preferable at this point.</p>
</section>
</section>
<section id="rgsw-ciphertexts">
<h2>RGSW ciphertexts<a class="headerlink" href="#rgsw-ciphertexts" title="Permalink to this headline">#</a></h2>
<p>The notion of a RGSW (name and idea originate from <span id="id43">[<a class="reference internal" href="#id70" title="Craig Gentry, Amit Sahai, and Brent Waters. Homomorphic encryption from learning with errors: conceptually-simpler, asymptotically-faster, attribute-based. Cryptology ePrint Archive, Paper 2013/340, 2013. https://eprint.iacr.org/2013/340. URL: https://eprint.iacr.org/2013/340.">Gentry <em>et al.</em>, 2013</a>]</span>) ciphertext adds another layer of complexity.
Namely, it consists of RLWE’ encryptions of both <span class="math notranslate nohighlight">\(s \cdot m\)</span> and <span class="math notranslate nohighlight">\(m\)</span>, where <span class="math notranslate nohighlight">\(s\)</span> is the secret key.
The scaling with <span class="math notranslate nohighlight">\(s\)</span> is necessary, if we extend the idea behind <span class="math notranslate nohighlight">\(\texttt{rlwe-x-scalar-multiply}\)</span> to a multiplication with a RLWE ciphertext (and not just a ring element).
This will enable us to define something like <span class="math notranslate nohighlight">\(\mathrm{RLWE}(m_1) \circledast \mathrm{RGSW}(m_2) \approx \mathrm{RLWE}(m_1m_2)\)</span>, because if <span class="math notranslate nohighlight">\(\mathrm{RLWE}(m_1) = (a,b)\)</span>, then <span class="math notranslate nohighlight">\(as+b = e_1 + m_1\)</span> can be computed without knowledge of <span class="math notranslate nohighlight">\(m_1\)</span> by implicitly transferring the multiplication with <span class="math notranslate nohighlight">\(s\)</span> to <span class="math notranslate nohighlight">\(\mathrm{RGSW}(m_2)\)</span>.</p>
<p>We save the details on the <span class="math notranslate nohighlight">\(\texttt{star-multiplication}\)</span> <span class="math notranslate nohighlight">\(\circledast\)</span> for later and define:</p>
<div class="math notranslate nohighlight">
\[\mathrm{RGSW}_{Q,s}(m) := (\mathrm{RLWE'}_{Q,s}(s\cdot m), \mathrm{RLWE'}_{Q,s}(m)) \in R_Q^{2(l+1)}.\]</div>
<p>Note that given <span class="math notranslate nohighlight">\(\RLWEx(m)\)</span>, one does not explicitly need <span class="math notranslate nohighlight">\(s\)</span> for obtaining <span class="math notranslate nohighlight">\(\RLWEx(s \cdot m)\)</span>, because it holds that:</p>
<div class="math notranslate nohighlight">
\[\RLWE(s \cdot B^i \cdot m) = \RLWE(0) + (B^i \cdot m, 0).\]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">rgsw_encryption</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">ciphertext_modulus</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">standard_deviation</span><span class="p">,</span> <span class="n">secret_key</span><span class="p">):</span>
    <span class="n">m</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">STD</span> <span class="o">=</span> <span class="n">message</span><span class="p">,</span> <span class="n">ciphertext_modulus</span><span class="p">,</span> <span class="n">secret_key</span><span class="p">,</span> <span class="n">standard_deviation</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">rlwe_x_encryption</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">Q</span><span class="p">),</span> <span class="n">Q</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">STD</span><span class="p">,</span> <span class="n">s</span><span class="p">),</span> <span class="n">rlwe_x_encryption</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">STD</span><span class="p">,</span> <span class="n">s</span><span class="p">)]</span>
</pre></div>
</div>
</div>
</div>
<section id="operations-on-rgsw-ciphertexts">
<h3>Operations on RGSW ciphertexts<a class="headerlink" href="#operations-on-rgsw-ciphertexts" title="Permalink to this headline">#</a></h3>
<p>Again, we start with the straightforward component-wise addition <span class="math notranslate nohighlight">\(\texttt{rgsw-add}\)</span> to obtain <span class="math notranslate nohighlight">\(\RGSW(m_1+m_2)\)</span> from <span class="math notranslate nohighlight">\(\RGSW(m_1)\)</span> and <span class="math notranslate nohighlight">\(\RGSW(m_2)\)</span>.
Since a <span class="math notranslate nohighlight">\(\RGSW\)</span> ciphertext builds on <span class="math notranslate nohighlight">\(\RLWEx\)</span> ciphertexts, which themself build on <span class="math notranslate nohighlight">\(\RLWE\)</span> ciphertext, we apply <span class="math notranslate nohighlight">\(\texttt{rlwe-add}\)</span> in the bottom level to obtain the desired result.
The error analysis is identical to the one in <span class="math notranslate nohighlight">\(\texttt{rlwe-add}\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">rgsw_add</span><span class="p">(</span><span class="n">rgsw1</span><span class="p">,</span> <span class="n">rgsw2</span><span class="p">,</span> <span class="n">ciphertext_modulus</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="n">l</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rgsw1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span> <span class="p">,</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">l</span><span class="p">)]]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
            <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">rlwe_add</span><span class="p">(</span><span class="n">rgsw1</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">rgsw2</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">ciphertext_modulus</span><span class="p">)</span>             
    <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
</div>
</div>
<p>In the above fashion of RLWE ciphertexts, we can extend the component-wise multiplication with a specific polynomial <span class="math notranslate nohighlight">\(r \in R_Q\)</span> to RGSW ciphertexts.
Needless to say, the same error discussion as in <span class="math notranslate nohighlight">\(\texttt{rlwe-multiply-with-poly}\)</span> applies:
It is mandatory that we only multiply with a <span class="math notranslate nohighlight">\(r\)</span> of small size, otherwise, we will decrypt the result wrongly (below indicated by <span class="math notranslate nohighlight">\(\leadsto\)</span>).</p>
<p>More formally we have:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{split}
\texttt{rgsw-multiply-with-poly}: \mathrm{RGSW}_{Q,s} \times R_Q &amp;\longrightarrow \mathrm{RGSW}_{Q,s}, \\
(\mathrm{RGSW}_{Q,s}(m), r) &amp;\leadsto \mathrm{RGSW}_{Q,s}(r\cdot m)
\end{split}\end{split}\]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">rgsw_multiply_with_poly</span><span class="p">(</span><span class="n">rgsw</span><span class="p">,</span> <span class="n">poly</span><span class="p">,</span> <span class="n">ciphertext_modulus</span><span class="p">):</span>
    <span class="n">l</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rgsw</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">l</span><span class="p">)]</span> <span class="p">,</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">l</span><span class="p">)]]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">rlwe_multiply_with_poly</span><span class="p">(</span><span class="n">rgsw</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">poly</span><span class="p">,</span> <span class="n">ciphertext_modulus</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="the-star-multiplication">
<h3>The star multiplication<a class="headerlink" href="#the-star-multiplication" title="Permalink to this headline">#</a></h3>
<p>The star multiplication <span class="math notranslate nohighlight">\(\circledast\)</span> can be seen as the most central auxiliary operation of the bootstrapping scheme.
It effectively minimizes the error growth when multiplying a particular kind of ciphertext (a RGSW-encrypted monomial) by exploiting the structure of RLWE’ ciphertexts.
Unlike BFV multiplication (see <a class="reference internal" href="#error-after-BFV-multiplication">Theorem 6</a>), the error after <span class="math notranslate nohighlight">\(\circledast\)</span> directly depends on the size of a message belonging to (only) one factor.</p>
<p>As a description of <span class="math notranslate nohighlight">\(\circledast\)</span> we have:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{split}
\texttt{star-multiplication} = \circledast: \mathrm{RLWE}_{Q,s} \times \mathrm{RGSW}_{Q,s} &amp;\longrightarrow \mathrm{RLWE}_{Q,s}, \\ (\mathrm{RLWE}_{Q,s}(m_1), \mathrm{RGSW}_{Q,s}(m_2)) &amp;\leadsto \mathrm{RLWE}_{Q,s}(m_1\cdot m_2+e_1m_2)
\end{split}\end{split}\]</div>
<p>The above shows what the result is rather than how it is actually defined.
Unfolding the components gives rise to the definition:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{split}
\underbrace{\mathrm{RLWE}_{Q,s}(m_1)}_{=: (a,b)} \circledast \mathrm{RGSW}_{Q,s}(m_2) &amp;:= a \odot \mathrm{RLWE'}_{Q,s}(s\cdot m_2) + b \odot \mathrm{RLWE'}_{Q,s}(m_2) \\
&amp;= \mathrm{RLWE}_{Q,s}((a\cdot s +b)m_2) \\
&amp;= \mathrm{RLWE}_{Q,s}(m_1\cdot m_2+e_1m_2).
\end{split}\end{split}\]</div>
<p>Here we have implicitly applied the auxiliary functions <span class="math notranslate nohighlight">\(\odot\)</span> and <span class="math notranslate nohighlight">\(\texttt{rlwe-add}\)</span> from above and we have used that <span class="math notranslate nohighlight">\(a \cdot s + b = m_1 + e_1\)</span>.
Finally, it becomes clear, why we originally needed the concept of RGSW ciphertexts (i.e. the additional multiplication with <span class="math notranslate nohighlight">\(s\)</span>).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">star_multiplication</span><span class="p">(</span><span class="n">rlwe</span><span class="p">,</span> <span class="n">rgsw</span><span class="p">,</span> <span class="n">ciphertext_modulus</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span> 
    <span class="n">summand1</span> <span class="o">=</span> <span class="n">rlwe_x_scalar_multiply</span><span class="p">(</span><span class="n">rlwe</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rgsw</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ciphertext_modulus</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
    <span class="n">summand2</span> <span class="o">=</span> <span class="n">rlwe_x_scalar_multiply</span><span class="p">(</span><span class="n">rlwe</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">rgsw</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ciphertext_modulus</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rlwe_add</span><span class="p">(</span><span class="n">summand1</span><span class="p">,</span> <span class="n">summand2</span><span class="p">,</span> <span class="n">ciphertext_modulus</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The error analysis is simple:</p>
<div class="proof lemma admonition" id="error-after-star-multiplication">
<p class="admonition-title"><span class="caption-number">Lemma 7 </span> (Error after <span class="math notranslate nohighlight">\(\texttt{star-multiplication}\)</span>)</p>
<section class="lemma-content" id="proof-content">
<p>The error size after <span class="math notranslate nohighlight">\(\RLWE_{Q,s}(m_1) \circledast \RGSW_{Q,s}(m_2)\)</span> is approximately bounded by <span class="math notranslate nohighlight">\(B \cdot \log_B(Q) \cdot \norm {e_2} \cdot \sqrt{N} + \norm{e_1m_2}\)</span>.</p>
</section>
</div><div class="proof admonition" id="proof">
<p>Proof. The result after <span class="math notranslate nohighlight">\(\circledast\)</span> is an encryption of <span class="math notranslate nohighlight">\(m_1m_2\)</span> altered by <span class="math notranslate nohighlight">\(e_1m_2\)</span>, thus <span class="math notranslate nohighlight">\(\norm{e_1m_2}\)</span> is the estimation.
Now, following <a class="reference internal" href="#error-after-rlwe-x-scalar-multiply">Lemma 6</a>, both components from <span class="math notranslate nohighlight">\(\RLWE(m_1)\)</span> can be treated as <span class="math notranslate nohighlight">\(\mathcal U(R_Q)\)</span> samples due to <a class="reference internal" href="#decision-RLWE">Definition 3</a>.
Together with the assumption that <span class="math notranslate nohighlight">\(e_2\)</span> (i.e. its coefficients) is distributed with mean zero (see <a class="reference internal" href="#conclusion-on-delta-r"><span class="std std-ref">Conclusion on the expansion factor</span></a>), we can select <span class="math notranslate nohighlight">\(\delta_R = \sqrt{N}\)</span> in <a class="reference internal" href="#error-after-rlwe-x-scalar-multiply">Lemma 6</a>.
Since we add two RLWE ciphertexts at the end, the claim follows.</p>
</div>
<p>Notice that <span class="math notranslate nohighlight">\(\norm{e_1m_2} \le N \norm{e_1}\norm{m_2}\)</span> in the worst case, since <span class="math notranslate nohighlight">\(m_2\)</span> could be arbitrary.
However, we will only use monomials as <span class="math notranslate nohighlight">\(m_2\)</span> in our algorithm, such that <span class="math notranslate nohighlight">\(\norm{e_1m_2} = \norm{e_1}\)</span> holds.</p>
</section>
<section id="the-extended-star-multiplication">
<h3>The extended star multiplication<a class="headerlink" href="#the-extended-star-multiplication" title="Permalink to this headline">#</a></h3>
<p>We can extend the star multiplication from RLWE to RLWE’ ciphertexts by again applying it component-wise.
Using the same notation out of comfort, the map is:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{split}
\texttt{star-x-multiplication} = \circledast: \mathrm{RLWE'}_{Q,s} \times \mathrm{RGSW}_{Q,s} &amp;\longrightarrow \mathrm{RLWE'}_{Q,s}, \\ (\mathrm{RLWE'}_{Q,s}(m_1), \mathrm{RGSW}_{Q,s}(m_2)) &amp;\leadsto \mathrm{RLWE'}_{Q,s}(m_1\cdot m_2+e_1m_2)
\end{split}\end{split}\]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">star_x_multiplication</span><span class="p">(</span><span class="n">rlwe_x</span><span class="p">,</span> <span class="n">rgsw</span><span class="p">,</span> <span class="n">modulus</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">star_multiplication</span><span class="p">(</span><span class="n">rlwe_x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">rgsw</span><span class="p">,</span> <span class="n">modulus</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rlwe_x</span><span class="p">))]</span>
</pre></div>
</div>
</div>
</div>
<p>Technically, the <span class="math notranslate nohighlight">\(\texttt{star-x-multiplication}\)</span> can now be extended even to a multiplication of two RGSW ciphertexts, as suggested in Section 2 of <span id="id44">[<a class="reference internal" href="#id71" title="Daniele Micciancio and Yuriy Polyakov. Bootstrapping in fhew-like cryptosystems. Cryptology ePrint Archive, Paper 2020/086, 2020. https://eprint.iacr.org/2020/086. URL: https://eprint.iacr.org/2020/086.">Micciancio and Polyakov, 2020</a>]</span>.
Although we will not use it, if one needs a RGSW encryption of the result of <span class="math notranslate nohighlight">\(\circledast\)</span>, the <span class="math notranslate nohighlight">\(\diamondsuit\)</span> operation may be useful:</p>
<div class="math notranslate nohighlight">
\[\diamondsuit: \RGSW \times \RGSW \longrightarrow \RGSW, \qquad ((c_1,c_2),C) \longmapsto (c_1 \circledast C, c_2 \circledast C).\]</div>
</section>
</section>
<section id="automorphisms-of-r">
<span id="id45"></span><h2>Automorphisms of <span class="math notranslate nohighlight">\(R\)</span><a class="headerlink" href="#automorphisms-of-r" title="Permalink to this headline">#</a></h2>
<p>Before getting to bootstrapping, we need two more auxiliary operations.
The first one is an automorphism evaluation on elements of <span class="math notranslate nohighlight">\(R\)</span> and thus on RLWE ciphertexts, too.
It is a well-known fact that there are exactly <span class="math notranslate nohighlight">\(N\)</span> automorphisms of <span class="math notranslate nohighlight">\(R\)</span>, namely <span class="math notranslate nohighlight">\(\psi_i\)</span> for each coprime <span class="math notranslate nohighlight">\(i \perp 2N\)</span> (recall that <span class="math notranslate nohighlight">\(N\)</span> is a power to two), and they can be denoted by:</p>
<div class="math notranslate nohighlight">
\[\psi_i : R \longrightarrow R,  \qquad a(x) \longmapsto a(x^i), \qquad i \in \{1,3,5,\dots,2N-1\}.\]</div>
<p>If we apply <span class="math notranslate nohighlight">\(\psi_i\)</span> to a RLWE ciphertext <span class="math notranslate nohighlight">\((a(x), b(x))\)</span>, we obtain the ciphertext <span class="math notranslate nohighlight">\((a(x^i), b(x^i))\)</span>, which, though it technically encrypts <span class="math notranslate nohighlight">\(m(x^i)\)</span>, it unfortunately uses <span class="math notranslate nohighlight">\(s(x^i)\)</span> as a secret key.
We will get rid of this complication by introducing the <span class="math notranslate nohighlight">\(\texttt{key-switch}\)</span> procedure.
Further notice that the application of <span class="math notranslate nohighlight">\(\psi_i\)</span> to a ciphertext preserves the error size since <span class="math notranslate nohighlight">\(\norm{e(x^i)} = \norm{e(x)}\)</span>.</p>
<section id="key-switching">
<h3>Key switching<a class="headerlink" href="#key-switching" title="Permalink to this headline">#</a></h3>
<p>The objective of this section is to enable the bootstrapping party to execute all <span class="math notranslate nohighlight">\(N\)</span> automorphisms (without knowledge of <span class="math notranslate nohighlight">\(s\)</span>).
To begin with, we mention that for this step we will need the <span class="math notranslate nohighlight">\(s(x^i)\)</span> as pre-computed information.
Obviously, we need to encrypt <span class="math notranslate nohighlight">\(s(x^i)\)</span>, thus the following function comes in handy.
It is run by a secret-key holder, sent to the bootstrapping party in advance of bootstrapping, and involves RLWE’ encryptions (to control the error growth for <span class="math notranslate nohighlight">\(\texttt{key-switch}\)</span> later):</p>
<div class="math notranslate nohighlight">
\[\texttt{key-switch-for-eval-auto}: (\mathrm{RLWE'}_{Q,s}(s(x^i)))_{i\in \{1,3,\dots,2N-1\}}.\]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">key_switch_for_eval_auto</span><span class="p">(</span><span class="n">secret_key</span><span class="p">,</span> <span class="n">ciphertext_modulus</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">standard_deviation</span><span class="p">):</span>
    <span class="n">s</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">STD</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">secret_key</span><span class="p">,</span> <span class="n">ciphertext_modulus</span><span class="p">,</span> <span class="n">standard_deviation</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">secret_key</span><span class="p">,</span> <span class="s1">&#39;ring_degree&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[[</span><span class="n">i</span><span class="p">,</span> <span class="n">rlwe_x_encryption</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">variable_powering</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">Q</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">STD</span><span class="p">,</span> <span class="n">s</span><span class="p">)]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>
</pre></div>
</div>
</div>
</div>
<p>Now, the procedure <span class="math notranslate nohighlight">\(\texttt{key-switch}\)</span> below will actually perform the key switching from a secret key <span class="math notranslate nohighlight">\(s_1\)</span> to another secret key <span class="math notranslate nohighlight">\(s_2\)</span>.
So, starting from a ciphertext <span class="math notranslate nohighlight">\(\mathrm{RLWE}_{Q,s_1}(m) =: (a,b)\)</span>, it outputs <span class="math notranslate nohighlight">\(\mathrm{RLWE}_{Q,s_2}(m)\)</span> plus a key-switching error <span class="math notranslate nohighlight">\(e_{\text{key-switch}}\)</span>.
The defining calculation:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{split}
\texttt{key-switch}: \mathrm{RLWE}_{s_2}(m) &amp;:= a \odot \mathrm{RLWE'}_{s_2}(s_1) + (0,b) \\
&amp;= \mathrm{RLWE}_{s_2}(a\cdot s_1) + \mathrm{RLWE}_{s_2}^0(b) \\
&amp;= \mathrm{RLWE}_{s_2}(a\cdot s_1 + b) 
\\ &amp;= \mathrm{RLWE}_{s_2}(m+e_{\text{key-switch}})
\end{split}\end{split}\]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">key_switch</span><span class="p">(</span><span class="n">rlwe</span><span class="p">,</span> <span class="n">ciphertext_modulus</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">key_switch_rlwe_x</span><span class="p">):</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">ks</span> <span class="o">=</span> <span class="n">rlwe</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rlwe</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ciphertext_modulus</span><span class="p">,</span> <span class="n">key_switch_rlwe_x</span>
    <span class="n">zero</span> <span class="o">=</span> <span class="n">generate_zero_poly</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s1">&#39;ring_degree&#39;</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">rlwe_add</span><span class="p">(</span><span class="n">rlwe_x_scalar_multiply</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ks</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">B</span><span class="p">),</span> <span class="p">[</span><span class="n">zero</span><span class="p">,</span> <span class="n">b</span><span class="p">],</span> <span class="n">Q</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>By construction, <span class="math notranslate nohighlight">\(\texttt{key-switch}\)</span> yields the exact same error as in <span class="math notranslate nohighlight">\(\texttt{rlwe-x-scalar-multiply}\)</span> (see <a class="reference internal" href="#error-after-rlwe-x-scalar-multiply">Lemma 6</a>).
That means an error of size at most <span class="math notranslate nohighlight">\((B/2) \cdot \log_B(Q) \cdot \norm e \cdot \sqrt{N}\)</span>, since <span class="math notranslate nohighlight">\(\delta_R' = \sqrt{N}\)</span> in the lemma, because <span class="math notranslate nohighlight">\(a\)</span> is uniformly at random (see <a class="reference internal" href="#conclusion-on-delta-r"><span class="std std-ref">Conclusion on the expansion factor</span></a>).
Note that here <span class="math notranslate nohighlight">\(e\)</span> stands for a RLWE encryption error, independent of the error inside <span class="math notranslate nohighlight">\(\RLWE_{s_2}(m)\)</span>.</p>
</section>
<section id="evaluating-automorphism">
<h3>Evaluating automorphism<a class="headerlink" href="#evaluating-automorphism" title="Permalink to this headline">#</a></h3>
<p>We are now able to evaluate <span class="math notranslate nohighlight">\(\psi_t\)</span> for an arbitrary <span class="math notranslate nohighlight">\(t\perp 2N\)</span> on a RLWE ciphertext, since we can change the secret key from <span class="math notranslate nohighlight">\(s(x^i)\)</span> to <span class="math notranslate nohighlight">\(s\)</span> again after applying <span class="math notranslate nohighlight">\(\psi_t\)</span>.
The function below transforms <span class="math notranslate nohighlight">\(\mathrm{RLWE}_{Q,s}(m(x))\)</span> into <span class="math notranslate nohighlight">\(\mathrm{RLWE}_{Q,s}(m(x^t))\)</span> by using <span class="math notranslate nohighlight">\(\texttt{key-switch}\)</span> after <span class="math notranslate nohighlight">\(t\)</span>-powering the polynomial variable <span class="math notranslate nohighlight">\(x\)</span>.</p>
<p>Remark on the code:
We highlight the pre-computational part by storing <span class="math notranslate nohighlight">\(t\)</span> right along with the RLWE’ encryption of <span class="math notranslate nohighlight">\(s(x^t)\)</span> (instead of accessing it directly) since this information will get transmitted by the holder of <span class="math notranslate nohighlight">\(s\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">eval_auto</span><span class="p">(</span><span class="n">rlwe</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">ciphertext_modulus</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">key_switch_array</span><span class="p">):</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">Q</span> <span class="o">=</span> <span class="n">rlwe</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rlwe</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">rlwe</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;ring_degree&#39;</span><span class="p">),</span> <span class="n">ciphertext_modulus</span>
    <span class="n">eval_a</span><span class="p">,</span> <span class="n">eval_b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">variable_powering</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">Q</span><span class="p">),</span> <span class="n">b</span><span class="o">.</span><span class="n">variable_powering</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">key_switch_array</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">key_switch_array</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="n">t</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">key_switch</span><span class="p">([</span><span class="n">eval_a</span><span class="p">,</span> <span class="n">eval_b</span><span class="p">],</span> <span class="n">Q</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">key_switch_array</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<p>Clearly, the error during an automorphism evaluation is precisely equal to the error of <span class="math notranslate nohighlight">\(\texttt{key-switch}\)</span>.</p>
<p>As a demonstration, we apply the transformation <span class="math notranslate nohighlight">\(x \longmapsto x^3\)</span> for a randomly selected message.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">B</span> <span class="o">=</span> <span class="mi">8</span>  <span class="c1"># example selection</span>
<span class="n">key_switch_array</span> <span class="o">=</span> <span class="n">key_switch_for_eval_auto</span><span class="p">(</span><span class="n">SK</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">STD</span><span class="p">)</span> <span class="c1"># precomputation</span>

<span class="n">Random_Poly</span> <span class="o">=</span> <span class="n">print_and_return</span><span class="p">(</span><span class="s2">&quot;Message&quot;</span><span class="p">,</span> <span class="n">generate_uniform_distribution</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="n">Random_Poly_Enc</span> <span class="o">=</span> <span class="n">encrypt</span><span class="p">(</span><span class="n">Random_Poly</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">STD</span><span class="p">,</span> <span class="n">PK</span><span class="p">)</span>
<span class="n">Morphed</span> <span class="o">=</span> <span class="n">eval_auto</span><span class="p">(</span><span class="n">Random_Poly_Enc</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">key_switch_array</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Message after eval-auto: x --&gt; x^3: </span><span class="si">{</span><span class="n">decrypt</span><span class="p">(</span><span class="n">Morphed</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">SK</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Note that x^(</span><span class="si">{</span><span class="n">two_power</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="si">}</span><span class="s2">) = -1 and coefficients are mod </span><span class="si">{</span><span class="n">two_power</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

<span class="n">KS_error</span> <span class="o">=</span> <span class="n">Morphed</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">SK</span><span class="p">)</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Morphed</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">Random_Poly</span><span class="o">.</span><span class="n">variable_powering</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">scalar_multiply</span><span class="p">(</span><span class="n">Q</span><span class="o">//</span><span class="n">T</span><span class="p">),</span> <span class="n">Q</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error size after key switching: </span><span class="si">{</span><span class="n">KS_error</span><span class="o">.</span><span class="n">mod_small</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Factor from error bound: (B/2) * log_B(Q) * sqrt(N) = </span><span class="si">{</span><span class="p">(</span><span class="n">B</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">log</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">B</span><span class="p">)</span> <span class="o">*</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Message = 3x^3 + 3x^2 + 2x + 1
Message after eval-auto: x --&gt; x^3: 2x^3 + x^2 + 3x + 1
Note that x^(2^2) = -1 and coefficients are mod 2^2.
Error size after key switching: 30
Factor from error bound: (B/2) * log_B(Q) * sqrt(N) = 53.333333333333336
</pre></div>
</div>
</div>
</div>
<p>The code also illustrates the error growth during <span class="math notranslate nohighlight">\(\texttt{key-switch}\)</span>.
It prints the factor <span class="math notranslate nohighlight">\((B/2) \log_B(Q) \sqrt{N}\)</span> from <a class="reference internal" href="#error-after-rlwe-x-scalar-multiply">Lemma 6</a>, which gets multiplied with the intrinsic error size from the original encryption.
We observe that the error after key switching is usually much smaller than the bound times at least 1.</p>
</section>
</section>
<section id="rescaling">
<span id="id46"></span><h2>Rescaling<a class="headerlink" href="#rescaling" title="Permalink to this headline">#</a></h2>
<p>The last key step, which has already been implicitly employed during the multiplication of BFV ciphertexts, is the rescaling procedure.
Recall how we introduced the auxiliary modulus <span class="math notranslate nohighlight">\(P\)</span> within the relinearization key (see e.g. <a class="reference internal" href="#relinearization-error">Lemma 5</a>).
To sum it up, its main purpose was scaling down a big error to a small one.
The simple way to do that was just to divide both components of a ciphertext by the factor <span class="math notranslate nohighlight">\(P\)</span>.
Notice that in this case the hidden message gets divided by <span class="math notranslate nohighlight">\(P\)</span>, too.
We had handled this side effect by having multiplied the message by <span class="math notranslate nohighlight">\(P\)</span> beforehand, such that division by <span class="math notranslate nohighlight">\(P\)</span> afterwards just yields the message again.</p>
<p>Now, the same idea can be generalized to RLWE ciphertexts, in which we want to solely scale down the ciphertext modulus while a priori not preserving the encryption of the same message, but a scaled-down version.
So for powers of two <span class="math notranslate nohighlight">\(q &lt; Q\)</span>, we define:</p>
<div class="math notranslate nohighlight">
\[\texttt{rescale}: \mathrm{RLWE}_{Q,s}(m) := (a,b) \longmapsto \left(\round{ \frac{a}{Q/q}} , \round{ \frac{b}{Q/q} } \right)  =: \mathrm{RLWE}_{q,s}\left(\round {\frac{m}{Q/q} }\right).\]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">rescale</span><span class="p">(</span><span class="n">rlwe</span><span class="p">,</span> <span class="n">old_modulus</span><span class="p">,</span> <span class="n">new_modulus</span><span class="p">):</span>
    <span class="n">Q</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">old_modulus</span><span class="p">,</span> <span class="n">new_modulus</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">rlwe</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">rounded_integer_divide</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">Q</span><span class="o">//</span><span class="n">q</span><span class="p">),</span> <span class="n">rlwe</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">rounded_integer_divide</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">Q</span><span class="o">//</span><span class="n">q</span><span class="p">)]</span>
</pre></div>
</div>
</div>
</div>
<p>Remark:
Needless to say, the rounding introduces a rescaling error <span class="math notranslate nohighlight">\(e_{\text{res}}\)</span>.
As in the proof of <a class="reference internal" href="#relinearization-error">Lemma 5</a>, we can estimate its size via:</p>
<div class="math notranslate nohighlight">
\[\norm{e_{\text{res}}} = \norm{ \round{ \frac{a}{Q/q}} \cdot s + \round{ \frac{b}{Q/q} } - \round{(as+b)/(Q/q)} } \le \delta_R/2 + 1/2.\]</div>
<p>Since we use the estimation <span class="math notranslate nohighlight">\(\delta_R \approx \sqrt{N}\)</span> anyway, we conclude that <span class="math notranslate nohighlight">\(\norm{e_{\text{res}}} \le \sqrt{N}/2\)</span>.</p>
<p>Rescaling will later be the last part of the core <span class="math notranslate nohighlight">\(\texttt{scaled-mod}\)</span> procedure and, thus, the total error, which has been accumulated beforehand, can be scaled down appropriately by <span class="math notranslate nohighlight">\(\texttt{rescale}\)</span>.</p>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="bootstrapping">
<span id="id47"></span><h1>Bootstrapping<a class="headerlink" href="#bootstrapping" title="Permalink to this headline">#</a></h1>
<section id="the-texttt-scaled-mod-procedure">
<h2>The <span class="math notranslate nohighlight">\(\texttt{scaled-mod}\)</span> procedure<a class="headerlink" href="#the-texttt-scaled-mod-procedure" title="Permalink to this headline">#</a></h2>
<p>The main task during bootstrapping is scaling up a message inside a RLWE ciphertext by a large factor <span class="math notranslate nohighlight">\(\Delta\)</span>.
Precisely, we want to transform <span class="math notranslate nohighlight">\(\mathrm{RLWE}_{2N,s}^0(u)\)</span>, with <span class="math notranslate nohighlight">\(u\)</span> satisfying <span class="math notranslate nohighlight">\(\norm u &lt; N/2\)</span>, into <span class="math notranslate nohighlight">\(\mathrm{RLWE}_{Q,s}(\Delta \cdot u)\)</span>.
How this procedure (<span class="math notranslate nohighlight">\(\texttt{scaled-mod}\)</span>) can be used to serve the actual purpose of bootstrapping, i.e. scaling down a big error, will be described afterwards.</p>
<p>The above discussion in <a class="reference internal" href="#preparations-for-bootstrapping"><span class="std std-ref">Preparations for bootstrapping</span></a> of multiplying RLWE ciphertexts and especially <a class="reference internal" href="#error-after-rlwe-x-scalar-multiply">Lemma 6</a> points out that this is a non-trivial task when using a large <span class="math notranslate nohighlight">\(\Delta\)</span>, because of error issues.
Once this has been achieved, the rest of our bootstrapping procedure consists of fitting the BFV encryption scheme towards the <span class="math notranslate nohighlight">\(\texttt{scaled-mod}\)</span> procedure, i.e. how to obtain the ciphertext of <span class="math notranslate nohighlight">\(u\)</span> from a BFV ciphertext and vice versa afterwards.
The name “scaled modulus raising” comes from scaling up by <span class="math notranslate nohighlight">\(\Delta\)</span> and from using a significantly larger modulus <span class="math notranslate nohighlight">\(Q\)</span> during the process to handle error growth.
At this point, we leave questions, e.g. why we initially assume an errorless encryption etc., for later.</p>
<p><span class="math notranslate nohighlight">\(\texttt{scaled-mod}\)</span> itself, which Section 3 of <span id="id48">[<a class="reference internal" href="#id69" title="Andrey Kim, Maxim Deryabin, Jieun Eom, Rakyong Choi, Yongwoo Lee, Whan Ghang, and Donghoon Yoo. General bootstrapping approach for rlwe-based homomorphic encryption. Cryptology ePrint Archive, Paper 2021/691, 2021. https://eprint.iacr.org/2021/691. URL: https://eprint.iacr.org/2021/691.">Kim <em>et al.</em>, 2021</a>]</span> covers, includes three steps:</p>
<ol class="simple">
<li><p>The extraction of LWE ciphertexts, where we essentially split up the problem in <span class="math notranslate nohighlight">\(N\)</span> single-dimensional (LWE) versions.</p></li>
<li><p>Blind rotation, where the main transformation towards <span class="math notranslate nohighlight">\(\Delta \cdot u\)</span> is realized.
It is by far the most costly operation.</p></li>
<li><p>Repacking, where we reunite our split-up ciphertexts into a single one, which contains all information.</p></li>
</ol>
</section>
<section id="step-1-extraction-of-lwe-ciphertexts">
<span id="extraction-of-lwe-ciphertexts"></span><h2>Step 1: Extraction of LWE ciphertexts<a class="headerlink" href="#step-1-extraction-of-lwe-ciphertexts" title="Permalink to this headline">#</a></h2>
<p>In defining LWE ciphertexts, losing the letter ‘R’ ≙ ring leaves us with integers as messages (whereas in RLWE we have <span class="math notranslate nohighlight">\(N\)</span> integers encoded in a polynomial message).
Apart from that, it has a very similar representation:</p>
<div class="math notranslate nohighlight">
\[\mathrm{LWE}_{Q,\vec s}(m) := (\vec a, -\langle \vec a, \vec s\rangle + e + m) \in \mathbb Z_Q^{N+1},\]</div>
<p>where <span class="math notranslate nohighlight">\(\vec a, \vec s \in \Z_Q^N\)</span> and <span class="math notranslate nohighlight">\(e, m \in \Z_Q\)</span>.
Again, if <span class="math notranslate nohighlight">\(e = 0\)</span>, then we will write <span class="math notranslate nohighlight">\(\mathrm{LWE}^0\)</span>.</p>
<p>Naturally, the LWE ciphertext security has been thoroughly analysed, as the concept was already existent prior to RLWE.
An extensive survey on this topic can be found in Section 4.2 of <span id="id49">[<a class="reference internal" href="#id62" title="Chris Peikert. A decade of lattice cryptography. Cryptology ePrint Archive, Paper 2015/939, 2015. https://eprint.iacr.org/2015/939. URL: https://eprint.iacr.org/2015/939.">Peikert, 2015</a>]</span>.
Moreover, since RLWE is based upon LWE, if we generate LWE ciphertexts from RLWE ciphertexts, all the security measures (as described in <a class="reference internal" href="#security"><span class="std std-ref">Security</span></a>) apply as well.
To preserve these, we write <span class="math notranslate nohighlight">\(\vec s := (s_0,\dots,s_{N-1})\)</span> as the coefficient vector of <span class="math notranslate nohighlight">\(s\)</span> and since the RLWE distributions for <span class="math notranslate nohighlight">\(a,s\)</span> and <span class="math notranslate nohighlight">\(e\)</span> are employed coefficient-wise, their properties still hold up in the context of the related LWE security.</p>
<p>The goal of the extraction essentially is properly representing the calculation of the linear combinations of the coefficients during a polynomial multiplication in <span class="math notranslate nohighlight">\(R\)</span>:</p>
<div class="math notranslate nohighlight">
\[s\cdot a = \left( \sum_{i=0}^{N-1} s_i x^i \right) \left( \sum_{i=0}^{N-1} a_i x^i \right) = \sum_{i=0}^{N-1}\left( \sum_{j=0}^{i} s_j a_{i-j} + \sum_{j=i+1}^{N-1} - s_j a_{i+N-j}\right) x^i =: \sum_{i=0}^{N-1} c_i x^i\]</div>
<p>Notice that the minus sign originates from the choice of <span class="math notranslate nohighlight">\(R\)</span>, i.e. <span class="math notranslate nohighlight">\(x^N=-1\)</span>.
Hence, if we want to create a LWE ciphertext per coefficient <span class="math notranslate nohighlight">\(c_i\)</span> of the above, we define:</p>
<div class="math notranslate nohighlight">
\[\tilde a_i := (a_i,a_{i-1},\dots,a_0,-a_{N-1},-a_{N-2},\dots,-a_{i+1}) \qquad \text{and} \qquad c_i := \langle \tilde a_i, \vec s \rangle = (a \cdot s)_i.\]</div>
<p>In total, we receive <span class="math notranslate nohighlight">\(N\)</span> LWE ciphertexts of the form <span class="math notranslate nohighlight">\(\mathrm{LWE}_{2N,\vec s}^0(u_i)\)</span>, extracted from the given <span class="math notranslate nohighlight">\(\mathrm{RLWE}_{2N,s}^0(u) = (a,b)\)</span>:</p>
<div class="math notranslate nohighlight">
\[\mathrm{LWE}_{2N,\vec s}^0(u_i) := (\tilde{a}_i, b_i) \qquad \text{with} \qquad \langle \tilde a_i, \vec s \rangle + b_i = u_i.\]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">extraction</span><span class="p">(</span><span class="n">rlwe</span><span class="p">):</span>
    <span class="n">a_coeffs</span><span class="p">,</span> <span class="n">b_coeffs</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">rlwe</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;coeffs&#39;</span><span class="p">),</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">rlwe</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;coeffs&#39;</span><span class="p">),</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">rlwe</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;ring_degree&#39;</span><span class="p">)</span>
    <span class="n">a_rotation</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">a_rotation</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">a_coeffs</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">j</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
            <span class="n">a_rotation</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">a_coeffs</span><span class="p">[</span><span class="n">N</span> <span class="o">+</span> <span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">[[</span><span class="n">mod</span><span class="p">(</span><span class="n">a_rotation</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">N</span><span class="p">),</span> <span class="n">mod</span><span class="p">(</span><span class="n">b_coeffs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">N</span><span class="p">)]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="step-2-blind-rotation">
<span id="blind-rotation"></span><h2>Step 2: Blind rotation<a class="headerlink" href="#step-2-blind-rotation" title="Permalink to this headline">#</a></h2>
<p>Starting from an extracted <span class="math notranslate nohighlight">\(\mathrm{LWE}_{2N,\vec s}^0(u) := (\vec \alpha, \beta)\)</span> ciphertext, we want to obtain a RLWE encryption of <span class="math notranslate nohighlight">\(\Delta \cdot u\)</span> by using the techniques of <a class="reference internal" href="#preparations-for-bootstrapping"><span class="std std-ref">Preparations for bootstrapping</span></a> to handle the error growth.
Recall that here <span class="math notranslate nohighlight">\(u\)</span> is an integer, thus <span class="math notranslate nohighlight">\(\Delta \cdot u\)</span> is as well, and therefore we have plenty of liberty in choosing the polynomial RLWE message, apart from the desired constant coefficient <span class="math notranslate nohighlight">\(\Delta \cdot u\)</span>.
On the other hand, we will also need this liberty, because we have no knowledge of what exactly <span class="math notranslate nohighlight">\(u\)</span> is, just knowledge of the size estimation <span class="math notranslate nohighlight">\(\abs u \le N/2\)</span>.</p>
<section id="rotation-function">
<h3>Rotation function<a class="headerlink" href="#rotation-function" title="Permalink to this headline">#</a></h3>
<p>The above observation leads to the notion of the blind rotation function <span class="math notranslate nohighlight">\(f\)</span>, which prepares the right scaling with <span class="math notranslate nohighlight">\(\Delta\)</span> at all possible coefficients of a RLWE message polynomial.</p>
<p>We define:</p>
<div class="math notranslate nohighlight">
\[f := \sum_{j=-c}^c -\Delta\cdot j \cdot x^j \in R, \qquad \text{ where } \abs u \le c &lt; N/2.\]</div>
<p>We will provide the details of <span class="math notranslate nohighlight">\(c\)</span> later on.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">initialize_rotation_function</span><span class="p">(</span><span class="n">key_size</span><span class="p">,</span> <span class="n">Delta</span><span class="p">,</span> <span class="n">c_boundary</span><span class="p">,</span> <span class="n">ciphertext_modulus</span><span class="p">):</span>
    <span class="n">function_coeffs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">key_size</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">c_boundary</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">function_coeffs</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">j</span><span class="o">*</span><span class="n">Delta</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">c_boundary</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">function_coeffs</span><span class="p">[</span><span class="n">key_size</span> <span class="o">-</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">j</span><span class="o">*</span><span class="n">Delta</span>
    <span class="k">return</span> <span class="n">Poly</span><span class="p">(</span><span class="n">key_size</span><span class="p">,</span> <span class="n">function_coeffs</span><span class="p">)</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">ciphertext_modulus</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>This now allows us, regardless of the special value of <span class="math notranslate nohighlight">\(u\)</span>, to have that <span class="math notranslate nohighlight">\((f\cdot x^u)(0) = \Delta \cdot u\)</span> (here we have used <span class="math notranslate nohighlight">\(\abs u \le c &lt; N/2\)</span> and thus <span class="math notranslate nohighlight">\(\mathrm{deg}(f\cdot x^u) &lt; N\)</span>) as an easy calculation shows.
Note that at this point the LWE extraction serves its purpose, since <span class="math notranslate nohighlight">\(u\)</span> as an integer can be selected as an exponent of <span class="math notranslate nohighlight">\(x\)</span> (contrary to a polynomial message).
Moving <span class="math notranslate nohighlight">\(u\)</span> to the exponent, instead of e.g. multiplying it directly with <span class="math notranslate nohighlight">\(\Delta\)</span>, yields a notably smaller error.
Recall, that it was already briefly mentioned beforehand (see <a class="reference internal" href="#equation-rlwe-multiply-error-growth">(7)</a>) that monomials can be cheaply multiplied with ciphertexts (in terms of error growth) compared to e.g. constants.
We make use of that, but <span class="math notranslate nohighlight">\(x^u\)</span> still does not suffice, because it is unknown, hence we have to perform monomial multiplication <span class="math notranslate nohighlight">\(N\)</span> times:</p>
<div class="math notranslate nohighlight">
\[x^u = x^\beta \cdot x^{\alpha_0 s_0} \cdots x^{\alpha_{N-1} s_{N-1}}, \qquad \text{since } u = \beta + \langle \vec \alpha, \vec s \rangle.\]</div>
<p>Here we utilized the properties of a LWE ciphertext.</p>
<p>Finally, we need to consider:
It is inevitable for a secret key holder to do some precomputation, which on the one hand, encrypts the secret key bits <span class="math notranslate nohighlight">\(s_i\)</span> one-by-one, and is, on the other hand, compatible with exponent multiplication, i.e. for later obtaining <span class="math notranslate nohighlight">\(x^{\alpha_i s_i}\)</span>.
RGSW ciphertexts solve both issues.</p>
</section>
<section id="blind-rotation-keys">
<h3>Blind rotation keys<a class="headerlink" href="#blind-rotation-keys" title="Permalink to this headline">#</a></h3>
<p>We hide the information about the bits of our ternary secret key <span class="math notranslate nohighlight">\(s\)</span> in a stack of <span class="math notranslate nohighlight">\(2N\)</span> RGSW ciphertexts.
First of all, a coefficient <span class="math notranslate nohighlight">\(s_i \in \{-1,0,1\}\)</span> gets separated into its positive and its negative part.
So we define:</p>
<div class="math notranslate nohighlight">
\[s_i^+ = 1 :\iff s_i = 1, \qquad s_i^- = 1 :\iff s_i = -1.\]</div>
<p>Otherwise <span class="math notranslate nohighlight">\(s_i^+\)</span> respectively <span class="math notranslate nohighlight">\(s_i^-\)</span> is set to <span class="math notranslate nohighlight">\(0\)</span>.
Now we define the blind rotation keys computed by a secret key holder in advance as:</p>
<div class="math notranslate nohighlight">
\[\texttt{blind-rotation-keys}: (\mathrm{RGSW}_{Q,s}(s_i^+), \mathrm{RGSW}_{Q,s}(s_i^-))_{i \in \{0,\dots,N-1\}}.\]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">blind_rotation_keys</span><span class="p">(</span><span class="n">ciphertext_modulus</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">standard_deviation</span><span class="p">,</span> <span class="n">secret_key</span><span class="p">):</span>
    <span class="n">Q</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">STD</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">ciphertext_modulus</span><span class="p">,</span> <span class="n">secret_key</span><span class="p">,</span> <span class="n">standard_deviation</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">secret_key</span><span class="p">,</span> <span class="s1">&#39;ring_degree&#39;</span><span class="p">)</span>
    <span class="n">s_coeffs</span><span class="p">,</span> <span class="n">zeropoly</span><span class="p">,</span> <span class="n">onepoly</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s1">&#39;coeffs&#39;</span><span class="p">),</span> <span class="n">generate_zero_poly</span><span class="p">(</span><span class="n">N</span><span class="p">),</span> <span class="n">generate_one_poly</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">brk</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">s_coeffs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">brk</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">rgsw_encryption</span><span class="p">(</span><span class="n">onepoly</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">STD</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">brk</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">rgsw_encryption</span><span class="p">(</span><span class="n">zeropoly</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">STD</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">s_coeffs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">brk</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">rgsw_encryption</span><span class="p">(</span><span class="n">onepoly</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">STD</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">brk</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">rgsw_encryption</span><span class="p">(</span><span class="n">zeropoly</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">STD</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">brk</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="blind-rotation-algorithm">
<h3>Blind rotation algorithm<a class="headerlink" href="#blind-rotation-algorithm" title="Permalink to this headline">#</a></h3>
<p>The last missing piece is a trivial (i.e. error-free and not using the secret key <span class="math notranslate nohighlight">\(s\)</span>) RGSW encryption of <span class="math notranslate nohighlight">\(1\)</span>.
We need it such that the following equation holds:</p>
<div class="math notranslate nohighlight">
\[\mathrm{RGSW}_{Q,s}(x^{\alpha_i s_i}) = \mathrm{RGSW}_{Q,s}^0(1) + (x^{\alpha_i}-1)\cdot \mathrm{RGSW}_{Q,s}(s_i^+) + (x^{-\alpha_i}-1)\cdot \mathrm{RGSW}_{Q,s}(s_i^-)\]</div>
<p>Recall that either <span class="math notranslate nohighlight">\(s_i^+\)</span> or <span class="math notranslate nohighlight">\(s_i^-\)</span> is zero.
In this case, the corresponding summand is equal to <span class="math notranslate nohighlight">\(\mathrm{RGSW}_{Q,s}(0)\)</span>.
Because RGSW errors behave favorably during additions, we merge everything into the result while only performing two <span class="math notranslate nohighlight">\(\texttt{rgsw-multiply-with-poly}\)</span> operations with a polynomial <span class="math notranslate nohighlight">\((x^{\pm \alpha_i}-1)\)</span> which is still almost as optimal as a monomial (see below <a class="reference internal" href="#equation-rlwe-multiply-error-growth">(7)</a>).</p>
<p>We realize the trivial RGSW encryption of <span class="math notranslate nohighlight">\(1\)</span> as follows:</p>
<div class="math notranslate nohighlight">
\[\RGSW_{Q,s}^0(1) = (\RLWEx_{Q,s}^0(s), \mathrm{RLWE'}_{Q,s}^0(1)) := ((B^i,0)_{i\in \{0,\dots,l-1\}}, (0,B^i)_{i\in \{0,\dots,l-1\}})\]</div>
<p>with <span class="math notranslate nohighlight">\(l = \lceil \log_B(Q) \rceil\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_trivial_rgsw_of_one</span><span class="p">(</span><span class="n">ciphertext_modulus</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">key_size</span><span class="p">):</span>
    <span class="n">g</span> <span class="o">=</span> <span class="p">[</span><span class="n">generate_constant_poly</span><span class="p">(</span><span class="n">key_size</span><span class="p">,</span> <span class="n">B</span> <span class="o">**</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ceil</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">ciphertext_modulus</span><span class="p">,</span> <span class="n">B</span><span class="p">)))]</span>
    <span class="n">zero</span> <span class="o">=</span> <span class="n">generate_zero_poly</span><span class="p">(</span><span class="n">key_size</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[[[</span><span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">zero</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="p">))],</span> <span class="p">[[</span><span class="n">zero</span><span class="p">,</span> <span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="p">))]]</span>
</pre></div>
</div>
</div>
</div>
<p>After having done the above RGSW ciphertext merging for every index <span class="math notranslate nohighlight">\(i\)</span>, we need to multiplicatively put everything into a RLWE ciphertext.
Starting from <span class="math notranslate nohighlight">\(\mathrm{RLWE}_{Q,s}^0(f \cdot x^\beta) := (0,f\cdot x^{\beta})\)</span> we apply the <span class="math notranslate nohighlight">\(\texttt{star-multiplication}\)</span> <span class="math notranslate nohighlight">\(N\)</span> times to accumulate our RGSW ciphertexts of the single monomials <span class="math notranslate nohighlight">\(x^{\alpha_i s_i}\)</span>.</p>
<p>The right-hand side being computed from left to right, we have:</p>
<div class="math notranslate nohighlight">
\[\mathrm{RLWE}_{Q,s}(f \cdot x^u) := \mathrm{RLWE}_{Q,s}^0(f \cdot x^\beta) \circledast \mathrm{RGSW}_{Q,s}(x^{\alpha_0 s_0}) \circledast \dots \circledast \mathrm{RGSW}_{Q,s}(x^{\alpha_{N-1}  s_{N-1}})\]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">blind_rotation</span><span class="p">(</span><span class="n">lwe_ciphertext</span><span class="p">,</span> <span class="n">blind_rotation_keys</span><span class="p">,</span> <span class="n">Delta</span><span class="p">,</span> <span class="n">c_boundary</span><span class="p">,</span> <span class="n">ciphertext_modulus</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">rgsw_one</span><span class="p">):</span>
    <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">brk</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">lwe_ciphertext</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">lwe_ciphertext</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">blind_rotation_keys</span><span class="p">,</span> <span class="n">Delta</span><span class="p">,</span> <span class="n">c_boundary</span>
    <span class="n">Q</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">ciphertext_modulus</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">initialize_rotation_function</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>
    <span class="n">ACC</span> <span class="o">=</span> <span class="p">[</span><span class="n">generate_zero_poly</span><span class="p">(</span><span class="n">N</span><span class="p">),</span> <span class="n">f</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">generate_monomial</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">beta</span><span class="p">),</span> <span class="n">Q</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>        
        <span class="n">pos_rotation</span> <span class="o">=</span> <span class="n">rotation_poly</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">alpha</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Q</span><span class="p">)</span>
        <span class="n">neg_rotation</span> <span class="o">=</span> <span class="n">rotation_poly</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="o">-</span><span class="n">alpha</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Q</span><span class="p">)</span>
        <span class="n">rgsw_plus</span> <span class="o">=</span> <span class="n">rgsw_multiply_with_poly</span><span class="p">(</span><span class="n">brk</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">pos_rotation</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>
        <span class="n">rgsw_minus</span> <span class="o">=</span> <span class="n">rgsw_multiply_with_poly</span><span class="p">(</span><span class="n">brk</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">neg_rotation</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>
        <span class="n">rgsw</span> <span class="o">=</span> <span class="n">rgsw_add</span><span class="p">(</span><span class="n">rgsw_add</span><span class="p">(</span><span class="n">rgsw_plus</span><span class="p">,</span> <span class="n">rgsw_minus</span><span class="p">,</span> <span class="n">Q</span><span class="p">),</span> <span class="n">rgsw_one</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>
        <span class="n">ACC</span> <span class="o">=</span> <span class="n">star_multiplication</span><span class="p">(</span><span class="n">ACC</span><span class="p">,</span> <span class="n">rgsw</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ACC</span>
</pre></div>
</div>
</div>
</div>
<p>Summary:
Taking <span class="math notranslate nohighlight">\(\mathrm{LWE}_{2N,s}^0(u)\)</span> and blind rotating it to <span class="math notranslate nohighlight">\(\mathrm{RLWE}_{Q,s}(f \cdot x^u) := (a,b)\)</span> has the desired effect of having <span class="math notranslate nohighlight">\(\Delta \cdot u\)</span> as the constant coefficient of <span class="math notranslate nohighlight">\(f \cdot x^u\)</span>.
Moreover, we have:</p>
<div class="math notranslate nohighlight" id="equation-blind-rotation-decryption">
<span class="eqno">(8)<a class="headerlink" href="#equation-blind-rotation-decryption" title="Permalink to this equation">#</a></span>\[a\cdot s+b = e_{\text{br}} + (\Delta \cdot u + \star \cdot x + \dots + \star \cdot x^{N-1}).\]</div>
<p>Here <span class="math notranslate nohighlight">\(e_{\text{br}}\)</span> denotes the blind rotation error and <span class="math notranslate nohighlight">\(\star\)</span> stands for an arbitrary coefficient.</p>
</section>
<section id="error-discussion">
<h3>Error discussion<a class="headerlink" href="#error-discussion" title="Permalink to this headline">#</a></h3>
<div class="proof lemma admonition" id="blind-rotation-error">
<p class="admonition-title"><span class="caption-number">Lemma 8 </span> (Blind rotation error)</p>
<section class="lemma-content" id="proof-content">
<p>If a RLWE encryption error has size at most <span class="math notranslate nohighlight">\(E\)</span>, then the error after blind rotation <span class="math notranslate nohighlight">\(e_{\text{br}}\)</span> satisfies:</p>
<div class="math notranslate nohighlight">
\[\norm{e_{\text{br}}} \le 4N^{3/2}B \log_B(Q) E.\]</div>
</section>
</div><p>By <span class="math notranslate nohighlight">\(E\)</span> we mean an error size bound coming from a fresh RLWE encryption, thus depending on the standard deviation parameter (see <a class="reference internal" href="#error-after-BFV-encryption">Lemma 3</a>, <a class="reference internal" href="#sampling-bound">Theorem 2</a>).</p>
<div class="proof admonition" id="proof">
<p>Proof. During the computation of <span class="math notranslate nohighlight">\(\RGSW_{Q,s}(x^{\alpha_i s_i})\)</span>, we perform <span class="math notranslate nohighlight">\(\texttt{rgsw-multiply-with-poly}\)</span> two times.
Following <a class="reference internal" href="#equation-rlwe-multiply-error-growth">(7)</a>, the error size after this multiplication is at most <span class="math notranslate nohighlight">\(2E\)</span> in each RLWE component of RGSW, since we are using the sum of monomials <span class="math notranslate nohighlight">\(x^{\pm \alpha_i} - 1\)</span>.
Adding both together (and adding the errorfree <span class="math notranslate nohighlight">\(\RGSW^0(1)\)</span>) yields an error size bounded by <span class="math notranslate nohighlight">\(4E\)</span> inside each <span class="math notranslate nohighlight">\(\RGSW_{Q,s}(x^{\alpha_i s_i})\)</span>.</p>
<p>Applying <span class="math notranslate nohighlight">\(\circledast\)</span>, thus applying <a class="reference internal" href="#error-after-star-multiplication">Lemma 7</a> <span class="math notranslate nohighlight">\(N\)</span> times with <span class="math notranslate nohighlight">\(\norm{m_2} = 1\)</span> and <span class="math notranslate nohighlight">\(\norm{e_2} \le 4E\)</span>, yields the claim.</p>
</div>
</section>
<section id="sparseness-after-blind-rotation">
<h3>Sparseness after blind rotation<a class="headerlink" href="#sparseness-after-blind-rotation" title="Permalink to this headline">#</a></h3>
<p>It is important for the upcoming <span class="math notranslate nohighlight">\(\texttt{repack}\)</span> procedure to further specify a property about the <span class="math notranslate nohighlight">\(\star\)</span>’s in <a class="reference internal" href="#equation-blind-rotation-decryption">(8)</a>.
After <span class="math notranslate nohighlight">\(\texttt{blind-rotation}\)</span>, we obtained a RLWE encryption of <span class="math notranslate nohighlight">\(f \cdot x^u =: \tilde u\)</span>.
Recall that, starting from <span class="math notranslate nohighlight">\(x^u\)</span>, the multiplication with the rotation function <span class="math notranslate nohighlight">\(f\)</span> only produces non-zero coefficients of <span class="math notranslate nohighlight">\(\tilde u\)</span> in the range <span class="math notranslate nohighlight">\(x^{u-c},\dots, x^{u+c}\)</span>.
Because <span class="math notranslate nohighlight">\(\abs u\)</span> was initially bounded by <span class="math notranslate nohighlight">\(c\)</span>, we can conclude that <span class="math notranslate nohighlight">\(\tilde u\)</span> only has non-zero coefficients in the range <span class="math notranslate nohighlight">\(x^{-2c},\dots, x^{2c}\)</span>.
So, if later <span class="math notranslate nohighlight">\(4c\)</span> is much smaller than <span class="math notranslate nohighlight">\(N\)</span>, we can use the remaining coefficients being zero to our advantage by simplifying and speeding up the <span class="math notranslate nohighlight">\(\texttt{repack}\)</span> procedure.</p>
</section>
</section>
<section id="step-3-repacking">
<span id="repacking"></span><h2>Step 3: Repacking<a class="headerlink" href="#step-3-repacking" title="Permalink to this headline">#</a></h2>
<p>Having applied <span class="math notranslate nohighlight">\(\texttt{blind-rotation}\)</span> to <span class="math notranslate nohighlight">\(N\)</span> LWE ciphertexts (with messages <span class="math notranslate nohighlight">\(u_0,\dots,u_{N-1}\)</span>), we are left with merging the information contained in the latter, which only lies in the <span class="math notranslate nohighlight">\(N\)</span> constant coefficients.
So the <span class="math notranslate nohighlight">\(\texttt{repack}\)</span> procedure takes ciphertexts <span class="math notranslate nohighlight">\(\mathrm{RLWE}_{Q,s}(\tilde u_i)\)</span> for <span class="math notranslate nohighlight">\(i \in \{0,\dots,N-1\}\)</span> as an input.</p>
<section id="simple-merging-from-sparseness">
<h3>Simple merging from sparseness<a class="headerlink" href="#simple-merging-from-sparseness" title="Permalink to this headline">#</a></h3>
<p>First of all, we make use of the sparseness described above.
Select a minimal <span class="math notranslate nohighlight">\(n\)</span>, a power of two for which <span class="math notranslate nohighlight">\(n &gt; 2c\)</span> (recall that <span class="math notranslate nohighlight">\(\abs {u_i} \le c\)</span> for all <span class="math notranslate nohighlight">\(i\)</span>) holds.
Because the <span class="math notranslate nohighlight">\(\tilde u_i\)</span> have at most <span class="math notranslate nohighlight">\(n\)</span> non-zero coefficients, we may now merge subsets of <span class="math notranslate nohighlight">\(N/n\)</span> ciphertexts into a single one, by individually shifting the corresponding coefficients all by <span class="math notranslate nohighlight">\(0,n,2n,\dots,N-n\)</span> and afterwards adding all ciphertexts.
Shifting is done by the (error-wise cheap) <span class="math notranslate nohighlight">\(\texttt{rlwe-multiply-with-poly}\)</span> with <span class="math notranslate nohighlight">\(x^{nk}\)</span> for <span class="math notranslate nohighlight">\(k \in \{0,1,\dots,N/n-1\}\)</span>. We do this for every integer <span class="math notranslate nohighlight">\(i \in [0,n-1]\)</span>.</p>
<p>More precisely: Taking a subset of ciphertexts of <span class="math notranslate nohighlight">\((\tilde u_{i+nk})_{k \in \{0,1,\dots,N/n-1\}}\)</span> for a specific <span class="math notranslate nohighlight">\(i\)</span>, we compute:</p>
<div class="math notranslate nohighlight">
\[\mathrm{RLWE}_{Q,s}(u_{i,n}) := \sum_{k=0}^{N/n-1} x^{nk} \cdot \mathrm{RLWE}_{Q,s}(\tilde u_{i+nk})\]</div>
<p>via <span class="math notranslate nohighlight">\(\texttt{rlwe-multiply-with-poly}\)</span> and <span class="math notranslate nohighlight">\(\texttt{rlwe-add}\)</span>.
Note that <span class="math notranslate nohighlight">\(u_{i,n}\)</span> still contains the desired information, i.e. <span class="math notranslate nohighlight">\(\Delta \cdot u_{i+nk}\)</span> is the coefficient of <span class="math notranslate nohighlight">\(x^{nk}\)</span> inside <span class="math notranslate nohighlight">\(u_{i,n}\)</span>.</p>
<p>The error size of <span class="math notranslate nohighlight">\(\mathrm{RLWE}_{Q,s}(u_{i,n})\)</span> will be bounded by <span class="math notranslate nohighlight">\(N/n \cdot \norm{ e_{\text{br}}}\)</span>, since the monomial multiplication does not increase the error size at all.</p>
</section>
<section id="merging-via-automorphisms">
<h3>Merging via automorphisms<a class="headerlink" href="#merging-via-automorphisms" title="Permalink to this headline">#</a></h3>
<p>The final goal is to obtain <span class="math notranslate nohighlight">\(u_{0,1} = \Delta \cdot u = \Delta \cdot \sum_{i=0}^{N-1} u_i x^i\)</span> by reducing the index <span class="math notranslate nohighlight">\(n\)</span> in <span class="math notranslate nohighlight">\(u_{i,n}\)</span> step-by-step to finally, <span class="math notranslate nohighlight">\(1\)</span>.
We approach it by divide-and-conquer, i.e. always halving <span class="math notranslate nohighlight">\(n\)</span>, thus also the number of ciphertexts per iteration and simultaneously doubling the information contained within each <span class="math notranslate nohighlight">\(u_{i,(\cdot)}\)</span>.
In the end, every coefficient of <span class="math notranslate nohighlight">\(u_{0,1}\)</span> accommodates the matching <span class="math notranslate nohighlight">\(u_i\)</span> as information.</p>
<p>To keep the order of the <span class="math notranslate nohighlight">\(u_i\)</span> sound, the idea is to compute:</p>
<div class="math notranslate nohighlight">
\[\mathrm{RLWE}_{Q,s}(u_{i,n/2}) :\approx \mathrm{RLWE}_{Q,s}(u_{i,n}) + x^{n/2} \cdot \mathrm{RLWE}_{Q,s}(u_{i+n/2,n}),\]</div>
<p>since <span class="math notranslate nohighlight">\(\mathrm{RLWE}_{Q,s}(u_{i+n/2,n})\)</span> contains <span class="math notranslate nohighlight">\(\Delta\cdot u_{i+n/2+nk} \cdot x^{nk}\)</span> for every <span class="math notranslate nohighlight">\(k\)</span>;
and if one multiplies this with <span class="math notranslate nohighlight">\(x^{n/2}\)</span> it fulfills the above definition of <span class="math notranslate nohighlight">\(u_{i,n}\)</span>.
But as a matter of fact, this is now incomplete (indicated by <span class="math notranslate nohighlight">\(\approx\)</span>) and wrong, since the <span class="math notranslate nohighlight">\(\star\)</span>-coefficients are interfering.</p>
<p>To resolve this issue, we make use of the <span class="math notranslate nohighlight">\(N\)</span> automorphisms <span class="math notranslate nohighlight">\(\psi_t: R \rightarrow R, a(x) \mapsto a(x^t)\)</span> for every <span class="math notranslate nohighlight">\(t \perp 2N\)</span>.
They have the fruitful property of, when using the right <span class="math notranslate nohighlight">\(t\)</span>, only permutating some subset of the coefficients.
Hence, if we transform that subset into just being the indices that we want to merge, we will be able to get rid of the undesirable <span class="math notranslate nohighlight">\(\star\)</span>-coefficients at the crucial monomials <span class="math notranslate nohighlight">\(x^{nk}\)</span> and <span class="math notranslate nohighlight">\(x^{nk+n/2}\)</span> for every <span class="math notranslate nohighlight">\(k\)</span>.</p>
<p>Setting <span class="math notranslate nohighlight">\(t := 1+2N/n\)</span> will result in</p>
<div class="math notranslate nohighlight">
\[\psi_t(x^{nk}) = x^{nk+2Nk} = x^{nk}, \qquad \psi_t(x^{nk+n/2}) = x^{nk+n/2+2Nk+N} = - x^{nk+n/2},\]</div>
<p>most importantly preserving the right exponent at the investigated monomials.</p>
<p>Thus if we apply <span class="math notranslate nohighlight">\(\psi_t\)</span> to e.g. <span class="math notranslate nohighlight">\(\mathrm{RLWE}_{Q,s}(u_{i,n})\)</span> we will still retain <span class="math notranslate nohighlight">\(\Delta \cdot u_{i+nk} \cdot x^{nk}\)</span> for every <span class="math notranslate nohighlight">\(k\)</span> as part of the message.
Moreover, in this case, the automorphism empowers us to liberate the other monomial of concern <span class="math notranslate nohighlight">\(x^{nk+n/2}\)</span> from its <span class="math notranslate nohighlight">\(\star\)</span> coefficient.
So by computing <span class="math notranslate nohighlight">\(\mathrm{RLWE}_{Q,s}(u_{i,n}) + \psi_t(\mathrm{RLWE}_{Q,s}(u_{i,n}))\)</span> we eliminate the term <span class="math notranslate nohighlight">\(\star \cdot x^{nk+n/2}\)</span> for every <span class="math notranslate nohighlight">\(k\)</span>.
As we are mirroring this technique with the other RLWE ciphertext, <span class="math notranslate nohighlight">\(\star \cdot x^{nk}\)</span> inside <span class="math notranslate nohighlight">\(x^{n/2} \cdot \mathrm{RLWE}_{Q,s}(u_{i+n/2,n})\)</span> gets deleted for every <span class="math notranslate nohighlight">\(k\)</span>, too.</p>
<p>In total we compute at each iteration for every <span class="math notranslate nohighlight">\(i\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{split}
\mathrm{RLWE}_{Q,s}(2\cdot u_{i,n/2}) &amp;:= \mathrm{RLWE}_{Q,s}(u_{i,n}) + x^{n/2} \cdot \mathrm{RLWE}_{Q,s}(u_{i+n/2,n}) \\ &amp;+ \texttt{eval-auto}_{t=1+\frac{2N}{n}}\left( \mathrm{RLWE}_{Q,s}(u_{i,n}) - x^{n/2} \cdot \mathrm{RLWE}_{Q,s}(u_{i+n/2,n})\right).
\end{split}\end{split}\]</div>
<p>We move on to the next iteration by halving <span class="math notranslate nohighlight">\(n\)</span>.</p>
<p>Notice that we have picked up a factor of two while merging two RLWE ciphertexts.
As we perform <span class="math notranslate nohighlight">\(\log_2(n)\)</span> iterations, we will arrive at a factor <span class="math notranslate nohighlight">\(2^{\log_2(n)}\)</span> which translates to the ciphertext <span class="math notranslate nohighlight">\(\mathrm{RLWE}_{Q,s}(n\cdot u_{i,n}) = \mathrm{RLWE}_{Q,s}(n\cdot \Delta \cdot u)\)</span> after repacking.
This will not cause any further problems, since we can eliminate this factor <span class="math notranslate nohighlight">\(n\)</span> via <span class="math notranslate nohighlight">\(\texttt{rescale}\)</span> at the end of our algorithm, which we have to do anyhow to scale down the bootstrapping error accumulated up to this point.
Further details on this issue will be provided after we have stated the algorithm.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">repack</span><span class="p">(</span><span class="n">rlwe_ciphertexts</span><span class="p">,</span> <span class="n">ciphertext_modulus</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">auxiliary_modulus</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">key_switch_array</span><span class="p">):</span>
    <span class="n">Q</span><span class="p">,</span> <span class="n">rlwe</span> <span class="o">=</span> <span class="n">ciphertext_modulus</span><span class="p">,</span> <span class="n">rlwe_ciphertexts</span> <span class="c1"># actually here Q equals Q*n*p (*T in BFV)</span>
    <span class="n">N</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">rlwe</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;ring_degree&#39;</span><span class="p">),</span> <span class="n">auxiliary_modulus</span>
    <span class="n">u</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
    <span class="c1"># Sparseness merging:</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">rlwe</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">//</span><span class="n">n</span><span class="p">):</span>
            <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">rlwe_add</span><span class="p">(</span><span class="n">rlwe_multiply_with_poly</span><span class="p">(</span><span class="n">rlwe</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">n</span><span class="o">*</span><span class="n">k</span><span class="p">],</span> <span class="n">generate_monomial</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">n</span><span class="o">*</span><span class="n">k</span><span class="p">),</span> <span class="n">Q</span><span class="p">),</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">n</span><span class="p">],</span> <span class="n">Q</span><span class="p">)</span>
    <span class="c1"># Automorphism merging:</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">n</span>
    <span class="k">while</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">x_to_the_k_halfed</span> <span class="o">=</span> <span class="n">generate_monomial</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">k</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="o">//</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">rlwe_add</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">],</span> <span class="n">rlwe_multiply_with_poly</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">k</span><span class="o">//</span><span class="mi">2</span><span class="p">)][</span><span class="n">k</span><span class="p">],</span> <span class="n">x_to_the_k_halfed</span><span class="p">,</span> <span class="n">Q</span><span class="p">),</span> <span class="n">Q</span><span class="p">)</span>
            <span class="n">to_be_evaluated</span> <span class="o">=</span> <span class="n">rlwe_multiply_with_poly</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">k</span><span class="o">//</span><span class="mi">2</span><span class="p">)][</span><span class="n">k</span><span class="p">],</span> <span class="n">x_to_the_k_halfed</span><span class="o">.</span><span class="n">scalar_multiply</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">Q</span><span class="p">)</span>
            <span class="n">to_be_evaluated</span> <span class="o">=</span> <span class="n">rlwe_add</span><span class="p">(</span><span class="n">to_be_evaluated</span><span class="p">,</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">],</span> <span class="n">Q</span><span class="p">)</span>
            <span class="n">u_rotated</span> <span class="o">=</span> <span class="n">eval_auto</span><span class="p">(</span><span class="n">to_be_evaluated</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="p">)</span><span class="o">//</span><span class="n">k</span><span class="p">),</span> <span class="n">Q</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">key_switch_array</span><span class="p">)</span>
            <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">rlwe_add</span><span class="p">(</span><span class="n">u_rotated</span><span class="p">,</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="o">//</span><span class="mi">2</span><span class="p">],</span> <span class="n">Q</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">//=</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="n">rescale</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">Q</span><span class="p">,</span> <span class="n">n</span><span class="o">*</span><span class="n">p</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="analysis-of-texttt-scaled-mod">
<h2>Analysis of <span class="math notranslate nohighlight">\(\texttt{scaled-mod}\)</span><a class="headerlink" href="#analysis-of-texttt-scaled-mod" title="Permalink to this headline">#</a></h2>
<section id="id50">
<h3>Error analysis<a class="headerlink" href="#id50" title="Permalink to this headline">#</a></h3>
<p>The above code still raises some yet unanswered questions, concerning the <span class="math notranslate nohighlight">\(\texttt{rescale}\)</span> procedure at the end and the different moduli used.
Rescaling solves two issues at once:</p>
<ul class="simple">
<li><p>To finally receive a RLWE ciphertext of <span class="math notranslate nohighlight">\(\Delta \cdot u\)</span> and not <span class="math notranslate nohighlight">\(n\cdot\Delta\cdot u\)</span>, we augment the ciphertext modulus from <span class="math notranslate nohighlight">\(Q\)</span> to <span class="math notranslate nohighlight">\(Q\cdot n\)</span> during <span class="math notranslate nohighlight">\(\texttt{scaled-mod}\)</span> and rescale the final result by <span class="math notranslate nohighlight">\(n\)</span>.</p></li>
<li><p>To handle the error growth accumulated during <span class="math notranslate nohighlight">\(\texttt{blind-rotation}\)</span> and <span class="math notranslate nohighlight">\(\texttt{repack}\)</span> (discussion below), we will further introduce another auxiliary modulus <span class="math notranslate nohighlight">\(p\)</span>, i.e. the bootstrapping modulus will be again enlarged.
It should be large enough (but still be minimal for complexity reasons) to let <span class="math notranslate nohighlight">\(\texttt{rescale}\)</span> lessen the error inside our RLWE ciphertext, such that it becomes comparable to an encryption error.
Recall, that <span class="math notranslate nohighlight">\(\texttt{rescale}\)</span> still adds a small error, too.</p></li>
</ul>
<p>Summarized, inside the whole <span class="math notranslate nohighlight">\(\texttt{scaled-mod}\)</span> procedure we work with a ciphertext modulus of <span class="math notranslate nohighlight">\(Q \cdot n \cdot p\)</span>, where <span class="math notranslate nohighlight">\(Q\)</span> is selected according to the underlying scheme of encoding (e.g. BFV).</p>
<p>Below we put together the parts of the <span class="math notranslate nohighlight">\(\texttt{scaled-mod}\)</span> procedure.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">scaled_mod</span><span class="p">(</span><span class="n">rlwe</span><span class="p">,</span> <span class="n">Delta</span><span class="p">,</span> <span class="n">c_boundary</span><span class="p">,</span> <span class="n">ciphertext_modulus</span><span class="p">,</span> <span class="n">auxiliary_modulus</span><span class="p">,</span> <span class="n">blind_rotation_keys</span><span class="p">,</span> <span class="n">rgsw_one</span><span class="p">,</span> <span class="n">key_switch_array</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
    <span class="n">Q</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">brk</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">ciphertext_modulus</span><span class="p">,</span> <span class="n">auxiliary_modulus</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">rlwe</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;ring_degree&#39;</span><span class="p">),</span> <span class="n">c_boundary</span><span class="p">,</span> <span class="n">blind_rotation_keys</span><span class="p">,</span> <span class="mi">1</span>
    <span class="k">while</span><span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="o">*</span><span class="n">c</span> <span class="ow">and</span> <span class="mi">2</span><span class="o">*</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">*=</span> <span class="mi">2</span>
    <span class="n">lwe</span> <span class="o">=</span> <span class="n">extraction</span><span class="p">(</span><span class="n">rlwe</span><span class="p">)</span>
    <span class="n">rotated</span> <span class="o">=</span> <span class="p">[</span><span class="n">blind_rotation</span><span class="p">(</span><span class="n">lwe</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">brk</span><span class="p">,</span> <span class="n">Delta</span><span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">Q</span><span class="o">*</span><span class="n">n</span><span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">rgsw_one</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">repack</span><span class="p">(</span><span class="n">rotated</span><span class="p">,</span> <span class="n">Q</span><span class="o">*</span><span class="n">n</span><span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">key_switch_array</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="proof theorem admonition" id="error-size-after-scaled-mod">
<p class="admonition-title"><span class="caption-number">Theorem 7 </span> (Error size after <span class="math notranslate nohighlight">\(\texttt{scaled-mod}\)</span>)</p>
<section class="theorem-content" id="proof-content">
<p>If a RLWE encryption error has size at most <span class="math notranslate nohighlight">\(E\)</span>, then the error <span class="math notranslate nohighlight">\(e_{\text{sm}}\)</span> after <span class="math notranslate nohighlight">\(\texttt{scaled-mod}\)</span> without rescaling satisfies:</p>
<div class="math notranslate nohighlight">
\[\norm{e_{\text{sm}}} \le 5nN^{5/2}B\log_B(Q)E.\]</div>
</section>
</div><div class="proof admonition" id="proof">
<p>Proof. <a class="reference internal" href="#blind-rotation-error">Lemma 8</a> bounds the size of the error <span class="math notranslate nohighlight">\(e_{\text{br}}\)</span> after the blind rotation step by <span class="math notranslate nohighlight">\(4N^{3/2}B\log_B(Q)E\)</span>.
The error bound from the first part of merging inside <span class="math notranslate nohighlight">\(\texttt{repack}\)</span> was <span class="math notranslate nohighlight">\(N/n \cdot \norm{ e_{\text{br}}}\)</span>.</p>
<p>In the automorphism merging of <span class="math notranslate nohighlight">\(\texttt{repack}\)</span>, per iteration an error <span class="math notranslate nohighlight">\(\tilde e\)</span> passes on with size:</p>
<div class="math notranslate nohighlight">
\[\norm{4 \tilde e + (B/2)\log_B(Q) E \sqrt{N}},\]</div>
<p>since we perform <span class="math notranslate nohighlight">\(4\)</span> RLWE additions and introduce the additional <span class="math notranslate nohighlight">\(\texttt{eval-auto}\)</span> error of size <span class="math notranslate nohighlight">\((B/2)\log_B(Q) E \sqrt{N}\)</span> (see <a class="reference internal" href="#automorphisms-of-r"><span class="std std-ref">Automorphisms of R</span></a>).</p>
<p>In total, we perform <span class="math notranslate nohighlight">\(\log_2(n)\)</span> iterations, making the error before rescaling as large as:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{split}
\norm{e_{\text{sm}}} &amp;= 4^{\log_2(n)}\frac{N}{n}\norm{e_{\text{br}}} + \frac{B}{2}\log_B(Q)E\sqrt{N}\sum_{i=0}^{\log_2(n)-1} 4^i \\
&amp;\le nN\norm{e_{\text{br}}} + \frac{B}{2}\log_B(Q)E\sqrt{N}n^2 \\
&amp;\le 5nN^{5/2}B\log_B(Q)E.
\end{split}\end{split}\]</div>
</div>
</section>
<section id="computational-complexity">
<h3>Computational complexity<a class="headerlink" href="#computational-complexity" title="Permalink to this headline">#</a></h3>
<p>At this point, we can already provide the runtime analysis of the entire <span class="math notranslate nohighlight">\(\texttt{bootstrapping}\)</span> procedure since <span class="math notranslate nohighlight">\(\texttt{scaled-mod}\)</span> and especially the blind rotation is the dominant part of it.
Following the approach in <span id="id51">[<a class="reference internal" href="#id69" title="Andrey Kim, Maxim Deryabin, Jieun Eom, Rakyong Choi, Yongwoo Lee, Whan Ghang, and Donghoon Yoo. General bootstrapping approach for rlwe-based homomorphic encryption. Cryptology ePrint Archive, Paper 2021/691, 2021. https://eprint.iacr.org/2021/691. URL: https://eprint.iacr.org/2021/691.">Kim <em>et al.</em>, 2021</a>]</span>, Section 6.1., we describe a high-level complexity analysis by employing the common <span class="math notranslate nohighlight">\(\mathcal O\)</span> notation as well as founding the analysis on the universal operation of multiplying elements of <span class="math notranslate nohighlight">\(R_Q\)</span>.</p>
<div class="proof theorem admonition" id="complexity-of-scaled-mod">
<p class="admonition-title"><span class="caption-number">Theorem 8 </span> (Complexity of <span class="math notranslate nohighlight">\(\texttt{scaled-mod}\)</span>)</p>
<section class="theorem-content" id="proof-content">
<p>The entire <span class="math notranslate nohighlight">\(\texttt{scaled-mod}\)</span> procedure can be performed with <span class="math notranslate nohighlight">\(\mathcal O(N^2 \cdot \log_B(Q))\)</span> polynomial multiplications in <span class="math notranslate nohighlight">\(R_Q\)</span>.</p>
</section>
</div><p>Before proving the theorem, we remark on the following (by referring to the previous chapters):</p>
<ul class="simple">
<li><p>A RLWE multiplication involves <span class="math notranslate nohighlight">\(\mathcal O(1)\)</span> multiplications in <span class="math notranslate nohighlight">\(R_Q\)</span>.</p></li>
<li><p>A RLWE addition can always be estimated by a RLWE multiplication considering the computation time.</p></li>
<li><p>Consequently, a <span class="math notranslate nohighlight">\(\texttt{rlwe-x-scalar-multiplication}\)</span> <span class="math notranslate nohighlight">\(\odot\)</span> can be performed in <span class="math notranslate nohighlight">\(\mathcal O(\log_B(Q))\)</span> multiplications in <span class="math notranslate nohighlight">\(R_Q\)</span>.</p></li>
<li><p>Similarly, adding/multiplying polynomials with RGSW ciphertexts requires <span class="math notranslate nohighlight">\(\mathcal O(\log_B(Q))\)</span> multiplications in <span class="math notranslate nohighlight">\(R_Q\)</span>, too.</p></li>
<li><p><span class="math notranslate nohighlight">\(\texttt{eval-auto}\)</span> essentially executes <span class="math notranslate nohighlight">\(\odot\)</span> once.</p></li>
</ul>
<div class="proof admonition" id="proof">
<p>Proof. The <a class="reference internal" href="#extraction-of-lwe-ciphertexts"><span class="std std-ref">Step 1: Extraction of LWE ciphertexts</span></a> clearly has a negligible running time compared to the one given in the theorem.</p>
<p>Inside <a class="reference internal" href="#blind-rotation"><span class="std std-ref">Step 2: Blind rotation</span></a>, we perform <span class="math notranslate nohighlight">\(N\)</span> <span class="math notranslate nohighlight">\(\texttt{blind-rotation}\)</span>s.
Each one consists of <span class="math notranslate nohighlight">\(N\)</span> <span class="math notranslate nohighlight">\(\texttt{star-multiplication}\)</span>s and <span class="math notranslate nohighlight">\(N\)</span> computations of <span class="math notranslate nohighlight">\(\RGSW(x^{\alpha_i s_i})\)</span>.
Since <span class="math notranslate nohighlight">\(\circledast\)</span> involves two <span class="math notranslate nohighlight">\(\odot\)</span> operations and <span class="math notranslate nohighlight">\(\RGSW(x^{\alpha_i s_i})\)</span> requires three <span class="math notranslate nohighlight">\(\texttt{rgsw-multiply-with-poly}\)</span>, we conclude a running time of <span class="math notranslate nohighlight">\(\mathcal O(N^2 \cdot \log_B(Q))\)</span> for the <span class="math notranslate nohighlight">\(\texttt{blind-rotation}\)</span>.</p>
<p>The <a class="reference internal" href="#repacking"><span class="std std-ref">Step 3: Repacking</span></a> includes loops of length <span class="math notranslate nohighlight">\(n\)</span> in both merging processes.
Inside each iteration, we perform <span class="math notranslate nohighlight">\(\mathcal O(1)\)</span> RLWE multiplications/additions and one <span class="math notranslate nohighlight">\(\texttt{eval-auto}\)</span>.
Estimating <span class="math notranslate nohighlight">\(n \le N\)</span> and thus estimating the <span class="math notranslate nohighlight">\(\texttt{repack}\)</span> procedure with the <span class="math notranslate nohighlight">\(\texttt{blind-rotation}\)</span> procedure yields the claim.</p>
</div>
</section>
</section>
<section id="adapting-texttt-scaled-mod-to-bfv-encoding">
<h2>Adapting <span class="math notranslate nohighlight">\(\texttt{scaled-mod}\)</span> to BFV encoding<a class="headerlink" href="#adapting-texttt-scaled-mod-to-bfv-encoding" title="Permalink to this headline">#</a></h2>
<p>Finally, we want to clarify, how the upscaling of a message (<span class="math notranslate nohighlight">\(u\)</span> to <span class="math notranslate nohighlight">\(\Delta \cdot u\)</span> during <span class="math notranslate nohighlight">\(\texttt{scaled-mod}\)</span>) allows us to regain a small error for a BFV ciphertext in particular.
We also provide the missing details, e.g. how to select <span class="math notranslate nohighlight">\(c\)</span> in <span class="math notranslate nohighlight">\(\texttt{scaled-mod}\)</span> or why we could assume an errorless encryption at the start of it, along the way.
This section bases upon Section 4.3.1. in <span id="id52">[<a class="reference internal" href="#id69" title="Andrey Kim, Maxim Deryabin, Jieun Eom, Rakyong Choi, Yongwoo Lee, Whan Ghang, and Donghoon Yoo. General bootstrapping approach for rlwe-based homomorphic encryption. Cryptology ePrint Archive, Paper 2021/691, 2021. https://eprint.iacr.org/2021/691. URL: https://eprint.iacr.org/2021/691.">Kim <em>et al.</em>, 2021</a>]</span>.</p>
<section id="removing-the-big-error">
<h3>Removing the big error<a class="headerlink" href="#removing-the-big-error" title="Permalink to this headline">#</a></h3>
<p>The issue of replacing a big error can be best described by treating RLWE ciphertexts in <span class="math notranslate nohighlight">\(R\)</span> (i.e. without a modulus).
Assume we have a BFV encryption of <span class="math notranslate nohighlight">\(m \in R_T\)</span> as:</p>
<div class="math notranslate nohighlight">
\[\mathrm{BFV}_{T,Q,s}(m) := (a,b) := (a, -a\cdot s +e + (Q/T)\cdot m) \in R_Q^2,\]</div>
<p>where <span class="math notranslate nohighlight">\(a \in R_Q\)</span>, <span class="math notranslate nohighlight">\(e\)</span> is an error of size that still leads to a correct decryption, and <span class="math notranslate nohighlight">\(Q\)</span> and <span class="math notranslate nohighlight">\(T\)</span> are powers of two to avoid the rounding.
We conveniently denote the essential decryption query in general (not only for the above ciphertext) as <span class="math notranslate nohighlight">\(\mathrm{ct}(s) := a\cdot s+b \ (\equiv e + (Q/T)\cdot m \in R_Q)\)</span>.</p>
<p>Subtracting the big error is technically easy, but it elicits the problem of needing to scale up a message (which then gets passed on to <span class="math notranslate nohighlight">\(\texttt{scaled-mod}\)</span>).</p>
<p>Starting from our <span class="math notranslate nohighlight">\(\mathrm{ct} := (a,b)\)</span> with the property <span class="math notranslate nohighlight">\(\mathrm{ct}(s) =: e + (Q/T)m + Q \cdot w \in R\)</span> above, let us define (component-wise):</p>
<div class="math notranslate nohighlight">
\[\mathrm{ct'} := T\cdot \mathrm{ct} \mod Q,\qquad \mathrm{ct''} := \mathrm{ct'} \mod Q',\]</div>
<p>where <span class="math notranslate nohighlight">\(Q' := Q/2N\)</span>.
Observe that <span class="math notranslate nohighlight">\(\mathrm{ct'}\)</span> removes the denominator <span class="math notranslate nohighlight">\(T\)</span> and <span class="math notranslate nohighlight">\(\mathrm{ct''}\)</span> enables us to already subtract the big error <span class="math notranslate nohighlight">\(e\)</span> as well as preparing our <span class="math notranslate nohighlight">\(\mathrm{RLWE}_{2N,s}^0(\cdot)\)</span> ciphertext, which <span class="math notranslate nohighlight">\(\texttt{scaled-mod}\)</span> requires.
Removing the big error becomes comprehensible by considering:</p>
<div class="math notranslate nohighlight" id="equation-definition-of-u">
<span class="eqno">(9)<a class="headerlink" href="#equation-definition-of-u" title="Permalink to this equation">#</a></span>\[\mathrm{ct'}(s) = T\cdot e + Q\cdot \underbrace{(m+T\cdot w)}_{=: v} \in R, \qquad \mathrm{ct''}(s) =: T\cdot e + Q' \cdot u \in R.\]</div>
<p>If we take the difference <span class="math notranslate nohighlight">\((\mathrm{ct'} - \mathrm{ct''})(s)\)</span>, we will successfully remove the <span class="math notranslate nohighlight">\(T\cdot e\)</span> term. Furthermore, getting rid of <span class="math notranslate nohighlight">\(Q'\)</span>, which divides <span class="math notranslate nohighlight">\(Q\)</span> anyway, we arrive at:</p>
<div class="math notranslate nohighlight">
\[\mathrm{ct}_{\text{prep}}(s) := \left(\frac{\mathrm{ct'}-\mathrm{ct''}}{Q'}\right)(s) = -u + 2N \cdot v \in R.\]</div>
<p>This is precisely the error-free encryption of <span class="math notranslate nohighlight">\(-u\)</span> within the modulus <span class="math notranslate nohighlight">\(2N\)</span> that <span class="math notranslate nohighlight">\(\texttt{scaled-mod}\)</span> takes as input.
The above also answers the question of why we can assume an errorless RLWE encryption:
Since we are not explicitly encrypting with an error equal to zero but only using a transformation from a RLWE ciphertext to an error-free encryption, we still can rely on the RLWE security described in <a class="reference internal" href="#security"><span class="std std-ref">Security</span></a>.</p>
</section>
<section id="restoring-m-after-texttt-scaled-mod">
<h3>Restoring <span class="math notranslate nohighlight">\(m\)</span> after <span class="math notranslate nohighlight">\(\texttt{scaled-mod}\)</span><a class="headerlink" href="#restoring-m-after-texttt-scaled-mod" title="Permalink to this headline">#</a></h3>
<p>Because we are using <span class="math notranslate nohighlight">\(\mathrm{ct'} \in R_Q^2\)</span> involving the sophisticated <span class="math notranslate nohighlight">\(0 \equiv Q \cdot m \mod Q\)</span> and the obstructive <span class="math notranslate nohighlight">\(Q\cdot T \cdot w\)</span> inside <span class="math notranslate nohighlight">\(\mathrm{ct'}(s)\)</span>, we clearly have to expand the modulus from <span class="math notranslate nohighlight">\(Q\)</span> to <span class="math notranslate nohighlight">\(Q\cdot T\)</span> during <span class="math notranslate nohighlight">\(\texttt{scaled-mod}\)</span>, to have any chance of piecing everything together correctly afterwards.
Notice that now the bootstrapping modulus is <span class="math notranslate nohighlight">\(Q\cdot T \cdot n \cdot p\)</span> in total.</p>
<p>Consider the following three ciphertexts in <span class="math notranslate nohighlight">\(R_{QT}\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{split}
(T \cdot \mathrm{ct})(s) = T \cdot e + Q \cdot m, \qquad
 \mathrm{ct}''(s) &amp;= T\cdot e + Q' \cdot u, \\
\texttt{scaled-mod}(\mathrm{ct}_{\mathrm{prep}}, \ \Delta = -Q',\ \text{modulus} = Q\cdot T)(s) &amp;= Q'\cdot u + e_{\text{sm}}.
\end{split}\end{split}\]</div>
<p>By cleverly adding/subtracting them together, we only end up with the desired <span class="math notranslate nohighlight">\(Q\cdot m \in R_{QT}\)</span> plus the already rescaled error <span class="math notranslate nohighlight">\(e_{\text{sm}}\)</span> from <span class="math notranslate nohighlight">\(\texttt{scaled-mod}\)</span>.</p>
<p>The last step involves <span class="math notranslate nohighlight">\(\texttt{rescale}\)</span> once again, to scale down the modulus from <span class="math notranslate nohighlight">\(Q\cdot T\)</span> to <span class="math notranslate nohighlight">\(Q\)</span> as well as the message from <span class="math notranslate nohighlight">\(Q\cdot m\)</span> to BFV-fitting <span class="math notranslate nohighlight">\((Q/T)\cdot m\)</span>.
As described in <a class="reference internal" href="#rescaling"><span class="std std-ref">Rescaling</span></a>, we will also downscale <span class="math notranslate nohighlight">\(e_{sm}\)</span> by <span class="math notranslate nohighlight">\(T\)</span> and only add a small <span class="math notranslate nohighlight">\(\texttt{rescale}\)</span> error with <span class="math notranslate nohighlight">\(\norm{e_{\text{rs}}} \le \sqrt{N}/2\)</span> to the final result.
If <span class="math notranslate nohighlight">\(\mathrm{ct}_{\text{sm}}\)</span> denotes the ciphertext after <span class="math notranslate nohighlight">\(\texttt{scaled-mod}\)</span>, we set the ciphertext <span class="math notranslate nohighlight">\(\mathrm{ct}_{\text{boot}}\)</span> after <span class="math notranslate nohighlight">\(\texttt{bootstrapping}\)</span> to:</p>
<div class="math notranslate nohighlight">
\[\mathrm{ct}_{\text{boot}} := \texttt{rescale}_{Q\cdot T \longrightarrow Q} \left(\mathrm{ct}_{\text{sm}} - \mathrm{ct''} + T \cdot \mathrm{ct} \right) \in R_Q.\]</div>
<p><span class="math notranslate nohighlight">\(\texttt{bootstrapping}\)</span> returns <span class="math notranslate nohighlight">\(\mathrm{ct}_{\text{boot}}(s) = \round{e_{\text{sm}}/T} + e_{\text{rs}} + (Q/T)\cdot m\)</span>.</p>
<p>We are left to determine <span class="math notranslate nohighlight">\(c\)</span>, which occurs during <span class="math notranslate nohighlight">\(\texttt{blind-rotation}\)</span> (definition of <span class="math notranslate nohighlight">\(f\)</span>) and which satisfies <span class="math notranslate nohighlight">\(\norm u &lt; c\)</span>.
Consider <a class="reference internal" href="#equation-definition-of-u">(9)</a>, i.e. the implicit definition of <span class="math notranslate nohighlight">\(u\)</span>.
It follows that</p>
<div class="math notranslate nohighlight" id="equation-norm-u">
<span class="eqno">(10)<a class="headerlink" href="#equation-norm-u" title="Permalink to this equation">#</a></span>\[\norm u = \frac{1}{Q'} \norm{[T \cdot a]_{Q'} \cdot s + [T \cdot b]_{Q'} - T \cdot e} \le \frac{C\sqrt{N}+1}{2} + \frac{\gamma}{Q'} &lt; N/2,\]</div>
<p>where <span class="math notranslate nohighlight">\(\norm{T \cdot e} \le \gamma\)</span> and the <a class="reference internal" href="#conclusion-on-delta-r"><span class="std std-ref">Conclusion on the expansion factor</span></a> with <span class="math notranslate nohighlight">\(\delta_R = C\cdot\sqrt{N}\)</span> were used.</p>
<p>Since <span class="math notranslate nohighlight">\(\norm u &lt; N/2\)</span> is required during <span class="math notranslate nohighlight">\(\texttt{scaled-mod}\)</span> (its coefficients serve as an exponent of a ring element), <span class="math notranslate nohighlight">\(\gamma\)</span> can be selected such that <span class="math notranslate nohighlight">\(T \norm{e} &lt; \gamma &lt; (Q/4N)(N-C\sqrt{N}-1)\)</span> holds as an easy calculation shows.
Note that this also implies a condition on the size of the error <span class="math notranslate nohighlight">\(e\)</span> before entering the bootstrapping procedure.</p>
<p>In total we define <span class="math notranslate nohighlight">\(c := \lfloor (C\sqrt{N}+1)/2 + \gamma/Q' \rfloor\)</span> obtained from <a class="reference internal" href="#equation-norm-u">(10)</a>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">bootstrapping</span><span class="p">(</span><span class="n">ciphertext</span><span class="p">,</span> <span class="n">ciphertext_modulus</span><span class="p">,</span> <span class="n">plaintext_modulus</span><span class="p">,</span> <span class="n">auxiliary_modulus</span><span class="p">,</span> <span class="n">blind_rotation_keys</span><span class="p">,</span> <span class="n">rgsw_one</span><span class="p">,</span> <span class="n">key_switch_array</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
    <span class="n">ct</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">brk</span> <span class="o">=</span> <span class="n">ciphertext</span><span class="p">,</span> <span class="n">ciphertext_modulus</span><span class="p">,</span> <span class="n">plaintext_modulus</span><span class="p">,</span> <span class="n">auxiliary_modulus</span><span class="p">,</span> <span class="n">blind_rotation_keys</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">ciphertext</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;ring_degree&#39;</span><span class="p">)</span>
    <span class="c1"># Preprocessing:</span>
    <span class="n">ct_x</span> <span class="o">=</span> <span class="p">[</span><span class="n">ct</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">scalar_multiply</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">mod_small</span><span class="p">(</span><span class="n">Q</span><span class="p">),</span> <span class="n">ct</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">scalar_multiply</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">mod_small</span><span class="p">(</span><span class="n">Q</span><span class="p">)]</span>
    <span class="n">Q_x</span> <span class="o">=</span> <span class="n">Q</span> <span class="o">//</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="p">)</span>
    <span class="n">ct_xx</span> <span class="o">=</span> <span class="p">[</span><span class="n">ct_x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mod_small</span><span class="p">(</span><span class="n">Q_x</span><span class="p">),</span> <span class="n">ct_x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">mod_small</span><span class="p">(</span><span class="n">Q_x</span><span class="p">)]</span>
    <span class="n">ct_prep1</span> <span class="o">=</span> <span class="n">ct_x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">ct_xx</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">scalar_integer_divide</span><span class="p">(</span><span class="n">Q_x</span><span class="p">)</span><span class="o">.</span><span class="n">mod_small</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="p">)</span>
    <span class="n">ct_prep2</span> <span class="o">=</span> <span class="n">ct_x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">ct_xx</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">scalar_integer_divide</span><span class="p">(</span><span class="n">Q_x</span><span class="p">)</span><span class="o">.</span><span class="n">mod_small</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="p">)</span>
    <span class="c1"># scaled-mod procedure:</span>
    <span class="n">gamma</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="n">Q</span><span class="o">*</span><span class="n">floor</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="n">sqrt</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">//</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">N</span><span class="p">))</span>
    <span class="n">c</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">+</span> <span class="n">gamma</span><span class="o">/</span><span class="n">Q_x</span><span class="p">),</span> <span class="n">floor</span><span class="p">(</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">ct_sm</span> <span class="o">=</span> <span class="n">scaled_mod</span><span class="p">([</span><span class="n">ct_prep1</span><span class="p">,</span> <span class="n">ct_prep2</span><span class="p">],</span> <span class="o">-</span><span class="n">Q_x</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">Q</span><span class="o">*</span><span class="n">T</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">brk</span><span class="p">,</span> <span class="n">rgsw_one</span><span class="p">,</span> <span class="n">key_switch_array</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
    <span class="c1"># Restoring:</span>
    <span class="n">t_ct</span> <span class="o">=</span> <span class="p">[</span><span class="n">ct</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">scalar_multiply</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">Q</span><span class="o">*</span><span class="n">T</span><span class="p">),</span> <span class="n">ct</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">scalar_multiply</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">Q</span><span class="o">*</span><span class="n">T</span><span class="p">)]</span>
    <span class="n">minus_ct_xx</span> <span class="o">=</span> <span class="p">[</span><span class="n">ct_xx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">scalar_multiply</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">ct_xx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">scalar_multiply</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
    <span class="n">ct_xxx</span> <span class="o">=</span> <span class="n">rlwe_add</span><span class="p">(</span><span class="n">ct_sm</span><span class="p">,</span> <span class="n">rlwe_add</span><span class="p">(</span><span class="n">t_ct</span><span class="p">,</span> <span class="n">minus_ct_xx</span><span class="p">,</span> <span class="n">Q</span><span class="o">*</span><span class="n">T</span><span class="p">),</span> <span class="n">Q</span><span class="o">*</span><span class="n">T</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rescale</span><span class="p">(</span><span class="n">ct_xxx</span><span class="p">,</span> <span class="n">Q</span><span class="o">*</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Remark on the code:
Especially when working with a small <span class="math notranslate nohighlight">\(N\)</span>, we have to ensure that <span class="math notranslate nohighlight">\(c &lt; N/2\)</span> by providing a very small <span class="math notranslate nohighlight">\(\gamma\)</span>, since also <span class="math notranslate nohighlight">\(C\)</span> inside <span class="math notranslate nohighlight">\(\delta_R\)</span> may be unusually large.
In the worst case, <a class="reference internal" href="#equation-norm-u">(10)</a> does not hold, because <span class="math notranslate nohighlight">\(C\sqrt{N}\)</span> would be replaced by <span class="math notranslate nohighlight">\(N\)</span> instead.
For large <span class="math notranslate nohighlight">\(N\)</span> this only happens with negligible probability, as pointed out in <a class="reference internal" href="#bound-for-multiplying-two-ring-elements"><span class="std std-ref">Bound for multiplying two R-elements</span></a>.</p>
</section>
</section>
<section id="parameters-for-bootstrapping">
<span id="id53"></span><h2>Parameters for bootstrapping<a class="headerlink" href="#parameters-for-bootstrapping" title="Permalink to this headline">#</a></h2>
<p>Choosing the optimal parameters <span class="math notranslate nohighlight">\(\{N, T, Q, p, B\}\)</span> is very important since we already have shown that they can heavily influence the computation time.</p>
<section id="message-length-n">
<h3>Message length <span class="math notranslate nohighlight">\(N\)</span><a class="headerlink" href="#message-length-n" title="Permalink to this headline">#</a></h3>
<p>The main security parameter <span class="math notranslate nohighlight">\(N\)</span> defines the number of coefficients of a polynomial.
Clearly, a small <span class="math notranslate nohighlight">\(N\)</span> as selected in our example Python demonstration cannot possibly satisfy any modern security measures.
In the Homomorphic Encryption Security Standard (see <span id="id54">[<a class="reference internal" href="#id65" title="Martin Albrecht, Melissa Chase, Hao Chen, Jintai Ding, Shafi Goldwasser, Sergey Gorbunov, Shai Halevi, Jeffrey Hoffstein, Kim Laine, Kristin Lauter, Satya Lokam, Daniele Micciancio, Dustin Moody, Travis Morrison, Amit Sahai, and Vinod Vaikuntanathan. Homomorphic encryption security standard. Technical Report, HomomorphicEncryption.org, Toronto, Canada, November 2018.">Albrecht <em>et al.</em>, 2018</a>]</span>) a security analysis for <span class="math notranslate nohighlight">\(N\)</span> ranging in <span class="math notranslate nohighlight">\(2^{10},\dots,2^{15}\)</span> is provided.</p>
<p>Note that multiplying polynomials of degree <span class="math notranslate nohighlight">\(N-1\)</span>, which the Karatsuba algorithm performs in roughly <span class="math notranslate nohighlight">\(N^{\log_2(3)}\)</span> integer multiplications, is the basic operation of our scheme.
Moreover, <span class="math notranslate nohighlight">\(N\)</span> has an even greater impact on the runtime, because, inter alia, we perform <span class="math notranslate nohighlight">\(N\)</span> <span class="math notranslate nohighlight">\(\texttt{blind-rotation}\)</span>s.
In total, a larger <span class="math notranslate nohighlight">\(N\)</span> yields a significantly longer running time:
In practice we observed that, when we double <span class="math notranslate nohighlight">\(N\)</span>, we can expect a running time of <span class="math notranslate nohighlight">\(\approx\)</span> 10-12 times the original one.
In theory, if we combine <a class="reference internal" href="#complexity-of-scaled-mod">Theorem 8</a> with Karatsuba, we have <span class="math notranslate nohighlight">\((2N)^{2+\log_2(3)} = 12N\)</span>, too.</p>
<p>Naturally, this also points out why fully homomorphic encryption in general (still) lacks viability in modern applications.</p>
</section>
<section id="plaintext-modulus-t">
<h3>Plaintext modulus <span class="math notranslate nohighlight">\(T\)</span><a class="headerlink" href="#plaintext-modulus-t" title="Permalink to this headline">#</a></h3>
<p>The encoding parameter <span class="math notranslate nohighlight">\(T\)</span> allows us to encode <span class="math notranslate nohighlight">\(T^N\)</span> distinct integers in one (BFV) ciphertext.
As we have seen during the BFV multiplication algorithm, choosing a larger <span class="math notranslate nohighlight">\(T\)</span> also demands a larger <span class="math notranslate nohighlight">\(Q\)</span> (see <a class="reference internal" href="#error-after-BFV-multiplication">Theorem 6</a>) for the same amount of possible operations, which leads to longer computation times.
Additionally, <span class="math notranslate nohighlight">\(T\)</span> also scales the bootstrapping modulus quasi-linearly.
For demonstration purposes and simplicity we set <span class="math notranslate nohighlight">\(T = 2\)</span>.</p>
</section>
<section id="ciphertext-modulus-q">
<span id="id55"></span><h3>Ciphertext modulus <span class="math notranslate nohighlight">\(Q\)</span><a class="headerlink" href="#ciphertext-modulus-q" title="Permalink to this headline">#</a></h3>
<p>By combining <a class="reference internal" href="#correct-BFV-decryption">Lemma 4</a> and <a class="reference internal" href="#error-after-BFV-multiplication">Theorem 6</a>, we observe that the BFV scheme can evaluate circuits of multiplicative depth <span class="math notranslate nohighlight">\(k\)</span> if (roughly):</p>
<div class="math notranslate nohighlight">
\[(2TN)^k &lt; \frac{Q}{2N} \iff k &lt; \frac{\log_2(Q)-\log_2(2T)}{\log_2(2TN)}.\]</div>
<p>This shows that we need to square <span class="math notranslate nohighlight">\(Q\)</span> if we want to double the multiplicative depth <span class="math notranslate nohighlight">\(k\)</span>.
In this case, although we will only need half of the <span class="math notranslate nohighlight">\(\texttt{bootstrapping}\)</span> procedures, <a class="reference internal" href="#complexity-of-scaled-mod">Theorem 8</a> shows that the bootstrapping time will double as well inside the <span class="math notranslate nohighlight">\(\mathcal O\)</span>-notation.
Furthermore, a multiplication in <span class="math notranslate nohighlight">\(R_Q\)</span> will be costlier as the following computation points out.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">N</span><span class="p">,</span> <span class="n">Q</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">50</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">):</span>
    <span class="n">testing_poly</span> <span class="o">=</span> <span class="n">generate_uniform_distribution</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="o">-</span><span class="n">Q</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="n">Q</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">timer</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="o">*</span><span class="n">speed</span><span class="p">):</span>
        <span class="n">testing_poly</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">testing_poly</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Multiplying in R_Q with Q = </span><span class="si">{</span><span class="n">two_power</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span><span class="si">}</span><span class="s2"> and N = </span><span class="si">{</span><span class="n">two_power</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="si">}</span><span class="s2"> in </span><span class="si">{</span><span class="p">(</span><span class="n">timedelta</span><span class="p">(</span><span class="n">seconds</span> <span class="o">=</span> <span class="n">timer</span><span class="p">()</span><span class="o">-</span><span class="n">start</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="mi">5</span><span class="o">*</span><span class="n">speed</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">Q</span> <span class="o">=</span> <span class="n">Q</span> <span class="o">**</span> <span class="mi">2</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Multiplying in R_Q with Q = 2^50 and N = 2^10 in 0:00:00.063411
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Multiplying in R_Q with Q = 2^100 and N = 2^10 in 0:00:00.065280
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Multiplying in R_Q with Q = 2^200 and N = 2^10 in 0:00:00.078943
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Multiplying in R_Q with Q = 2^400 and N = 2^10 in 0:00:00.102636
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Multiplying in R_Q with Q = 2^800 and N = 2^10 in 0:00:00.179852
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Multiplying in R_Q with Q = 2^1600 and N = 2^10 in 0:00:00.466436
</pre></div>
</div>
</div>
</div>
<p>We observe that the computation time at least doubles during doubling a large <span class="math notranslate nohighlight">\(Q\)</span>.
Note that, for comparably small <span class="math notranslate nohighlight">\(Q\)</span>, the running times are more or less equal, since in these cases they greatly depend on <span class="math notranslate nohighlight">\(N\)</span> exclusively.</p>
<p>We conclude that there is a limit, for which the augmentation of the ciphertext modulus <span class="math notranslate nohighlight">\(Q\)</span> is viable.</p>
</section>
<section id="auxiliary-modulus-p">
<h3>Auxiliary modulus <span class="math notranslate nohighlight">\(p\)</span><a class="headerlink" href="#auxiliary-modulus-p" title="Permalink to this headline">#</a></h3>
<p>We need an auxiliary modulus <span class="math notranslate nohighlight">\(p\)</span> to scale down the <span class="math notranslate nohighlight">\(\texttt{scaled-mod}\)</span> error during its final rescaling step.
Consider <a class="reference internal" href="#error-size-after-scaled-mod">Theorem 7</a>, which gives rise to the size of <span class="math notranslate nohighlight">\(p\)</span>:</p>
<div class="math notranslate nohighlight">
\[p = 5 n N^{5/2} B \log_B(QTnp),\]</div>
<p>since the error size after <span class="math notranslate nohighlight">\(\texttt{scaled-mod}\)</span> should be comparable to the RLWE encryption error size <span class="math notranslate nohighlight">\(E\)</span> in the theorem.
We simplify the above with the estimation <span class="math notranslate nohighlight">\(\log_B(p) &lt; \log_B(QTn)\)</span> to <span class="math notranslate nohighlight">\(p := 10 n N^{5/2} B\log_B(QTn)\)</span>.</p>
</section>
<section id="decomposition-parameter-b">
<h3>Decomposition parameter <span class="math notranslate nohighlight">\(B\)</span><a class="headerlink" href="#decomposition-parameter-b" title="Permalink to this headline">#</a></h3>
<p>The choice of <span class="math notranslate nohighlight">\(B\)</span> is somewhat subtle, too, since <span class="math notranslate nohighlight">\(B\)</span> depends on <span class="math notranslate nohighlight">\(p\)</span> and vice versa.
In <a class="reference internal" href="#complexity-of-scaled-mod">Theorem 8</a> we have shown that squaring <span class="math notranslate nohighlight">\(B\)</span> halves the time required for <span class="math notranslate nohighlight">\(\texttt{bootstrapping}\)</span>.
Aside from that, <span class="math notranslate nohighlight">\(B\)</span> also occurs during the error discussion and its increase generates larger error sizes.
Thus, for correct decryption (see <a class="reference internal" href="#correct-BFV-decryption">Lemma 4</a>), the error in <a class="reference internal" href="#error-size-after-scaled-mod">Theorem 7</a> must not be greater than <span class="math notranslate nohighlight">\(Qnp/2\)</span>.
Since <span class="math notranslate nohighlight">\(p\)</span> already assures the latter, we have plenty of liberty in choosing <span class="math notranslate nohighlight">\(B\)</span>.
In fact, it technically could be even larger than <span class="math notranslate nohighlight">\(Q\)</span> itself to boost the runtime (this effect has a limit, see <a class="reference internal" href="#ciphertext-modulus-q"><span class="std std-ref">Ciphertext modulus Q</span></a>).
We will examine this computationally (see <a class="reference internal" href="#runtime-analysis"><span class="std std-ref">Runtime observations</span></a>).</p>
</section>
<section id="wrapper-for-parameters">
<h3>Wrapper for parameters<a class="headerlink" href="#wrapper-for-parameters" title="Permalink to this headline">#</a></h3>
<p>Below we define an auxiliary function, which computes all necessary bootstrapping parameters <span class="math notranslate nohighlight">\(\{N,T,Q,B,n,p,c,QTnp\}\)</span>, the <span class="math notranslate nohighlight">\(\texttt{key-switch}\)</span> array, and the <span class="math notranslate nohighlight">\(\texttt{blind-rotation-keys}\)</span>.
Because knowledge of <span class="math notranslate nohighlight">\(s\)</span> is required, these precomputations need to be run by a secret key holder.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">bootstrapping_parameters</span><span class="p">(</span><span class="n">secret_key</span><span class="p">,</span> <span class="n">plaintext_modulus</span><span class="p">,</span> <span class="n">ciphertext_modulus</span><span class="p">,</span> <span class="n">standard_deviation</span><span class="p">):</span>
    <span class="n">N</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">secret_key</span><span class="p">,</span> <span class="s1">&#39;ring_degree&#39;</span><span class="p">),</span> <span class="n">ciphertext_modulus</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">Q</span>
    <span class="n">gamma</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(((</span><span class="n">Q</span><span class="o">*</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="n">sqrt</span><span class="p">(</span><span class="n">N</span><span class="p">)))</span><span class="o">/</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">N</span><span class="p">)))</span>
    <span class="n">c</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">+</span> <span class="n">gamma</span><span class="o">/</span><span class="p">(</span><span class="n">Q</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="p">))),</span> <span class="n">floor</span><span class="p">(</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">while</span><span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="o">*</span><span class="n">c</span> <span class="ow">and</span> <span class="mi">2</span><span class="o">*</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">*=</span> <span class="mi">2</span>
    <span class="k">while</span><span class="p">(</span><span class="n">p</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="o">*</span><span class="n">n</span><span class="o">*</span><span class="p">(</span><span class="n">N</span><span class="o">**</span><span class="p">(</span><span class="mi">5</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span><span class="o">*</span><span class="n">B</span><span class="o">*</span><span class="n">log</span><span class="p">(</span><span class="n">Q</span><span class="o">*</span><span class="n">T</span><span class="o">*</span><span class="n">n</span><span class="p">,</span><span class="n">B</span><span class="p">)):</span>
        <span class="n">p</span> <span class="o">*=</span> <span class="mi">2</span>
    <span class="n">boot_modulus</span> <span class="o">=</span> <span class="n">Q</span><span class="o">*</span><span class="n">T</span><span class="o">*</span><span class="n">n</span><span class="o">*</span><span class="n">p</span>
    <span class="n">brk</span> <span class="o">=</span> <span class="n">blind_rotation_keys</span><span class="p">(</span><span class="n">boot_modulus</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">standard_deviation</span><span class="p">,</span> <span class="n">secret_key</span><span class="p">)</span>
    <span class="n">rgsw_one</span> <span class="o">=</span> <span class="n">get_trivial_rgsw_of_one</span><span class="p">(</span><span class="n">boot_modulus</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
    <span class="n">key_switch</span> <span class="o">=</span> <span class="n">key_switch_for_eval_auto</span><span class="p">(</span><span class="n">secret_key</span><span class="p">,</span> <span class="n">boot_modulus</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">standard_deviation</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">boot_modulus</span><span class="p">,</span> <span class="n">brk</span><span class="p">,</span> <span class="n">rgsw_one</span><span class="p">,</span> <span class="n">key_switch</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>As the parameters are public information, now any party, which wants to bootstrap a ciphertext, can use the parameter array and the following <span class="math notranslate nohighlight">\(\texttt{bootstrapping-wrapper}\)</span> to perform the refreshing of the error within the ciphertext.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">bootstrapping_wrapper</span><span class="p">(</span><span class="n">ciphertext</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">timer</span><span class="p">()</span>
    <span class="n">N</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">boot_modulus</span><span class="p">,</span> <span class="n">brk</span><span class="p">,</span> <span class="n">rgsw_one</span><span class="p">,</span> <span class="n">key_switch</span> <span class="o">=</span> <span class="n">parameters</span>
    <span class="n">boot</span> <span class="o">=</span> <span class="n">bootstrapping</span><span class="p">(</span><span class="n">ciphertext</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">brk</span><span class="p">,</span> <span class="n">rgsw_one</span><span class="p">,</span> <span class="n">key_switch</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">info</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Time taken for bootstrapping: </span><span class="si">{</span><span class="n">timedelta</span><span class="p">(</span><span class="n">seconds</span> <span class="o">=</span> <span class="n">timer</span><span class="p">()</span><span class="o">-</span><span class="n">start</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Bootstrapping parameters: Modulus = </span><span class="si">{</span><span class="n">two_power</span><span class="p">(</span><span class="n">Q</span><span class="o">*</span><span class="n">n</span><span class="o">*</span><span class="n">p</span><span class="o">*</span><span class="n">T</span><span class="p">)</span><span class="si">}</span><span class="s2">, B = </span><span class="si">{</span><span class="n">two_power</span><span class="p">(</span><span class="n">B</span><span class="p">)</span><span class="si">}</span><span class="s2">, N = </span><span class="si">{</span><span class="n">two_power</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">boot</span> 
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="testing-texttt-bootstrapping">
<h2>Testing <span class="math notranslate nohighlight">\(\texttt{bootstrapping}\)</span><a class="headerlink" href="#testing-texttt-bootstrapping" title="Permalink to this headline">#</a></h2>
<section id="correctness">
<h3>Correctness<a class="headerlink" href="#correctness" title="Permalink to this headline">#</a></h3>
<p>As a proof of concept, we want to test our bootstrapping algorithm by taking a random message and encrypting it, then measuring the error size after having added an error of a certain size.
For that instance, we print the error after bootstrapping, which should ideally be about the same size as a regular encrypting error.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">N</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Q</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">100</span>
<span class="n">SK</span><span class="p">,</span> <span class="n">PK</span> <span class="o">=</span> <span class="n">keygen</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">STD</span><span class="p">)</span>
<span class="n">M</span> <span class="o">=</span> <span class="n">generate_uniform_distribution</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">encryption</span> <span class="o">=</span> <span class="n">encrypt</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">STD</span><span class="p">,</span> <span class="n">PK</span><span class="p">)</span>
<span class="n">unnecessary_error</span> <span class="o">=</span> <span class="n">generate_uniform_distribution</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="o">-</span><span class="n">Q</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="p">),</span> <span class="n">Q</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Adding an error of size: </span><span class="si">{</span><span class="n">two_power</span><span class="p">(</span><span class="n">unnecessary_error</span><span class="o">.</span><span class="n">norm</span><span class="p">())</span><span class="si">}</span><span class="s2"> within the ciphertext modulus: </span><span class="si">{</span><span class="n">two_power</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span><span class="si">}</span><span class="s2">...&quot;</span><span class="p">)</span> 
<span class="n">noisy_ciphertext</span> <span class="o">=</span> <span class="p">[</span><span class="n">encryption</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">encryption</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">unnecessary_error</span><span class="p">,</span> <span class="n">Q</span><span class="p">)]</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;...to the encryption of the message: </span><span class="si">{</span><span class="n">M</span><span class="si">}</span><span class="s2"> and refreshing the obtained noisy ciphertext by bootstrapping...&quot;</span><span class="p">)</span>
<span class="n">start</span> <span class="o">=</span> <span class="n">timer</span><span class="p">()</span>
<span class="n">parameters</span> <span class="o">=</span> <span class="n">bootstrapping_parameters</span><span class="p">(</span><span class="n">SK</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">STD</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Time taken for the precomputation: </span><span class="si">{</span><span class="n">timedelta</span><span class="p">(</span><span class="n">seconds</span> <span class="o">=</span> <span class="n">timer</span><span class="p">()</span><span class="o">-</span><span class="n">start</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">refreshed_ciphertext</span> <span class="o">=</span> <span class="n">bootstrapping_wrapper</span><span class="p">(</span><span class="n">noisy_ciphertext</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="n">refreshed_decryption</span> <span class="o">=</span> <span class="n">decrypt</span><span class="p">(</span><span class="n">refreshed_ciphertext</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">SK</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Decryption of refreshed ciphertext after bootstrapping: </span><span class="si">{</span><span class="n">refreshed_decryption</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Still correct? </span><span class="si">{</span><span class="n">M</span><span class="o">.</span><span class="n">is_equal_to</span><span class="p">(</span><span class="n">refreshed_decryption</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">refreshed_error</span> <span class="o">=</span> <span class="n">refreshed_ciphertext</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">SK</span><span class="p">)</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">refreshed_ciphertext</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">Q</span><span class="p">)</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">scalar_multiply</span><span class="p">(</span><span class="n">Q</span><span class="o">//</span><span class="n">T</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error size after bootstrapping: </span><span class="si">{</span><span class="n">refreshed_error</span><span class="o">.</span><span class="n">mod_small</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Adding an error of size: 2^94 within the ciphertext modulus: 2^100...
...to the encryption of the message: x^14 + x^11 + x^7 + x^6 + x^2 + x + 1 and refreshing the obtained noisy ciphertext by bootstrapping...
Time taken for the precomputation: 0:00:00.028010
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Time taken for bootstrapping: 0:00:00.741090
Bootstrapping parameters: Modulus = 2^223, B = 2^100, N = 2^4
Decryption of refreshed ciphertext after bootstrapping: x^14 + x^11 + x^7 + x^6 + x^2 + x + 1
Still correct? True
Error size after bootstrapping: 1
</pre></div>
</div>
</div>
</div>
</section>
<section id="runtime-observations">
<span id="runtime-analysis"></span><h3>Runtime observations<a class="headerlink" href="#runtime-observations" title="Permalink to this headline">#</a></h3>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">runtime</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">runs</span><span class="p">):</span>
    <span class="n">SK</span><span class="p">,</span> <span class="n">PK</span> <span class="o">=</span> <span class="n">keygen</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">CT</span> <span class="o">=</span> <span class="p">[</span><span class="n">generate_uniform_distribution</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="o">-</span><span class="n">Q</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="n">Q</span><span class="o">//</span><span class="mi">2</span><span class="p">)]</span><span class="o">*</span><span class="mi">2</span> 
    <span class="n">parameters</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">bootstrapping_parameters</span><span class="p">(</span><span class="n">SK</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">parameters</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">N</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">B</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">timer</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">runs</span><span class="p">):</span>
        <span class="n">bootstrapping_wrapper</span><span class="p">(</span><span class="n">CT</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">parameters</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Running with N = </span><span class="si">{</span><span class="n">two_power</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="si">}</span><span class="s2">, Q = </span><span class="si">{</span><span class="n">two_power</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span><span class="si">}</span><span class="s2">, B = </span><span class="si">{</span><span class="n">two_power</span><span class="p">(</span><span class="n">B</span><span class="p">)</span><span class="si">}</span><span class="s2"> and taking </span><span class="si">{</span><span class="p">(</span><span class="n">timer</span><span class="p">()</span><span class="o">-</span><span class="n">start</span><span class="p">)</span><span class="o">/</span><span class="n">runs</span><span class="si">}</span><span class="s2"> seconds.&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>With the <span class="math notranslate nohighlight">\(\texttt{runtime}\)</span> procedure, we want to confirm some observations from <a class="reference internal" href="#parameters-for-bootstrapping"><span class="std std-ref">Parameters for bootstrapping</span></a> computationally:</p>
<ul class="simple">
<li><p>Selecting <span class="math notranslate nohighlight">\(B\)</span> larger than <span class="math notranslate nohighlight">\(Q\)</span> yields a faster running time:</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">runtime</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">100</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="o">*</span><span class="n">speed</span><span class="p">)</span>
<span class="n">runtime</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">100</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">200</span><span class="p">,</span> <span class="mi">100</span><span class="o">*</span><span class="n">speed</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Running with N = 2^2, Q = 2^100, B = 2^100 and taking 0.008050216669999983 seconds.
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Running with N = 2^2, Q = 2^100, B = 2^200 and taking 0.0077115658399999985 seconds.
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Doubling <span class="math notranslate nohighlight">\(N\)</span> multiplies the running time by about a factor 10-12:</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">runtime</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">50</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">50</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">speed</span><span class="p">)</span>
<span class="n">runtime</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">50</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">50</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">speed</span><span class="p">)</span>
<span class="n">runtime</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">50</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">50</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">speed</span><span class="p">)</span>
<span class="n">runtime</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">50</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">50</span><span class="p">,</span> <span class="mi">1</span><span class="o">*</span><span class="n">speed</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Running with N = 2^2, Q = 2^50, B = 2^50 and taking 0.008078833333333554 seconds.
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Running with N = 2^3, Q = 2^50, B = 2^50 and taking 0.05882129166666653 seconds.
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Running with N = 2^4, Q = 2^50, B = 2^50 and taking 0.66926475 seconds.
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Running with N = 2^5, Q = 2^50, B = 2^50 and taking 7.893876625000001 seconds.
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Squaring <span class="math notranslate nohighlight">\(Q\)</span> along with <span class="math notranslate nohighlight">\(B\)</span> has nearly no impact on the running time for comparably small <span class="math notranslate nohighlight">\(Q\)</span> and <span class="math notranslate nohighlight">\(B\)</span>. For large <span class="math notranslate nohighlight">\(Q\)</span> and <span class="math notranslate nohighlight">\(B\)</span> it approximately doubles the time:</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">runtime</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">25</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">25</span><span class="p">,</span> <span class="mi">100</span><span class="o">*</span><span class="n">speed</span><span class="p">)</span>
<span class="n">runtime</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">50</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="o">*</span><span class="n">speed</span><span class="p">)</span>
<span class="n">runtime</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">500</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">500</span><span class="p">,</span> <span class="mi">25</span><span class="o">*</span><span class="n">speed</span><span class="p">)</span>
<span class="n">runtime</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">25</span><span class="o">*</span><span class="n">speed</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Running with N = 2^2, Q = 2^25, B = 2^25 and taking 0.007676601670000025 seconds.
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Running with N = 2^2, Q = 2^50, B = 2^50 and taking 0.007793034999999975 seconds.
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Running with N = 2^2, Q = 2^500, B = 2^500 and taking 0.010189870000000099 seconds.
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Running with N = 2^2, Q = 2^1000, B = 2^1000 and taking 0.047415053320000025 seconds.
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="application-homomorphic-comparisons">
<h2>Application: Homomorphic Comparisons<a class="headerlink" href="#application-homomorphic-comparisons" title="Permalink to this headline">#</a></h2>
<p>As the last section, we want to present a simple application, which points out, how more complex homomorphic operations, building on additions and multiplications, can be realized.
Since it is crucial for any advanced computer program to handle if-statements, we state a basic algorithm, which checks if <span class="math notranslate nohighlight">\(a \ge b\)</span> in ciphertext space and gives the answer in an encrypted binary form.
This method is due to Section 4.B in <span id="id56">[<a class="reference internal" href="#id76" title="Harika Narumanchi, Dishant Goyal, Nitesh Emmadi, and Praveen Gauravaram. Performance analysis of sorting of fhe data: integer-wise comparison vs bit-wise comparison. In 2017 IEEE 31st International Conference on Advanced Information Networking and Applications (AINA), volume, 902-908. 2017. doi:10.1109/AINA.2017.85.">Narumanchi <em>et al.</em>, 2017</a>]</span>.</p>
<p>More precisely, given two (BFV) ciphertexts <span class="math notranslate nohighlight">\(C_a\)</span> and <span class="math notranslate nohighlight">\(C_a\)</span> including the hidden messages <span class="math notranslate nohighlight">\(a, b \in \Z\)</span>, the algorithm outputs a ciphertext <span class="math notranslate nohighlight">\(C_0\)</span> containing the message <span class="math notranslate nohighlight">\(0\)</span> (i.e. true), if <span class="math notranslate nohighlight">\(a \ge b\)</span>, and otherwise <span class="math notranslate nohighlight">\(C_1\)</span> (i.e. false).</p>
<p>The idea is to compare the difference <span class="math notranslate nohighlight">\(a-b\)</span> with zero since this works for arbitrary <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span>.
Therefore we select a prime <span class="math notranslate nohighlight">\(p\)</span>, such that <span class="math notranslate nohighlight">\(p/2 \ge \abs{a} + \abs{b}\)</span>, because then <span class="math notranslate nohighlight">\(a-b \in (-p/2,p/2]\)</span>.
Now, for all integers <span class="math notranslate nohighlight">\(y\)</span> in <span class="math notranslate nohighlight">\((-p/2,p/2]\)</span>, we determine the polynomial in <span class="math notranslate nohighlight">\(l(y) \in (\Z/p\Z)[y]\)</span> of degree <span class="math notranslate nohighlight">\(p-1\)</span>, which satisfies <span class="math notranslate nohighlight">\(f(y) = 0 \mod p\)</span>, if <span class="math notranslate nohighlight">\(y \ge 0\)</span>, and <span class="math notranslate nohighlight">\(f(y) = 1 \mod p\)</span>, if <span class="math notranslate nohighlight">\(y &lt; 0\)</span>.
This can be done by Lagrange interpolation followed by a modular reduction by <span class="math notranslate nohighlight">\(p\)</span>.</p>
<p>In total, we now define our result ciphertext as <span class="math notranslate nohighlight">\(l(C_a - C_b) = l(C_{a-b})\)</span>, which can be evaluated by the (BFV) scheme’s homomorphic addition/multiplication operations.</p>
<p>Below we implement a homomorphic comparison example with <span class="math notranslate nohighlight">\(a,b \in {-1,0,1}\)</span> and <span class="math notranslate nohighlight">\(p = 5\)</span>.
Thus we have <span class="math notranslate nohighlight">\(l(y) = 3y^4+3y^3-y\)</span> in this case.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">N</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">STD</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">100</span><span class="p">,</span> <span class="mi">1</span>
<span class="n">SK</span><span class="p">,</span> <span class="n">PK</span> <span class="o">=</span> <span class="n">keygen</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">STD</span><span class="p">)</span>
<span class="n">rel_keys</span> <span class="o">=</span> <span class="n">relinearization_key</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">Q</span><span class="o">**</span><span class="mi">3</span><span class="p">,</span> <span class="n">STD</span><span class="p">,</span> <span class="n">SK</span><span class="p">)</span>

<span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span> <span class="c1"># from {-1,0,1}</span>
<span class="n">a_enc</span> <span class="o">=</span> <span class="n">encrypt</span><span class="p">(</span><span class="n">generate_constant_poly</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span> <span class="n">T</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">STD</span><span class="p">,</span> <span class="n">PK</span><span class="p">)</span>
<span class="n">b_enc</span> <span class="o">=</span> <span class="n">encrypt</span><span class="p">(</span><span class="n">generate_constant_poly</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">T</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">STD</span><span class="p">,</span> <span class="n">PK</span><span class="p">)</span>
<span class="n">difference</span> <span class="o">=</span> <span class="n">subtract</span><span class="p">(</span><span class="n">a_enc</span><span class="p">,</span> <span class="n">b_enc</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>

<span class="c1"># Evaluating 3*y^4 + 3*y^3 - y with y = C_{a-b} homomorphically:</span>
<span class="n">y_squared</span> <span class="o">=</span> <span class="n">multiply</span><span class="p">(</span><span class="n">difference</span><span class="p">,</span> <span class="n">difference</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">Q</span><span class="o">**</span><span class="mi">3</span><span class="p">,</span> <span class="n">rel_keys</span><span class="p">)</span>
<span class="n">y_to_the_three</span> <span class="o">=</span> <span class="n">multiply</span><span class="p">(</span><span class="n">y_squared</span><span class="p">,</span> <span class="n">difference</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">Q</span><span class="o">**</span><span class="mi">3</span><span class="p">,</span> <span class="n">rel_keys</span><span class="p">)</span>
<span class="n">y_to_the_four</span> <span class="o">=</span> <span class="n">multiply</span><span class="p">(</span><span class="n">y_squared</span><span class="p">,</span> <span class="n">y_squared</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">Q</span><span class="o">**</span><span class="mi">3</span><span class="p">,</span> <span class="n">rel_keys</span><span class="p">)</span>
<span class="n">three_y_to_the_three</span> <span class="o">=</span> <span class="n">rlwe_multiply_with_poly</span><span class="p">(</span><span class="n">y_to_the_three</span><span class="p">,</span> <span class="n">generate_constant_poly</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">Q</span><span class="p">)</span>
<span class="n">three_y_to_the_four</span> <span class="o">=</span> <span class="n">rlwe_multiply_with_poly</span><span class="p">(</span><span class="n">y_to_the_four</span><span class="p">,</span> <span class="n">generate_constant_poly</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">Q</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="n">three_y_to_the_four</span><span class="p">,</span> <span class="n">subtract</span><span class="p">(</span><span class="n">three_y_to_the_three</span><span class="p">,</span> <span class="n">difference</span><span class="p">,</span> <span class="n">Q</span><span class="p">),</span> <span class="n">Q</span><span class="p">)</span>

<span class="k">if</span> <span class="n">decrypt</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">SK</span><span class="p">)</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;a = </span><span class="si">{</span><span class="n">a</span><span class="si">}</span><span class="s2"> greater equal to b = </span><span class="si">{</span><span class="n">b</span><span class="si">}</span><span class="s2">!&quot;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;a = </span><span class="si">{</span><span class="n">a</span><span class="si">}</span><span class="s2"> smaller than b = </span><span class="si">{</span><span class="n">b</span><span class="si">}</span><span class="s2">!&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>a = -1 smaller than b = 1!
</pre></div>
</div>
</div>
</div>
<p>Remarks:</p>
<ul class="simple">
<li><p>For large <span class="math notranslate nohighlight">\(p\)</span>, the above procedure is quite inefficient, since evaluating <span class="math notranslate nohighlight">\(\mathcal O(p)\)</span> multiplications usually involves many intermediary bootstrapping procedures because of the error growth (see <a class="reference internal" href="#error-after-BFV-multiplication">Theorem 6</a>) and because we have put only the constant coefficient of a message polynomial to use.</p></li>
<li><p>Homomorphic comparison could be utilized to formulate a homomorphic division algorithm.
The naïve division algorithm solely consists of comparisons and subtractions, repeated until the quotient is <span class="math notranslate nohighlight">\(0\)</span> (checked by comparison).
However, there are more sophisticated approaches, see e.g. <span id="id57">[<a class="reference internal" href="#id75" title="Hiroki Okada, Carlos Cid, Seira Hidano, and Shinsaku Kiyomoto. Linear depth integer-wise homomorphic division. In Olivier Blazy and Chan Yeob Yeun, editors, Information Security Theory and Practice, 91–106. Cham, 2019. Springer International Publishing.">Okada <em>et al.</em>, 2019</a>]</span>.</p></li>
</ul>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="bibliography">
<h1>Bibliography<a class="headerlink" href="#bibliography" title="Permalink to this headline">#</a></h1>
<div class="docutils container" id="id58">
<dl class="citation">
<dt class="label" id="id65"><span class="brackets">ACC+18</span><span class="fn-backref">(<a href="#id27">1</a>,<a href="#id54">2</a>)</span></dt>
<dd><p>Martin Albrecht, Melissa Chase, Hao Chen, Jintai Ding, Shafi Goldwasser, Sergey Gorbunov, Shai Halevi, Jeffrey Hoffstein, Kim Laine, Kristin Lauter, Satya Lokam, Daniele Micciancio, Dustin Moody, Travis Morrison, Amit Sahai, and Vinod Vaikuntanathan. Homomorphic encryption security standard. Technical Report, HomomorphicEncryption.org, Toronto, Canada, November 2018.</p>
</dd>
<dt class="label" id="id60"><span class="brackets"><a class="fn-backref" href="#id14">An21</a></span></dt>
<dd><p>J. An. Sample variance of rounded variables. 2021. URL: <a class="reference external" href="https://arxiv.org/abs/2102.08483">https://arxiv.org/abs/2102.08483</a>, <a class="reference external" href="https://doi.org/10.48550/ARXIV.2102.08483">doi:10.48550/ARXIV.2102.08483</a>.</p>
</dd>
<dt class="label" id="id73"><span class="brackets"><a class="fn-backref" href="#id8">BRT20</a></span></dt>
<dd><p>Mădălina Bolboceanu, Miruna Roșca, and Radu Țițiu. Homomorphic encryption: a toy implementation in python. <a class="reference external" href="https://bit-ml.github.io/blog/post/homomorphic-encryption-toy-implementation-in-python/">https://bit-ml.github.io/blog/post/homomorphic-encryption-toy-implementation-in-python/</a>, 2020.</p>
</dd>
<dt class="label" id="id66"><span class="brackets"><a class="fn-backref" href="#id10">CKKS17</a></span></dt>
<dd><p>Jung Hee Cheon, Andrey Kim, Miran Kim, and Yongsoo Song. Homomorphic encryption for arithmetic of approximate numbers. In Tsuyoshi Takagi and Thomas Peyrin, editors, <em>Advances in Cryptology – ASIACRYPT 2017</em>, 409–437. Cham, 2017. Springer International Publishing.</p>
</dd>
<dt class="label" id="id72"><span class="brackets">Era20</span><span class="fn-backref">(<a href="#id6">1</a>,<a href="#id7">2</a>)</span></dt>
<dd><p>Saroja Erabelli. A python library for fully homomorphic encryption. <a class="reference external" href="https://github.com/sarojaerabelli/py-fhe">https://github.com/sarojaerabelli/py-fhe</a>, 2020.</p>
</dd>
<dt class="label" id="id67"><span class="brackets">FV12</span><span class="fn-backref">(<a href="#id4">1</a>,<a href="#id29">2</a>,<a href="#id31">3</a>,<a href="#id32">4</a>,<a href="#id33">5</a>,<a href="#id34">6</a>,<a href="#id35">7</a>,<a href="#id36">8</a>)</span></dt>
<dd><p>Junfeng Fan and Frederik Vercauteren. Somewhat practical fully homomorphic encryption. Cryptology ePrint Archive, Paper 2012/144, 2012. <a class="reference external" href="https://eprint.iacr.org/2012/144">https://eprint.iacr.org/2012/144</a>. URL: <a class="reference external" href="https://eprint.iacr.org/2012/144">https://eprint.iacr.org/2012/144</a>.</p>
</dd>
<dt class="label" id="id74"><span class="brackets"><a class="fn-backref" href="#id2">Gen09</a></span></dt>
<dd><p>Craig Gentry. <em>A fully homomorphic encryption scheme</em>. PhD thesis, Stanford University, 2009. <a class="reference external" href="crypto.stanford.edu/craig">crypto.stanford.edu/craig</a>.</p>
</dd>
<dt class="label" id="id70"><span class="brackets"><a class="fn-backref" href="#id43">GSW13</a></span></dt>
<dd><p>Craig Gentry, Amit Sahai, and Brent Waters. Homomorphic encryption from learning with errors: conceptually-simpler, asymptotically-faster, attribute-based. Cryptology ePrint Archive, Paper 2013/340, 2013. <a class="reference external" href="https://eprint.iacr.org/2013/340">https://eprint.iacr.org/2013/340</a>. URL: <a class="reference external" href="https://eprint.iacr.org/2013/340">https://eprint.iacr.org/2013/340</a>.</p>
</dd>
<dt class="label" id="id61"><span class="brackets"><a class="fn-backref" href="#id15">HPS18</a></span></dt>
<dd><p>Shai Halevi, Yuriy Polyakov, and Victor Shoup. An improved rns variant of the bfv homomorphic encryption scheme. Cryptology ePrint Archive, Paper 2018/117, 2018. <a class="reference external" href="https://eprint.iacr.org/2018/117">https://eprint.iacr.org/2018/117</a>. URL: <a class="reference external" href="https://eprint.iacr.org/2018/117">https://eprint.iacr.org/2018/117</a>, <a class="reference external" href="https://doi.org/10.1007/978-3-030-12612-4_5">doi:10.1007/978-3-030-12612-4_5</a>.</p>
</dd>
<dt class="label" id="id69"><span class="brackets">KDE+21</span><span class="fn-backref">(<a href="#id5">1</a>,<a href="#id39">2</a>,<a href="#id40">3</a>,<a href="#id48">4</a>,<a href="#id51">5</a>,<a href="#id52">6</a>)</span></dt>
<dd><p>Andrey Kim, Maxim Deryabin, Jieun Eom, Rakyong Choi, Yongwoo Lee, Whan Ghang, and Donghoon Yoo. General bootstrapping approach for rlwe-based homomorphic encryption. Cryptology ePrint Archive, Paper 2021/691, 2021. <a class="reference external" href="https://eprint.iacr.org/2021/691">https://eprint.iacr.org/2021/691</a>. URL: <a class="reference external" href="https://eprint.iacr.org/2021/691">https://eprint.iacr.org/2021/691</a>.</p>
</dd>
<dt class="label" id="id63"><span class="brackets"><a class="fn-backref" href="#id24">LStehle12</a></span></dt>
<dd><p>Adeline Langlois and Damien Stehlé. Hardness of decision (r)lwe for any modulus. <em>IACR Cryptol. ePrint Arch.</em>, 2012:91, 2012.</p>
</dd>
<dt class="label" id="id64"><span class="brackets"><a class="fn-backref" href="#id26">LMK+22</a></span></dt>
<dd><p>Yongwoo Lee, Daniele Micciancio, Andrey Kim, Rakyong Choi, Maxim Deryabin, Jieun Eom, and Donghoon Yoo. Efficient fhew bootstrapping with small evaluation keys, and applications to threshold homomorphic encryption. Cryptology ePrint Archive, Paper 2022/198, 2022. <a class="reference external" href="https://eprint.iacr.org/2022/198">https://eprint.iacr.org/2022/198</a>. URL: <a class="reference external" href="https://eprint.iacr.org/2022/198">https://eprint.iacr.org/2022/198</a>.</p>
</dd>
<dt class="label" id="id68"><span class="brackets"><a class="fn-backref" href="#id30">LPR13</a></span></dt>
<dd><p>Vadim Lyubashevsky, Chris Peikert, and Oded Regev. A toolkit for ring-lwe cryptography. Cryptology ePrint Archive, Paper 2013/293, 2013. <a class="reference external" href="https://eprint.iacr.org/2013/293">https://eprint.iacr.org/2013/293</a>. URL: <a class="reference external" href="https://eprint.iacr.org/2013/293">https://eprint.iacr.org/2013/293</a>.</p>
</dd>
<dt class="label" id="id71"><span class="brackets"><a class="fn-backref" href="#id44">MP20</a></span></dt>
<dd><p>Daniele Micciancio and Yuriy Polyakov. Bootstrapping in fhew-like cryptosystems. Cryptology ePrint Archive, Paper 2020/086, 2020. <a class="reference external" href="https://eprint.iacr.org/2020/086">https://eprint.iacr.org/2020/086</a>. URL: <a class="reference external" href="https://eprint.iacr.org/2020/086">https://eprint.iacr.org/2020/086</a>.</p>
</dd>
<dt class="label" id="id76"><span class="brackets"><a class="fn-backref" href="#id56">NGEG17</a></span></dt>
<dd><p>Harika Narumanchi, Dishant Goyal, Nitesh Emmadi, and Praveen Gauravaram. Performance analysis of sorting of fhe data: integer-wise comparison vs bit-wise comparison. In <em>2017 IEEE 31st International Conference on Advanced Information Networking and Applications (AINA)</em>, volume, 902–908. 2017. <a class="reference external" href="https://doi.org/10.1109/AINA.2017.85">doi:10.1109/AINA.2017.85</a>.</p>
</dd>
<dt class="label" id="id75"><span class="brackets"><a class="fn-backref" href="#id57">OCHK19</a></span></dt>
<dd><p>Hiroki Okada, Carlos Cid, Seira Hidano, and Shinsaku Kiyomoto. Linear depth integer-wise homomorphic division. In Olivier Blazy and Chan Yeob Yeun, editors, <em>Information Security Theory and Practice</em>, 91–106. Cham, 2019. Springer International Publishing.</p>
</dd>
<dt class="label" id="id62"><span class="brackets">Pei15</span><span class="fn-backref">(<a href="#id3">1</a>,<a href="#id17">2</a>,<a href="#id18">3</a>,<a href="#id19">4</a>,<a href="#id21">5</a>,<a href="#id22">6</a>,<a href="#id23">7</a>,<a href="#id25">8</a>,<a href="#id49">9</a>)</span></dt>
<dd><p>Chris Peikert. A decade of lattice cryptography. Cryptology ePrint Archive, Paper 2015/939, 2015. <a class="reference external" href="https://eprint.iacr.org/2015/939">https://eprint.iacr.org/2015/939</a>. URL: <a class="reference external" href="https://eprint.iacr.org/2015/939">https://eprint.iacr.org/2015/939</a>.</p>
</dd>
<dt class="label" id="id59"><span class="brackets"><a class="fn-backref" href="#id13">Tri84</a></span></dt>
<dd><p>A. R. Tricker. Effects of rounding on the moments of a probability distribution. <em>Journal of the Royal Statistical Society. Series D (The Statistician)</em>, 33(4):381–390, 1984. URL: <a class="reference external" href="http://www.jstor.org/stable/2987741">http://www.jstor.org/stable/2987741</a> (visited on 2022-09-21).</p>
</dd>
</dl>
</div>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "robinkoestler/A-survey-on-modern-fully-homomorphic-encryption",
            ref: "main",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By Robin Köstler<br/>
  
      &copy; Copyright 2022.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>